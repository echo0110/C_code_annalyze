/* vim: ts=4:et:ai:ci:sw=4
*/
/******************************************************************************
 *
 * ARICENT -
 *
 * Copyright (C) 2012 Aricent Inc . All Rights Reserved.
 *
 *******************************************************************************
 *
 * $$Id: rrm_ue_mgr.c $
 *
 *******************************************************************************
 *
 * File Description: This file have the information about process message and 
                     manipulation of UE memory utilization
 *      
 *
 *******************************************************************************
 *Revision Details
 *----------------------
 *   DATE            AUTHOR      REFERENCE       REASON
 *   3 Apr,2012      gur11059    Initial
 *   13 MAY,2012     gur30487                    CLPC regarding changes
 *   28 MAY,2012     gur30784                    Emergency feature changes
 *   7 June,2012     gur29220                    CS-Fallback & Redirection
 *   26 Jul,2012     gur27278                    Removed compilation warnings
 *   19 Dec,2012     gur11056                    Fix for SPR 285
 *   29 Jan,2013     gur27278                    Added code for SPS feature
 *   25 Apr 2014     gur31824     SPR 10729      RRM is not releasing the UE
 *                                               when RRC sends
 *                                               RRC_RRM_LOCAL_ERROR_IND to
 *                                               RRM for UE with single rabs
 *   28 Apr,2014     gur27356    SPR-10397       Updated for PDCP KPI stat.
 *    2 May 2014     gur25767     SPR 10538      Queueing implemented for Meas Config
 *                               /CSR 69389      CGI req.
 *   16 May,2014     gur13083    SPR 10869       Modified ECN function to
 *                                               calculate UL/DL status separately
 *   16 Apr,2014     gur32417                    Carrier Aggregation Stage 3 code
 *                                               added
 *   27 May,2014     gur29831    SPR-11366       UE Rel Fix.
 *   30 May 2014     gur34951    SPR 8004        ECID Enhancement for Inter
 *                                               Frequency Cells
 *   18 June 2014     gur25767    SPR 10538      Queueing implemented for Meas Config
 *                                               in sequence or not..
 *   17 June,2014    gur35095    SPR-11943       rrmh_fsm calls is replaced with 
 *                                               rrm_uem_process_fsm
 *                               /CSR 69389      CGI req.
 *   17 June,2014    gur35095    SPR-11943       rrmh_fsm calls is replaced with
 *                                               rrm_uem_process_fsm and initilize
 *                                               proc variable with PNULL.
 *   18 June,2014    gur21481    SPR 11648       Deactive count of cell will 
 *                                               not be increased.If cell is stopped.
 *    2 July,2014    gur35095    SPR 11907       Broadcast cell_del_req to all cells
 *                                               after resp from all cells, Send
 *                                               cell_del_req to rrc
 *   02 July,2014    gur26515    SPR-10450       Implemented DRX Staggering. 
 *   02 July,2014    gur26515    SPR-10450       Implemented DRX Staggering. 
 *   12 July,2014    gur30784    SPR-12512       UE sync status handling
 *   14 July,2014    gur27356    SPR-12570       RRM should not send ho_report
 *   22 July,2014    gur27356    SPR-12644       Some issue in Too Late Handover (MRO).
 *   22 July,2014    gur35095    SPR-12658       Reestab Config Fix .
 *   30 July,2014    gur21481    SPR-12059       wrong cell index was set
 *   4  Aug,2014     gur29831                     ue reestab conf req fix
 *   08 Aug, 2014    gur27356    SPR-12923       Handover failure report not sends when too
 *                                               late handover is triggered.
 *   27 Aug,2014     gur27356    SPR-13375       RRM sending HO Failure report with value 0.
 *   06 Nov,2014     gur33103    SPR 13332       Fix regarding Issue in RRM enqueue if Erb delete message
                                                  between ongoing Meas config procedure
 *   Oct 2014        gur32505    eICIC Feature   eICIC feature support at UE side
                                 Development     
 ****************************************************************************/
/****************************************************************************
 * Standard Library Includes
 ****************************************************************************/

/****************************************************************************
 * Project Includes
 ****************************************************************************/
#include "rrm_stats.h"
#include "rrm_utils.h"
#include "rrm_ue_fsm.h"
#include "rrm_ue_mgr.h"
#include "rrc_ext_api.h"
#include "rrm_cell_rrmim_intf.h"
#include "rrm_uem_rrmim_intf.h"
#include "l3_api_parser.h"
#include "l3_api_composer.h"
#include "rrm_rrc_ue_intf.h"
#include "rrm_l2_intf.h"
#include "rrm_uem_cellm_intf.h"
#include "rrm_cell_mgr.h"
#include "rrm_events.h"
#include "rrc_x2apRrm_intf.h"
#include "rrc_x2apCommon_intf.h"
#include "x2ap_rrm_parser.h"
#include "s1ap_rrm_composer.h"
#ifdef LTE_EMBMS_SUPPORTED
#include "rrm_cell_embms.h"
#include "rrm_ue_embms.h"
#endif
/****************************************************************************
  Private Definitions
 ****************************************************************************/

/****************************************************************************
  Private Types
 ****************************************************************************/

/* warnings removal: proper initialization of structure 
   'rrm_uem_global_proc_t', 10/05/2004 */ 
rrm_uem_global_proc_t g_uem_gbl_proc = {{RRM_ZERO},RRM_ZERO,RRM_ZERO};
/****************************************************************************
 * Exported Variables
 ****************************************************************************/
extern rrm_void_t rrm_ue_process_timer_msg (QTIMER timer_id, rrm_void_t *p_buf, rrm_void_t *p_context);
extern rrm_bool_et rrm_check_if_ue_has_dc_split_bearer (rrm_ue_context_t *p_ue_context);
extern rrm_return_et rrm_ue_get_new_lc_id_for_bearer_change(rrm_ue_context_t *p_ue_context, rrm_ue_erab_setup_item_t   *p_erab_item);
extern rrm_bool_et rrm_check_is_endc_x2ap_link_established();
extern rrm_bool_et rrm_check_is_ue_support_endc(rrm_ue_context_t *p_ue_context);
extern rrm_bool_et rrm_check_frequancy_band(rrm_ue_context_t *p_rrm_ue_context);
/* SPR 20652 Fix Start */
/* Code Removed */
/* SPR 20652 Fix End */

YLIST                   ue_erab_priority_list[RRM_MAX_ERAB_PRIORITY];
YLIST 			ue_priority_list[RRM_MAX_UE_PRIORITY];

rrm_gap_offset_repository_t    rrm_gap_offset0_repository[MAX_USABLE_GP0_OFFSET];
rrm_gap_offset_repository_t    rrm_gap_offset1_repository[MAX_USABLE_GP1_OFFSET];
/* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED
rrm_gap_offset_repository_t    rrm_gap_offset4_repository[MAX_USABLE_GP4_OFFSET];
rrm_gap_offset_repository_t    rrm_gap_offset5_repository[MAX_USABLE_GP5_OFFSET];
#endif
/* ENDC_MEAS_CHANGES_END */

const S8 * UE_FSM_STATE[]=
{
     (const S8 *)"RRM_UE_STATE_IDLE",                /*!< UEM FSM state 0 */
     (const S8 *)"RRM_UE_WAIT_FOR_CAP_IND",           /*!< UEM FSM state 1 */
     (const S8 *)"RRM_UE_STATE_ACTIVE",              /*!< UEM FSM state 2 */
     (const S8 *)"RRM_UE_STATE_HO_ONGOING",          /*!< UEM FSM state 3 */
     /*SPR_17893_START*/
     (const S8 *)"RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES", /*!< UEM FSN state 4 */
     (const S8 *)"RRM_UE_MAX_STATE"                  /*!< UEM FSN state 5 */
    /*SPR_17893_END*/

};

const S8 * UE_FSM_EVENT[]=
{

    (const S8 *)"RRC_RRM_UE_ADMISSION_REQ_EVENT", /*!< FSM event 0    */
    (const S8 *)"RRC_RRM_UE_ADMISSION_CNF_EVENT", /*!< FSM event 1    */
    (const S8 *)"RRC_RRM_UE_CAPABILITY_IND_EVENT",/*!< FSM event 2    */
    (const S8 *)"RRC_RRM_UE_CAPABILITY_ENQUIRY_RESP_EVENT",
    /*!< FSM event 3    */
    (const S8 *)"RRC_RRM_ERB_SETUP_REQUEST_EVENT",/*!< FSM event 4    */
    (const S8 *)"RRC_RRM_ERB_SETUP_CNF_EVENT",    /*!< FSM event 5    */
    (const S8 *)"RRC_RRM_MEASURMENT_RESULTS_IND_EVENT",
    /*!< FSM event 6    */
    (const S8 *)"RRC_RRM_ERB_MODIFY_REQUEST_EVENT",
    /*!< FSM event 7    */
    (const S8 *)"RRC_RRM_ERB_RELEASE_REQUEST_EVENT",
    /*!< FSM event 8    */
    (const S8 *)"RRC_RRM_ERB_MODIFY_CNF_EVENT",
    /*!< FSM event 9    */
    (const S8 *)"RRC_RRM_ERB_RELEASE_CNF_EVENT",
    /*!< FSM event 10   */
    (const S8 *)"RRC_RRM_UE_RELEASE_REQ_EVENT",   /*!< FSM event 11   */
    (const S8 *)"RRC_RRM_UE_HO_ADM_REQ_EVENT",    /*!< FSM event 12   */
    (const S8 *)"RRC_RRM_UE_HO_ADM_CNF_EVENT",    /*!< FSM event 13   */
    (const S8 *)"RRC_RRM_UE_HO_CMD_REQ_EVENT",    /*!< FSM event 14   */
    (const S8 *)"RRC_RRM_HO_FAILURE_EVENT",       /*!< FSM event 15   */
    (const S8 *)"RRC_RRM_HO_CANCEL_RESP_EVENT",   /*!< FSM event 16   */
    (const S8 *)"RRC_RRM_UE_CONTEXT_MOD_REQ_EVENT",   /*!< FSM event 17       */
    (const S8 *)"RRC_RRM_UE_CONTEXT_MOD_CNF_EVENT",   /*!< FSM event 18       */
    (const S8 *)"RRC_RRM_MEAS_CONFIG_RESP_EVENT",     /*!< FSM event 19       */
    /* MC, MR & HO Start */
    (const S8 *)"RRC_RRM_HO_RESTRICTION_LIST_IND_EVENT",/*!< FSM event 20       */
    (const S8 *)"RRM_UE_TIMER_EXPIRY_EVENT",          /*!< FSM event 21       */
    /* MC, MR & HO End */
    /*LTE_RRM_TM_SWITCH_START*/
    (const S8 *)"RRC_RRM_UE_RECONFIG_RESP_EVENT",     /*!< FSM event 22   */
    (const S8 *)"RRM_MAC_PERIODIC_REPORTS_IND_EVENT",     /*!< FSM event 23*/
    /*csg start*/
    /*PROXIMITY IND START*/
    (const S8 *)"RRC_RRM_PROXIMITY_IND_EVENT",         /*!< FSM event 24*/
    /*PROXIMITY IND END*/
    /*csg end*/
    /*RRC_RRM RLF IND start*/
    (const S8 *)"RRC_RRM_RLF_IND_EVENT",         /*!< FSM event 25*/
    /*RRC_RRM RLF IND end*/
    /*LTE_RRM_TM_SWITCH_END*/
    (const S8 *)"RRC_RRM_UE_CDMA2000_MOB_INFO_REQ_EVENT",  /*!<FSM event 26*/
    (const S8 *)"RRC_RRM_DL_NAS_TRANSPORT_IND_EVENT",              /*!<FSM event 27*/
    (const S8 *)"RRC_RRM_INTRA_ENB_HO_IND_EVENT",          /*!<FSM event 28 */
    /* UE positioning start */
    (const S8 *)"S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ_EVENT",            /*!<FSM event 29 */
    (const S8 *)"S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND_EVENT", /*!<FSM event 30 */
    (const S8 *)"S1AP_RRM_LPPA_ERROR_IND_EVENT",                     /*!<FSM event 31 */
    /* UE positioning end */
    (const S8 *)"RRC_RRM_INTER_FREQ_MEAS_IND_EVENT",           /*!<FSM event 32 */
    (const S8 *)"RRC_RRM_LOCAL_ERROR_IND_EVENT",                     /*!<FSM event 33 */
    (const S8 *)"RRC_RRM_LIPA_HO_REQUIRED_EVENT",                    /*!<FSM event 34 */
    /*SPR-695 Fix Starts*/
    (const S8 *)"RRM_RELEASE_LOW_PRIORITY_UE_REL_EVENT",                /*!<FSM event 35 */
    /*SPR-695 Fix Ends*/
    /* SPR 12512 Fix Start */
    (const S8 *)"RRC_RRM_UE_SYNC_STATUS_IND_EVENT",       /*!<FSM event 36 */
    /* SPR 12512 Fix End */
    /* SPR 9216:MRO enhancement start */
    (const S8 *)"RRC_RRM_UE_REESTAB_CONFIG_CNF_EVENT",          /*!<FSM event 37 */
    /* SPR 9216:MRO enhancement end */
    /*SPR 11535:start*/
   
   /* SPR 21598 start */
    (const S8 *)"RRM_UE_CGI_TIMER_EXPIRY_EVENT",
   /* SPR 21598 end */
    (const S8 *)"RRC_RRM_UE_INACTIVE_EVENT",
    /*SPR 11535:end*/
/* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
    (const S8 *)"RRC_RRM_UE_DC_BEARER_CHANGE_CNF_EVENT",
#endif
/* OPTION3X Changes End */
    (const S8 *)"RRM_UE_MAX_EVENT"                /*!< FSM MAX event  */

};


static int 
rrm_ue_priority_list_data_compare (
    const rrm_void_t *p_key1,
    const rrm_void_t *p_key2
    );
static const rrm_void_t * rrm_ue_delete_req_from_ue_priority_list_key(const YLNODE *p_ylnode);

static rrm_return_et 
find_ngbr_non_preemptable_erb_present(
	rrm_ue_context_t *
	);

/* SPR 14226 start */
/* SPR 14226 end*/
/*Bug_721_changes_start*/
/*lines deleted*/
/*Bug_721_changes_end*/

static const rrm_void_t * rrm_ue_del_req_object_id_keyof(const YLNODE *p_ylnode);

static int rrm_ue_erb_list_data_compare (
    	const rrm_void_t *p_key1,
    	const rrm_void_t *p_key2
	);
meas_cdma_node_t *
rrmcm_find_cdma_meas_context
(
    U16                   arfcn,
    rrm_son_cdma_band_class_et              band_class,
    rrm_cell_context_t   *p_cell_ctx /*cell context*/
);




meas_cdma_node_t *
rrmcm_find_cdma_meas_context
(
    U16                   arfcn,
    rrm_son_cdma_band_class_et              band_class,
    rrm_cell_context_t   *p_cell_ctx /*cell context*/
);

/*SPR-695 Fix Starts*/
static rrm_return_et 
rrm_uem_handle_low_priority_ue_del_req
(
        rrm_ue_global_context_t     *p_rrm_glb_ctxt,
        rrm_void_t *p_api /*Input Api buffer*/
);
/* SPR 16406 Start */
static rrm_return_et
rrm_uem_handle_awaited_ho_trigger_ind
(
 rrm_void_t *p_api_buf
 );
/* SPR 16406 End */
/*SPR-695 Fix Ends*/


/* eICIC_PHASE_1_2_CHANGES_START */
static void 
rrm_calculate_victim_ue
(
 rrm_ue_global_context_t *p_ue_glbl_ctxt,
 rrm_cell_context_t *p_cell_context
 );
/* eICIC_PHASE_1_2_CHANGES_END */
/* SPR 20652 Fix Start */
/****************************************************************************
 * Function Name  : rrm_ue_get_first_node_ctxt 
 * Inputs         : p_ue_node rrm_seq_data_info_t node
 *                : p_ue_context UE Context 
 * Outputs        :  
 * Returns        : void
 * Description    : This function is used to fetch the first node in the
 *                   UE Context List.
 ****************************************************************************/
rrm_void_t
rrm_ue_get_first_node_ctxt
(
 rrm_seq_data_info_t *p_ue_node,
 rrm_ue_context_t    **p_ue_context,
 rrm_cell_index_t    cell_index
 )
{
    rrm_cell_context_t  *p_rrm_cell_ctx = RRM_PNULL;
    rrm_ue_shelf_node_t *p_next_ue_node = RRM_PNULL;
    rrm_ue_shelf_node_t *p_tmp_node     = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    p_rrm_cell_ctx = rrm_cellm_get_cell_context(cell_index);
    /* SPR 21618 Fix Start */	
    p_ue_node->choice = RRM_INVALID_UE_NODE_PRESENT;
    *p_ue_context = RRM_PNULL;
    /* SPR 21618 Fix End */	

    if(RRM_PNULL != p_rrm_cell_ctx)
    {
        if((p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list != RRM_NULL) && 
                (p_rrm_cell_ctx->rrm_ue_db.head_idx != RRM_INVALID_UE_INDEX))
        {
            if(RRM_ZERO != ylCount(&(p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_rrm_cell_ctx->rrm_ue_db.head_idx].rrm_ue_info_list)))
            {
                p_tmp_node = (rrm_ue_shelf_node_t*)ylFirst(&(p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_rrm_cell_ctx->rrm_ue_db.head_idx].rrm_ue_info_list));
                if(RRM_PNULL != p_tmp_node)
                {
                    *p_ue_context = (rrm_ue_context_t*)(p_tmp_node->p_ue_context);
                    p_next_ue_node = (rrm_ue_shelf_node_t *)ylNext(&p_tmp_node->node);
                    if(RRM_PNULL == p_next_ue_node)
		    {
			    /* SPR 21618 Fix Start */	
			    p_ue_node->u.nxt_idx = p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_rrm_cell_ctx->rrm_ue_db.head_idx].next_idx; 
			    if (RRM_INVALID_UE_INDEX != p_ue_node->u.nxt_idx)
			    {
				    p_ue_node->choice = RRM_NEXT_UE_INDEX_PRESENT;
			    }
			    /* SPR 21618 Fix End */	
		    }
                    else
                    {
                        p_ue_node->choice = RRM_NEXT_NODE_FOR_SAME_UE_INDEX_PRESENT;
                        p_ue_node->u.p_nxt_node = p_next_ue_node; 
                    }
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Cell Context not found for cell index [%d]", cell_index);
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_ue_get_next_node_ctxt 
 * Inputs         : p_ue_node rrm_seq_data_info_t
 *                : p_ue_context UE Context 
 * Outputs        :  
 * Returns        : next UE context node of type rrm_seq_data_info_t
 * Description    : This function is used to fetch the next node in the
 *                   UE Context List.
 ****************************************************************************/
rrm_seq_data_info_t 
rrm_ue_get_next_node_ctxt
(
    rrm_seq_data_info_t *p_ue_node,
    rrm_ue_context_t    **p_ue_context,
    rrm_cell_index_t    cell_index
)
{
    rrm_cell_context_t  *p_rrm_cell_ctx = RRM_PNULL;
    rrm_ue_shelf_node_t *p_tmp_node     = RRM_PNULL;
    rrm_ue_shelf_node_t *p_next_ue_node = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = rrm_cellm_get_cell_context(cell_index);

    if(RRM_PNULL != p_rrm_cell_ctx)
    {
        if (RRM_PNULL != p_ue_node)
        {
		/* SPR 21618 Fix Start */	
            switch (p_ue_node->choice)
            {
                case RRM_NEXT_UE_INDEX_PRESENT:
                p_tmp_node = (rrm_ue_shelf_node_t *)ylFirst(&(p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_ue_node->u.nxt_idx].rrm_ue_info_list));   
                *p_ue_context = (rrm_ue_context_t*)(p_tmp_node->p_ue_context); 
                break;

                case RRM_NEXT_NODE_FOR_SAME_UE_INDEX_PRESENT:
                p_tmp_node = (rrm_ue_shelf_node_t *)(p_ue_node->u.p_nxt_node);
                *p_ue_context = (rrm_ue_context_t*)(p_tmp_node->p_ue_context);
                break;

                default:
                ue_node.choice = RRM_INVALID_UE_NODE_PRESENT;
                *p_ue_context = RRM_PNULL;
                break;
            }

            if (RRM_PNULL != p_tmp_node)
            {
                p_next_ue_node = (rrm_ue_shelf_node_t *)ylNext(&p_tmp_node->node); 
                if(RRM_PNULL == p_next_ue_node)
                {
                    ue_node.u.nxt_idx = p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[((*p_ue_context)->ue_index)].next_idx; 
                    /*SPR21746 Changes start*/
                    if (RRM_INVALID_UE_INDEX != ue_node.u.nxt_idx)
                    {
                    ue_node.choice = RRM_NEXT_UE_INDEX_PRESENT;
                    }
                    else
                    {
                      ue_node.choice = RRM_INVALID_UE_NODE_PRESENT;
                      *p_ue_context = RRM_PNULL;
                    }
                    /*SPR21746 Changes end*/
                }
                else
                {
                    ue_node.choice = RRM_NEXT_NODE_FOR_SAME_UE_INDEX_PRESENT;
                    ue_node.u.p_nxt_node = p_next_ue_node; 
                }
		/* SPR 21618 Fix End */	
            }
        }
        else
        {
            ue_node.choice = RRM_INVALID_UE_NODE_PRESENT;
            *p_ue_context = RRM_PNULL;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Cell Context not found for cell index [%d]", cell_index);
        *p_ue_context = RRM_PNULL;
        ue_node.choice = RRM_INVALID_UE_NODE_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
    return ue_node;
}
/* SPR 20652 Fix End */

/* uplink mu mimo chnage end*/

/******************************************************************************
  *   FUNCTION NAME: rrm_is_ue_lie_on_provide_cell_region
  *   DESCRIPTION:
  *       Find th Ue lie on given cell region or not
  *   RETURNS:
  *       rrm_bool_et
 ******************************************************************************/
rrm_bool_et
rrm_does_ue_lie_on_provided_cell_region( rrm_cell_region_et  cell_region,
                                         rrm_ue_context_t   *p_ue_context,
                                         U32                 uplink_pathloss_threshold )
{

    rrm_bool_et       is_ue_lie_on_given_cell_region = RRM_FALSE;
    U32               uplink_pathloss_of_ue = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* SPR 21496 Fix Start */ 
    if( (p_ue_context->p_ue_mac_report->report_index) > RRM_ONE )
      /* SPR 21496 Fix End */ 
    {
        /* + SPR 20078 */
        uplink_pathloss_of_ue = p_ue_context->ue_avg_stats.uplinkPathLossValue;
        /* - SPR 20078 */
 
        if( RRM_CELL_CENTER_UE == cell_region )
        {
            if( uplink_pathloss_of_ue <= uplink_pathloss_threshold )
            {
                is_ue_lie_on_given_cell_region = RRM_TRUE;

                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "[UE:%d] lies on given CELL_CENTER region [%d]",
                p_ue_context->ue_index,cell_region);

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "[UE:%d] does not lie on given CELL_CENTER region [%d]",
                p_ue_context->ue_index,cell_region);
            }
        }
        else if( RRM_CELL_EDGE_UE == cell_region )
        {
            if( uplink_pathloss_of_ue > uplink_pathloss_threshold )
            {
                is_ue_lie_on_given_cell_region = RRM_TRUE;

                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "[UE:%d] lies on given CELL_EDGE region [%d]",
                p_ue_context->ue_index,cell_region);
          
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "[UE:%d] does not lie on given CELL_EDGE region [%d]",
                p_ue_context->ue_index,cell_region);
            }
        }
      
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
        "No mac stats report available for [UE:%d] ",p_ue_context->ue_index);
    }   
 
    RRM_UT_TRACE_EXIT();   /* Coverity: CID 41585 Rel2.1.3*/
    return is_ue_lie_on_given_cell_region;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_which_cell_regionof_ue
 *   DESCRIPTION:
 *       Find th Ue are eligible for uplink mu mimo
 *   RETURNS:
 *       void
 ******************************************************************************/
rrm_cell_region_et
rrm_which_cell_regionof_ue(
                           rrm_ue_context_t   *p_ue_context,
                           U32                 uplink_pathloss_threshold)
{
    rrm_cell_region_et cell_region = RRM_CELL_CENTER_UE; 
    U32                uplink_pathloss_of_ue = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
   
    /* SPR 21496 Fix Start */ 
    if(p_ue_context->p_ue_mac_report->report_index > RRM_ONE )
    /* SPR 21496 Fix End */ 
    {   
        /* + SPR 20078 */
        uplink_pathloss_of_ue = p_ue_context->ue_avg_stats.uplinkPathLossValue;
        /* - SPR 20078 */
        if( uplink_pathloss_of_ue > uplink_pathloss_threshold )
        {
            cell_region = RRM_CELL_EDGE_UE;
	    /* SPR 18891 fix start */
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
            "[UE:%d] cell region : %d Average Pathloss value : %d",
            p_ue_context->ue_index,cell_region, uplink_pathloss_of_ue);
	    /* SPR 18891 fix stop */
        }
        else
        {
            /* SPR 18891 fix start */
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
            "[UE:%d] cell region : %d Average Pathloss value : %d",
            p_ue_context->ue_index,cell_region, uplink_pathloss_of_ue);
            /* SPR 18891 fix stop */
        }

    }
    else
    {

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
        "No mac stats report available for [UE:%d] ",p_ue_context->ue_index);
    }

    RRM_UT_TRACE_EXIT();

    return cell_region;
}


/******************************************************************************
  *   FUNCTION NAME: rrm_find_eligible_ue_for_ul_mu_mimo
  *   DESCRIPTION:
  *       Find th Ue are eligible for uplink mu mimo
  *   RETURNS:
  *       rrm_return_et
 ******************************************************************************/
rrm_bool_et
rrm_find_eligible_ue_for_ul_mu_mimo( U32                  uplink_pathloss_threshold,
                                     U32                **p_cell_region[RRM_MAX_CELL_REGION_ALLOWED],
                                     U16                  region_count[RRM_MAX_CELL_REGION_ALLOWED],
                                     rrm_cell_region_et   cell_region,
                                     rrm_bool_et          both_cell,
			             rrm_ue_context_t    *p_ue_context,
                                     rrm_bool_et          only_single_region )
{
    rrm_bool_et             break_loop = RRM_FALSE;
    U16                     index = RRM_ZERO;
    rrm_bool_et             does_ue_lie_in_region = RRM_FALSE; 
    rrm_cell_region_et      region = RRM_CELL_CENTER_UE ;

    RRM_UT_TRACE_ENTER();

    if( RRM_PNULL == p_cell_region[RRM_CELL_CENTER_UE] ||
        RRM_PNULL == p_cell_region[RRM_CELL_EDGE_UE] ||
	RRM_PNULL == p_ue_context )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
        "NULL Pointer Exception for p_cell_region");
        break_loop = RRM_TRUE;
    }
    else
    {
        if(both_cell)
	{
            if( (region_count[RRM_CELL_CENTER_UE]) >= MAX_NUM_OF_UE &&
                (region_count[RRM_CELL_EDGE_UE]) >= MAX_NUM_OF_UE )
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "Maximum number of index is reached for both region of cells");
                break_loop = RRM_TRUE; 
            }
            else
            {  
                region = rrm_which_cell_regionof_ue(p_ue_context,uplink_pathloss_threshold);
                     
                if( region_count[region] < MAX_NUM_OF_UE )
                { 
                    index = region_count[region]; 
                    (region_count[region])++;
                        
                    p_cell_region[region][index] = (U32 *)p_ue_context;

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "UE is selected for uplink mu mimo operation in cell region [%d]",region);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "MAX_NUM_OF_UE of UE already selected for uplink mu mimo operation in \
                    for this cell region [%d], so not considering this UE,but we have another \
                    region to search the UE",region);
                }
            }

        }
        else
        {
            if( (region_count[cell_region]) < MAX_NUM_OF_UE )
            { 
             
                does_ue_lie_in_region = rrm_does_ue_lie_on_provided_cell_region( cell_region,
                                                                              p_ue_context,
                                                                              uplink_pathloss_threshold );
                if( does_ue_lie_in_region )
                {
                    index = region_count[cell_region];
                    p_cell_region[cell_region][index] = (U32 *)p_ue_context;
                 
                    (region_count[cell_region])++;
 
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "UE is selected for uplink mu mimo operation in cell region [%d]",cell_region);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "UE is not selected for uplink mu mimo operation, because UE does not lie \
                    in cell region [%d]",cell_region);
                }
            }
            else
            {
                if(only_single_region)
                {
                    break_loop = RRM_TRUE;
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Maximum number of UE's are filled for only single region [%d]",cell_region);
                }
                else if( (region_count[RRM_CELL_CENTER_UE]) >= MAX_NUM_OF_UE &&
                         (region_count[RRM_CELL_EDGE_UE]) >= MAX_NUM_OF_UE )
                {
                    break_loop = RRM_TRUE;
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Maximum number of UE's are filled for both region of cell");
                } 
            }

        }
    }

    RRM_UT_TRACE_EXIT();

    return break_loop;

}



/******************************************************************************
  *   FUNCTION NAME: rrm_populate_mu_mimo_info_enable_disable
  *   DESCRIPTION:
  *       Fill the mu mimo status in mac ue reconfig req
  *   RETURNS:
  *       rrm_return_et
 ******************************************************************************/
rrm_return_et
rrm_populate_mu_mimo_info_enable_disable( RrmMacUeReconfigReq    *p_mac_ue_reconfig_req,
                                          rrm_cell_region_et            cell_region_enable,
                                          rrm_cell_region_et            cell_region_disable,
                                          rrm_bool_et                   both_cell,
                                          rrm_bool_et                   enable,
                                          rrm_bool_et                   disable,
                                          U16                           index,
                                          rrm_ue_context_t             *p_ue_context )
{

    rrm_return_et        ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    
    if( RRM_PNULL != p_ue_context )
    {
        if( both_cell &&  enable )
        {
            p_ue_context->mu_mimo_bitmask = RRM_MU_MIMO_ENABLE_CNF;

            p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.ueUlMUMIMOInfo[index].
            ulMUMIMOStatus = UL_MU_MIMO_ENABLED;
                      
         }
         else if( both_cell && disable )
         {
             p_ue_context->mu_mimo_bitmask = RRM_MU_MIMO_DISABLE_CNF;

             p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.ueUlMUMIMOInfo[index].
             ulMUMIMOStatus = UL_MU_MIMO_DISABLED;
         }
         else if( RRM_CELL_CENTER_UE == cell_region_enable )
         {
             p_ue_context->mu_mimo_bitmask = RRM_MU_MIMO_ENABLE_CNF;

             p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.ueUlMUMIMOInfo[index].
             ulMUMIMOStatus = UL_MU_MIMO_ENABLED;
         }
         else if( RRM_CELL_CENTER_UE == cell_region_disable )
         {
             p_ue_context->mu_mimo_bitmask = RRM_MU_MIMO_DISABLE_CNF;

             p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.ueUlMUMIMOInfo[index].
             ulMUMIMOStatus = UL_MU_MIMO_DISABLED;
         }

         p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.ueUlMUMIMOInfo[index].
         ueIndex = p_ue_context->ue_index;

        /* SPR 18891 fix start */
	 RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
         "[UE:%d]\n,UE's mu mimo bitmask : %d\n,UE MUMIMO STATUS : %d\n",
         p_ue_context->ue_index,p_ue_context->mu_mimo_bitmask,
         p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.ueUlMUMIMOInfo[index].ulMUMIMOStatus);
         /* SPR 18891 fix stop */
    }
    else
    {
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
        "NULL POINTER Exception for p_ue_context ");
   
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_best_fill_ue_list_in_mac_config_req
 *   DESCRIPTION:
 *       Find the best fill ue list for uplink mu mimo
 *   RETURNS:
 *       void
 ******************************************************************************/
rrm_return_et
rrm_best_fill_ue_list_in_mac_config_req(RrmMacUeReconfigReq    *p_mac_ue_reconfig_req,
                          rrm_cell_region_et            cell_region_enable,
                          rrm_cell_region_et            cell_region_disable,
                          rrm_bool_et                   both_cell,
                          rrm_bool_et                   enable,
                          rrm_bool_et                   disable,
                          U32                         **p_cell_region[RRM_MAX_CELL_REGION_ALLOWED],
			  U16                           region_count[RRM_MAX_CELL_REGION_ALLOWED])
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    U16                         modified_count_1 = RRM_ZERO;
    U16                         modified_count_2 = RRM_ZERO;
    U16                         num = RRM_ZERO;
    U16                         i = RRM_ZERO;
    U16                         index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if( RRM_PNULL == p_cell_region[RRM_CELL_CENTER_UE] ||
	RRM_PNULL == p_cell_region[RRM_CELL_EDGE_UE] )
    {
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
        "NULL POINTER Exception for p_cell_region[] ");

        ret_val = RRM_FAILURE;
    }
    else
    {
        if( (region_count[RRM_CELL_CENTER_UE] + region_count[RRM_CELL_EDGE_UE]) <= MAX_NUM_OF_UE) 
	{
	    modified_count_1 = region_count[RRM_CELL_CENTER_UE];
	    modified_count_2 = region_count[RRM_CELL_EDGE_UE];
	}
	else
	{
	    num = MAX_NUM_OF_UE;
	    if(region_count[RRM_CELL_CENTER_UE] < num/RRM_TWO )
	    {
	        modified_count_1 = region_count[RRM_CELL_CENTER_UE];
		modified_count_2 = num - modified_count_1;
            }
	    else if(region_count[RRM_CELL_EDGE_UE] <= num/RRM_TWO)
	    {
	        modified_count_2 = region_count[RRM_CELL_EDGE_UE]; 
	        modified_count_1 = num - modified_count_2;
	    }
	    else
	    {
	        modified_count_1 = num/RRM_TWO;
	        modified_count_2 = num - modified_count_1;
	    }
	}
	
	for(i = RRM_ZERO ; i< modified_count_1 && i < MAX_NUM_OF_UE ; i++)
	{
            p_ue_context = (rrm_ue_context_t *)p_cell_region[RRM_CELL_CENTER_UE][i];
            if( RRM_PNULL != p_ue_context )
            {
                ret_val = rrm_populate_mu_mimo_info_enable_disable( p_mac_ue_reconfig_req,
                                                          cell_region_enable,
                                                          cell_region_disable,
                                                          both_cell,
                                                          enable,
                                                          disable,
                                                          index,
                                                          p_ue_context );
                 
	        if( ret_val ) index++;

                p_cell_region[RRM_CELL_CENTER_UE][i] = RRM_PNULL;
                p_ue_context = RRM_PNULL;
            }
	}

	for( i = RRM_ZERO ; i< modified_count_2 && i < MAX_NUM_OF_UE ; i++)
	{
            p_ue_context = (rrm_ue_context_t *)p_cell_region[RRM_CELL_EDGE_UE][i];
            if( RRM_PNULL != p_ue_context )
            {
                ret_val = rrm_populate_mu_mimo_info_enable_disable( p_mac_ue_reconfig_req,
                                                          cell_region_enable,
                                                          cell_region_disable,
                                                          both_cell,
                                                          enable,
                                                          disable,
                                                          index,
                                                          p_ue_context );
                 
	        if( ret_val ) index++;

                p_cell_region[RRM_CELL_EDGE_UE][i] = RRM_PNULL;
                p_ue_context = RRM_PNULL;
            }
	}

        p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.numOfUE = index;
        p_mac_ue_reconfig_req->bitmask |= UE_ULMUMIMO_RECONFIG_BIT ;
  
        /* SPR 18891 fix start */
	RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
	"Count for CELL CENTER UE : %d\n, Count for CELL EDGE UE : %d\n, \
	total_ue_count :%d\n",modified_count_1,modified_count_2,index);
	/* SPR 18891 fix stop */
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;

}




/******************************************************************************
 *   FUNCTION NAME: rrm_find_UE_eligible_for_ul_mumimo
 *   DESCRIPTION:
 *       Find th Ue are eligible for uplink mu mimo
 *   RETURNS:
 *       void
 ******************************************************************************/
rrm_return_et
rrm_find_UE_eligible_for_ul_mumimo( RrmMacUeReconfigReq  *p_mac_ue_reconfig_req,
                                    rrm_cell_index_t           cell_index,
                                    rrm_cell_region_et         cell_region_enable,
                                    rrm_cell_region_et         cell_region_disable,
                                    rrm_bool_et                both_cell,
                                    rrm_bool_et                enable,
                                    rrm_bool_et                disable,
                                    rrm_bool_et                only_single_region)
                                                
{

/* this function is called when uplink prb usage threshold is reached*/

    rrm_return_et        ret_val = RRM_SUCCESS;
    rrm_ue_context_t    *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_seq_data_info_t  ue_node;
    /* SPR 20652 Fix End */
    U8                   uplink_sinr_threshold = RRM_ZERO;
    U32                  uplink_pathloss_threshold = RRM_ZERO;

    U32                **p_cell_region[RRM_MAX_CELL_REGION_ALLOWED] = { RRM_PNULL };
    U16                  cell_region_ue_count[RRM_TWO] = {RRM_ZERO};
    rrm_bool_et          break_loop = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    p_cell_region[RRM_CELL_CENTER_UE] = (U32**)rrm_mem_get( MAX_NUM_OF_UE * sizeof(U32*) );
    
    p_cell_region[RRM_CELL_EDGE_UE] = (U32**)rrm_mem_get( MAX_NUM_OF_UE * sizeof(U32*) );

    if( RRM_PNULL == p_cell_region[RRM_CELL_CENTER_UE] ||
        RRM_PNULL == p_cell_region[RRM_CELL_EDGE_UE] )
    {

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
        "NULL POINTER Exception, memory could not be allocated for p_cell_region[] ");
        /* BUG_11576_FIX_START */
        if( RRM_PNULL != p_cell_region[RRM_CELL_CENTER_UE] )
        {
            RRM_MEM_FREE( p_cell_region[RRM_CELL_CENTER_UE] );
            p_cell_region[RRM_CELL_CENTER_UE] = RRM_PNULL;
        }
        if( RRM_PNULL != p_cell_region[RRM_CELL_EDGE_UE] )
        {
            RRM_MEM_FREE( p_cell_region[RRM_CELL_EDGE_UE] );
            p_cell_region[RRM_CELL_EDGE_UE] = RRM_PNULL;
        } 
        /* BUG_11576_FIX_END */

        ret_val = RRM_FAILURE;
    }
    else
    {

        /* uplink sinr threshold value form rrm.cfg */ 
        uplink_sinr_threshold = rrm_get_uplink_sinr_threshold(cell_index);
        uplink_pathloss_threshold = rrm_get_uplink_pathloss_threshold_for_ue(cell_index);

        /* SPR 18891 fix start */
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
        "uplink_sinr_threshold : %d\n, uplink_pathloss_threshold : %d\n",
        uplink_sinr_threshold,uplink_pathloss_threshold);
	/* SPR 18891 fix stop */
        /* SPR 20652 Fix Start */
        rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
        while( RRM_PNULL != p_ue_context )
        {
            if( cell_index == p_ue_context->cell_index )
            {
                if( !(p_ue_context->ue_sps_data.is_sps_erab_established) )
                {
                    if(!(p_ue_context->mu_mimo_bitmask & RRM_MU_MIMO_ENABLE_CNF))
                    {
                        
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "[UE:%d] is currently not enabled in uplink mu mimo",p_ue_context->ue_index);

                        if( RRM_TRUE == enable )
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            "Enable in uplink mu mimo condition on the basis of PRB is TRUE, \
                            Now we are going to check its uplink sinr");

                            if( uplink_sinr_threshold <= p_ue_context->ue_avg_stats.uplinkSINRValue )
                            {
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "Average Uplink sinr [%d] is greator than or equal UPLINK SINR THRESHOLD [%d] \
                                for [UE:%d] ",p_ue_context->ue_avg_stats.uplinkSINRValue,
                                uplink_sinr_threshold,p_ue_context->ue_index);

                                 break_loop = rrm_find_eligible_ue_for_ul_mu_mimo( uplink_pathloss_threshold,
                                                                 p_cell_region,
                                                                 cell_region_ue_count,
                                                                 cell_region_enable,
                                                                 both_cell,
                                                                 p_ue_context,
                                                                 only_single_region );
                                if( break_loop )break;
                            
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "Average Uplink sinr [%d] is less than UPLINK SINR THRESHOLD [%d] for [UE:%d] ",
                                p_ue_context->ue_avg_stats.uplinkSINRValue,uplink_sinr_threshold,p_ue_context->ue_index);
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            "Enable in uplink mu mimo condition on the basis of PRB is FALSE");
                        }
                    }
                    else
                    {
                        if( RRM_TRUE == disable )
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            "Disable in uplink mu mimo condition on the basis of PRB is TRUE");

                            break_loop = rrm_find_eligible_ue_for_ul_mu_mimo( uplink_pathloss_threshold,
                                                              p_cell_region,
                                                              cell_region_ue_count,
                                                              cell_region_disable,
                                                              both_cell,
                                                              p_ue_context,
                                                              only_single_region );
                            if( break_loop )break;
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            "Disable from uplink mu mimo condition on the basis of PRB is FALSE");
                        }
                    }
                }
                else
                {
                    RRM_TRACE( g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "[UE:%d] is sps enabled. so we can not perform mu mimo for this UE",
                    p_ue_context->ue_index );
                }
            }

             /* move to pointer to its next element */
            ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
            /* SPR 20652 Fix End */
        }


        if( cell_region_ue_count[RRM_CELL_CENTER_UE] ||
            cell_region_ue_count[RRM_CELL_EDGE_UE] )
        {
            ret_val = rrm_best_fill_ue_list_in_mac_config_req( p_mac_ue_reconfig_req,
                                                           cell_region_enable,
                                                           cell_region_disable,
                                                           both_cell,
                                                           enable,
                                                           disable,
                                                           p_cell_region,
                                                           cell_region_ue_count );
        }
        else
        {
            RRM_TRACE( g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
            "No Ue is selected for enabling or disabling in uplink mu mimo");

            ret_val = RRM_FAILURE;
        }

        if( RRM_PNULL != p_cell_region[RRM_CELL_CENTER_UE] )
        {
            RRM_MEM_FREE( p_cell_region[RRM_CELL_CENTER_UE] );
             p_cell_region[RRM_CELL_CENTER_UE] = RRM_PNULL;
        }
        if( RRM_PNULL != p_cell_region[RRM_CELL_EDGE_UE] )
        {
            RRM_MEM_FREE( p_cell_region[RRM_CELL_EDGE_UE] );
             p_cell_region[RRM_CELL_EDGE_UE] = RRM_PNULL;
        } 

    }

    RRM_UT_TRACE_EXIT();

    return ret_val;

}



/******************************************************************************
  *   FUNCTION NAME: rrm_fill_ue_in_mac_reconfig_req_for_disabling_only
  *   DESCRIPTION:
  *       Function build and send the mac ue reconfig req to mac
  *   RETURNS:
  *       rrm_void_t
 ******************************************************************************/
rrm_void_t
rrm_send_ue_mac_reconfig_req_for_disabling( rrm_ue_context_t           *p_mimo_ue_list[MAX_NUM_OF_UE],
                                            rrm_cell_index_t            cell_index )
{
    /* Coverity Fix 99676 Start */
    U16                          index = RRM_ZERO;
    /* Coverity Fix 99676 End */
    rrm_ue_context_t            *p_ue_context = RRM_PNULL;
    /* Coverity Fix 99676 Start */
    U16                          count = RRM_ZERO;
    /* Coverity Fix 99676 Start */
    U8                          port = RRM_ZERO;
    /* Coverity Fix 99713 Start */
    RrmMacUeReconfigReq   *p_mac_ue_reconfig_req = RRM_PNULL;
    /* Coverity Fix 99713 End */
    RRM_UT_TRACE_ENTER();
    /* Coverity Fix 99713 Start */
    p_mac_ue_reconfig_req = (RrmMacUeReconfigReq *)
                        rrm_mem_get(sizeof(RrmMacUeReconfigReq));
    if( RRM_PNULL ==  p_mac_ue_reconfig_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return;
    }
    RRM_MEMSET(p_mac_ue_reconfig_req,RRM_ZERO,sizeof(RrmMacUeReconfigReq));
    /* Coverity Fix 99713 End */
    if (RRM_FAILURE == rrm_cellm_get_antenna_port( cell_index,&port ))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_ERROR,
            "rrm_cellm_get_antenna_port returned FAILURE because given antenna port not available");
    }

    if( ( ANTENNA_PORTS_COUNT_AN2 == port) || ( ANTENNA_PORTS_COUNT_AN4 == port ) ) 
    {
        /*SPR 7892 FIX START*/
        if( MAC_UE_RECONF_NOT_ONGOING  == (rrm_get_mac_ue_reconfig_mutex( cell_index )) )
        /*SPR 7892 FIX END*/
        {
            for( index = RRM_ZERO; index < MAX_NUM_OF_UE ; index++)
            {
                p_ue_context = p_mimo_ue_list[index];

                if( RRM_PNULL != p_ue_context)
                {
                    p_ue_context->mu_mimo_bitmask = RRM_MU_MIMO_DISABLE_CNF;
                    /* Coverity Fix 99713 Start */
                    p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.ueUlMUMIMOInfo[index].
                    ulMUMIMOStatus = UL_MU_MIMO_DISABLED;

                    p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.ueUlMUMIMOInfo[index].
                    ueIndex = p_ue_context->ue_index;
                    /* Coverity Fix 99713 End */
                    count++;

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_BRIEF,
                    "[UE:%d] is filled with Mu mimo Status [%d] in mac ue reconfig req",
                    p_ue_context->ue_index,UL_MU_MIMO_DISABLED );
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_ERROR,
                    "NULL Pointer for Ue context at [%d] index of filtered mu mimo list",
                    index);
                } 

            }
            /* Coverity Fix 99713 Start */
            p_mac_ue_reconfig_req->ueUlMUMIMOInfoList.numOfUE = count;
            p_mac_ue_reconfig_req->bitmask |= UE_ULMUMIMO_RECONFIG_BIT ;
            /* Coverity Fix 99713 End */
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_ERROR,
            "Ue count is  [%d] for mac ue reconfig request",count);

            
            /* Coverity Fix 99713 Start */
            if( rrm_send_mac_ue_reconfig_req( p_mac_ue_reconfig_req,
                                               RRM_MODULE_ID,
                                               RRM_ZERO,
                                               cell_index ))
            /* Coverity Fix 99713 End */
            {
                /*SPR 7892 FIX START*/
                rrm_set_mac_ue_reconfig_mutex(cell_index,W_FOR_MAC_UE_RECONF_CNF_FOR_UL_MIMO);
                /*SPR 7892 FIX END*/

                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_ERROR,
                "Successfully sent RRM_MAC_UE_RECONFIG_REQ to  L2");
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_ERROR,
                "Failed to Send to RRM_MAC_UE_RECONFIG_REQ to  L2");
            } 
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_BRIEF,
            "MAC UE reconfig request is already sent for this cell index[%d]",cell_index);
        }
    }
    /* Coverity Fix 99713 Start */
    RRM_MEM_FREE(p_mac_ue_reconfig_req);
     /* Coverity Fix 99713 End */
    RRM_UT_TRACE_EXIT(); 
}



/******************************************************************************
  *   FUNCTION NAME: rrm_build_and_send_mac_ue_reconfig_req
  *   DESCRIPTION:
  *       Function build and send the mac ue reconfig req to mac
  *   RETURNS:
  *       rrm_void_t
 ******************************************************************************/
rrm_void_t
rrm_build_and_send_mac_ue_reconfig_req( 
                       rrmuem_cm_prb_threshold_reached_ind_t   *prb_msg_api
                                      )
{

    rrm_return_et               ret_val = RRM_SUCCESS;
    /* Coverity Fix 99681 Start */
    RrmMacUeReconfigReq   *p_mac_ue_reconfig_req = RRM_PNULL;
    /* Coverity Fix 99681 End */
    U8                          port = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    /* Coverity Fix 99681 Start */
    p_mac_ue_reconfig_req = (RrmMacUeReconfigReq *)
                        rrm_mem_get(sizeof(RrmMacUeReconfigReq));
    if( RRM_PNULL ==  p_mac_ue_reconfig_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return;
    }
    RRM_MEMSET(p_mac_ue_reconfig_req,RRM_ZERO,sizeof(RrmMacUeReconfigReq));
    /* Coverity Fix 99681 End */
    ret_val = rrm_cellm_get_antenna_port(prb_msg_api->cell_index,&port);

    if (RRM_SUCCESS == ret_val)
    {
    if( ( ANTENNA_PORTS_COUNT_AN2 == port ) ||  ( ANTENNA_PORTS_COUNT_AN4 == port ) ) 
    {
        /*SPR 7892 FIX START*/
        if(MAC_UE_RECONF_NOT_ONGOING  == (rrm_get_mac_ue_reconfig_mutex( prb_msg_api->cell_index )) )
        /*SPR 7892 FIX END*/
        {
            /* Coverity Fix 99681 Start */
            ret_val = rrm_find_UE_eligible_for_ul_mumimo( p_mac_ue_reconfig_req,
                                                 prb_msg_api->cell_index,
                                                 prb_msg_api->cell_region_enable,
                                                 prb_msg_api->cell_region_disable,
                                                 prb_msg_api->both_cell,
                                                 prb_msg_api->enable,
                                                 prb_msg_api->disable,
                                                 prb_msg_api->only_single_region);
    
            /* Coverity Fix 99681 End */
            if( ret_val )
            { 
                /* Coverity Fix 99681 Start */  
                ret_val = rrm_send_mac_ue_reconfig_req( p_mac_ue_reconfig_req,
                                                        RRM_MODULE_ID,
                                                        RRM_ZERO,
                                                        prb_msg_api->cell_index );
                /* Coverity Fix 99681 End */
                if( RRM_FAILURE == ret_val )
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_ERROR,
                    "Failed to Send to RRM_MAC_UE_RECONFIG_REQ to  L2");
                }
                else
                {
                    /*SPR 7892 FIX START*/
                    rrm_set_mac_ue_reconfig_mutex(prb_msg_api->cell_index,W_FOR_MAC_UE_RECONF_CNF_FOR_UL_MIMO);
                    /*SPR 7892 FIX END*/

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_ERROR,
                    "Successfully Sent RRM_MAC_UE_RECONFIG_REQ to  L2");
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_BRIEF,
            "MAC UE reconfig request is already sent for this cell index[%d]",prb_msg_api->cell_index);
        }        

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_WARNING,
        "Number of antenna port is not TWO/FOUR.Failed to Send to RRM_MAC_UE_RECONFIG_REQ to  L2");
    }
    }
    /* Coverity Fix 99681 Start */
    RRM_MEM_FREE(p_mac_ue_reconfig_req);
    /* Coverity Fix 99681 End */
    RRM_UT_TRACE_EXIT();
}



/******************************************************************************
  *   FUNCTION NAME: rrm_uem_handle_prb_threshold_indication
  *   DESCRIPTION:
  *       Function handle the prb threshold indication
  *   RETURNS:
  *       rrm_return_et
 ******************************************************************************/
rrm_return_et
rrm_uem_handle_prb_threshold_indication(
                                /*SPR 17777 +-*/
                                rrm_void_t                  *p_api, /*Input Api buffer*/
                                /*SPR 17777 +-*/
                                U16                         data_len/* Incoming data length*/)
{

    rrmuem_cm_prb_threshold_reached_ind_t   prb_msg_ind = { RRM_ZERO };
    rrmuem_cm_prb_threshold_reached_ind_t   *temp_api = (rrmuem_cm_prb_threshold_reached_ind_t *)p_api;
    RRM_UT_TRACE_ENTER();
    
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_PRB_THRESHOLD_REACHED_IND");
    
    if( data_len < sizeof( rrmuem_cm_prb_threshold_reached_ind_t ) )
    {
        /* invalid message ignore*/
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
        "Failed to send the prb threshold indication to UE Mgr");
    }
    else /* process the message */
    {
        SET_CELL_INDEX(temp_api->cell_index);
        prb_msg_ind.cell_index = temp_api->cell_index;
        prb_msg_ind.cell_region_enable = temp_api->cell_region_enable;
        prb_msg_ind.cell_region_disable = temp_api->cell_region_disable;
        prb_msg_ind.both_cell = temp_api->both_cell;
        prb_msg_ind.enable = temp_api->enable;
        prb_msg_ind.disable = temp_api->disable;
        prb_msg_ind.only_single_region = temp_api->only_single_region;
        
        /* build the message and send the mac ue reconfig req*/ 
        rrm_build_and_send_mac_ue_reconfig_req(&prb_msg_ind); 
    }
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/* SPR 17784 Start */
/****************************************************************************
 * Function Name  : rrm_search_and_mark_cgi_meas_node_for_earfcn 
 * Inputs         : earfcn , p_ue_context - Pointer to the UE context for which meas
 *                  results are being populated
 * Outputs        : None
 * Returns        : RRM_SUCCESS when EARFCN is found in the list
 *                : RRM_FAILURE when EARFCN is not found in the list
 * Description    : Search the EARFCN in the measurement list and mark that CGI
 *                  is no more required from the UE 
 ****************************************************************************/
rrm_return_et 
rrm_search_and_mark_cgi_meas_node_for_earfcn(U16                        earfcn,
                                  rrm_ue_context_t*         p_ue_context)
{
  meas_report_info_node_t   *p_meas_report_info = RRM_PNULL;

  RRM_UT_TRACE_ENTER();
  p_meas_report_info = (meas_report_info_node_t*)ylFirst(&(p_ue_context->meas_report_list));

  while (p_meas_report_info) 
  {
    if ((p_meas_report_info->carrier_earfcn == earfcn) &&
        (p_meas_report_info->reporting_event == MEAS_REP_EVENT_FOR_CGI) &&
        (p_meas_report_info->is_meas_report_pending == RRM_TRUE))
    {
      RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
          "EARFCN %d found in the list.",earfcn);
      p_meas_report_info->is_meas_report_pending = RRM_FALSE;
      RRM_UT_TRACE_EXIT();
      return RRM_SUCCESS;
    }
    p_meas_report_info = (meas_report_info_node_t*)ylNext(&p_meas_report_info->sNode);
  }

  RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
      "EARFCN %d is not found in the list.",earfcn);
  RRM_UT_TRACE_EXIT();
  return RRM_FAILURE;
}
/****************************************************************************
 * Function Name  : rrm_ue_handle_ho_ongoing_ue_cgi_timer_expiry 
 * Inputs         : p_rrm_glb_ctxt 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE 
 * Description    : Handler for cgi timer expiry when HO is ongoing 
 *                  
 ****************************************************************************/

rrm_return_et 
rrm_ue_handle_ho_ongoing_ue_cgi_timer_expiry(
    rrm_ue_global_context_t *p_rrm_glb_ctxt)
{

  rrm_ue_timer_buf_t *p_timer_buf  = RRM_PNULL;
  rrm_return_et       ret_val        = RRM_SUCCESS;
  rrm_ue_context_t*   p_ue_context   = RRM_PNULL;

  p_ue_context = (rrm_ue_context_t*)p_rrm_glb_ctxt->p_ue_context;

  RRM_UT_TRACE_ENTER();

  if (p_ue_context->ho_params.cgi_timer) 
  {
    /* 
     ** Report CGI timer expired, Ho is ongoing 
     ** Only remove the PCI from the lists 
     */

    p_timer_buf = (rrm_ue_timer_buf_t *) qvTimerData(p_ue_context->ho_params.cgi_timer);
    
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
        "CGI Timer expired for PCI: %d & EARFCN: %d ", p_timer_buf->phy_cell_id, p_timer_buf->earfcn);

    rrm_remove_previous_cell_for_ho(p_ue_context,
        p_timer_buf->phy_cell_id,
        p_timer_buf->earfcn);

    rrm_search_and_remove_phy(p_ue_context,
        p_timer_buf->phy_cell_id,
        p_timer_buf->earfcn);

    rrm_search_and_mark_cgi_meas_node_for_earfcn(p_timer_buf->earfcn,p_ue_context);

  }
  else
  {
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
        "CGI Timer is NULL %d ", p_ue_context->ho_params.cgi_timer);
  }
  p_ue_context->ho_params.cgi_timer = RRM_PNULL;

  RRM_UT_TRACE_EXIT();
  return ret_val;
}
/* SPR 17784 End */

/******************************************************************************
  *   FUNCTION NAME: rrm_update_or_rollback_bitmask_on_mac_ue_reconfig_cnf
  *   DESCRIPTION:
  *       Function perform an action on success and failue case
  *   RETURNS:
  *       rrm_void_t
 ******************************************************************************/
rrm_return_et
rrm_update_or_rollback_bitmask_on_mac_ue_reconfig_cnf( rrm_cell_index_t   cell_index,
                                                       RrmMacUEReConfigCnf
                                                                          *p_mac_ue_reconf_cnf )
{

    rrm_ue_context_t    *p_ue_context = RRM_PNULL;
    /* Coverity Fix 99673 Start */
    U16                   index = RRM_ZERO;
    /* Coverity Fix 99673 End */
    /* +- SPR 18268 */
    U16                   ue_count = RRM_ZERO;
    /* +- SPR 18268 */
    rrm_ue_index_t       ue_index = RRM_ZERO ;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */

    RRM_UT_TRACE_ENTER();


    /* Bug_869_Changes_Start */
    if (p_mac_ue_reconf_cnf->responseCode != RRM_SUCCESS)
    {
        if( p_mac_ue_reconf_cnf->bitmask & UE_MUMIMO_RECONFIG_ERROR_INFO_BITMASK)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Mac ue reconfig cnf is handled with Failure/Partial Success response");

            ue_count = p_mac_ue_reconf_cnf->ueULMUMIMOErrorInfo.numOfUE;

            /* SPR 18891 fix start */
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "UE count for uplink mu mimo Error info : %d\n", ue_count);
            /* SPR 18891 fix stop */

            for( index = RRM_ZERO; (index < ue_count) && (index < MAX_NUM_OF_UE); index++ )
            {
                ue_index = p_mac_ue_reconf_cnf->ueULMUMIMOErrorInfo.ueULMUMIMOError[index].ueIndex;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "Processing [UE:%d]", ue_index);
                /* SPR 20652 Fix Start */
                p_ue_context = rrm_ue_find_context( ue_index , cell_index );
                /* SPR 20652 Fix End */
                if( RRM_PNULL != p_ue_context)
                {
                    if( p_ue_context->mu_mimo_bitmask & RRM_MU_MIMO_ENABLE_CNF )
                    {
                        p_ue_context->mu_mimo_bitmask = RRM_ZERO;

                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "[UE:%d] is rolled back its mu_mimo_bitmask state to NONE",ue_index);
                    }
                    else if( p_ue_context->mu_mimo_bitmask & RRM_MU_MIMO_DISABLE_CNF )
                    {
                        p_ue_context->mu_mimo_bitmask = RRM_MU_MIMO_ENABLE_CNF;

                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "[UE:%d] is rolled back its state to RRM_MU_MIMO_ENABLE_CNF",ue_index);
                    }
                    p_ue_context = RRM_PNULL;
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "UE not found for this [UE:%d] and cell index [%d]",ue_index,cell_index);
                }
            }
        }
    }
    else
    {
       RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Complete Success[%d] so No need to Roll Back",
                p_mac_ue_reconf_cnf->responseCode);
    }
    /* Bug_869_Changes_End */
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}




rrmh_fsm_ptr rrmh_fsm[RRM_UE_MAX_STATE][RRM_UE_MAX_EVENT] = 
{
    /** RRM_UE_STATE_IDLE */
    {
        rrm_ue_handle_log_and_ignore_event,      /** RRC_RRM_UE_ADMISSION_REQ */
        rrm_ue_handle_ue_admission_cnf,			/** RRC_RRM_UE_ADMISSION_CNF */
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_CAPABILITY_IND*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_CAPABILITY_
                                                  ENQUERY_RESP 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_SETUP_REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_SETUP_CNF 	 */
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_MEASURMENT_RESULTS
                                                  _IND*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_MODIFY_REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_RELEASE_
                                                  REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_MODIFY_CNF 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_RELEASE_CNF */
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_RELEASE_REQ 	*/
        rrm_ue_handle_ue_ho_adm_req,			/** RRC_RRM_UE_HO_ADM_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,			/** RRC_RRM_UE_HO_ADM_CNF 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_HO_CMD_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_HO_FAILURE 		*/
        rrm_ue_handle_log_and_ignore_event, 	/** RRC_RRM_HO_CANCEL_RESP 	*/
        rrm_ue_handle_log_and_ignore_event, 		/** RRC_RRM_UE_CONTEXT_MOD_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event, 		/** RRC_RRM_UE_CONTEXT_MOD_CNF_EVENT */
        rrm_ue_handle_log_and_ignore_event,          /** RRC_RRM_MEAS_CONFIG_RESP_EVENT */
        /*MC, MR & HO  START */
        rrm_ue_handle_ho_restriction_ind,          /** RRC_RRM_HO_RESTRICTION_LIST_IND_EVENT */
        rrm_ue_handle_log_and_ignore_event,              /**RRC_RRM_UE_TIMER_EXPIRY_EVENT */
        /*MC, MR & HO  END */
        /*LTE_RRM_TM_SWITCH_START*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_UE_RECONFIG_RESP_EVENT*/
        rrm_ue_handle_log_and_ignore_event,		/**RRM_MAC_PERIODIC_REPORTS_IND*/
        /*LTE_RRM_TM_SWITCH_END*/
        /*PROXIMITY IND START*/
        rrm_ue_handle_log_and_ignore_event,      /**RRC_RRM_PROXIMITY_IND_EVENT*/
        /*PROXIMITY IND END*/
        /* MRO code changes start */
        /*RRC_RRM RLF IND START*/
        rrm_ue_handle_log_and_ignore_event,     /**X2AP_RLF_IND*/
        /*RRC_RRM RLF IND end*/
        /* MRO code changes end */
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_UE_CDMA2000_MOB_INFO_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_DL_NAS_TRANSPORT_IND_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_INTRA_ENB_HO_IND_EVENT*/
        /*ue pos start*/
        rrm_ue_handle_log_and_ignore_event,      /*S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      /*S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      /*S1AP_RRM_LPPA_ERROR_IND_EVENT*/
        /*ue pos end*/
        rrm_ue_handle_log_and_ignore_event,       /*RRC_RRM_INTER_FREQ_MEASUREMENT_IND*/
        rrm_ue_handle_log_and_ignore_event,       /* RRC_RRM_LOCAL_ERROR_IND */
        /*SPR-695 Fix Starts*/
        rrm_ue_handle_log_and_ignore_event,       /* RRC_RRM_HO_REQUIRED */
        /* SPR 12512 Fix Start */
        rrm_ue_handle_log_and_ignore_event,      /** RRM_RELEASE_LOW_PRIORITY_UE_REL_EVENT   */
        /*SPR-695 Fix Ends*/
        /* SPR_16053_Fix: Start */
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_UE_SYNC_STATUS_IND_EVENT*/
        /* SPR 12512 Fix End */
        /* SPR 9216:MRO enhancement start */
        rrm_ue_handle_log_and_ignore_event,      /* RRC_RRM_UE_REESTAB_CONFIG_CNF_EVENT */
        /* SPR_16053_Fix: End */
        /* SPR 9216:MRO enhancement end */
        /*SPR 11535:start*/
        /* SPR_16053_Fix: End */
        /* SPR 17784 Start */
         rrm_ue_handle_log_and_ignore_event,      /*RRM_UE_CGI_TIMER_EXPIRY_EVENT*/
      /* SPR 17784 End */

        rrm_ue_handle_log_and_ignore_event      /* RRC_RRM_UE_INACTIVE_EVENT */
            /*SPR 11535:end*/
/* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
        ,rrm_ue_handle_log_and_ignore_event      /* RRC_RRM_UE_DC_BEARER_CHANGE_CNF_EVENT */
#endif
/* OPTION3X Changes End */
    },
    /** RRM_UE_WAIT_FOR_CAP_IND */
    {
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_ADMISSION_REQ*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_ADMISSION_CNF*/
        rrm_ue_handle_ue_capability_ind,		/** RRC_RRM_UE_CAPABILITY_IND*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_CAPABILITY_
                                                  ENQUERY_RESP 	*/
        rrm_ue_wait_for_cap_ind_handle_erb_setup_req,    /** RRC_RRM_ERB_SETUP_
                                                           REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_SETUP_CNF*/
        rrm_ue_handle_log_and_ignore_event,			/** RRC_RRM_MEASURMENT_RESULTS
                                                      _IND*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_MODIFY_REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_RELEASE_
                                                  REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_MODIFY_CNF 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_RELEASE_CNF */
        //rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_RELEASE_REQ 	*/
        rrm_ue_wait_for_cap_ind_handle_ue_release_req,		/** RRC_RRM_UE_RELEASE_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_HO_ADM_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_HO_ADM_CNF 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_HO_CMD_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_HO_FAILURE 		*/
        rrm_ue_handle_log_and_ignore_event, 	/** RRC_RRM_HO_CANCEL_RESP 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_CONTEXT_MOD_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event, 		/** RRC_RRM_UE_CONTEXT_MOD_CNF_EVENT */
        rrm_ue_handle_log_and_ignore_event,          /** RRC_RRM_MEAS_CONFIG_RESP_EVENT */
        /*MC, MR & HO  START */
        rrm_ue_handle_ho_restriction_ind,          /** RRC_RRM_HO_RESTRICTION_LIST_IND_EVENT */
        rrm_ue_handle_log_and_ignore_event,              /**RRC_RRM_UE_TIMER_EXPIRY_EVENT */
        /*MC, MR & HO  END */
        /*LTE_RRM_TM_SWITCH_START*/
        rrm_ue_handle_log_and_ignore_event,              /*RRC_RRM_UE_RECONFIG_RESP_EVENT*/
        rrm_ue_handle_log_and_ignore_event,              /*RRM_MAC_PERIODIC_REPORTS_IND*/ 
        /*LTE_RRM_TM_SWITCH_END*/
        /*PROXIMITY IND START*/
        rrm_ue_handle_log_and_ignore_event,      /**RRC_RRM_PROXIMITY_IND_EVENT*/
        /*PROXIMITY IND END*/
        /* MRO code changes start */
        /*RRC_RRM RLF IND START*/
        rrm_ue_handle_log_and_ignore_event,      /**X2AP_RLF_IND*/
        /*RRC_RRM RLF IND end*/
        /* MRO code changes end */
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_UE_CDMA2000_MOB_INFO_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_DL_NAS_TRANSPORT_IND_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_INTRA_ENB_HO_IND_EVENT*/
        /*ue pos start*/
        rrm_ue_handle_log_and_ignore_event,      /*S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      /*S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND_EVENT*/
        rrm_ue_handle_log_and_ignore_event,       /*S1AP_RRM_LPPA_ERROR_IND_EVENT*/
        /*ue pos end*/
        rrm_ue_handle_log_and_ignore_event,       /*RRC_RRM_INTER_FREQ_MEASUREMENT_IND*/
        rrm_ue_handle_log_and_ignore_event,      /* RRC_RRM_LOCAL_ERROR_IND */
        /*SPR-695 Fix Starts*/
        rrm_ue_handle_log_and_ignore_event,       /* RRC_RRM_HO_REQUIRED */
        /* SPR 12512 Fix Start */
        rrm_ue_handle_low_priority_ue_rel_event,     /** RRM_RELEASE_LOW_PRIORITY_UE_REL_EVENT   */
        /*SPR-695 Fix Ends*/
        /* SPR_16053_Fix: Start */
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_UE_SYNC_STATUS_IND_EVENT*/
        /* SPR 12512 Fix End */
        /*SPR 12658:start*/
       /* SPR 17784 Start */
        rrm_ue_handle_log_and_ignore_event,       /* RRC_RRM_UE_REESTAB_CONFIG_CNF_EVENT */ 
        rrm_ue_handle_log_and_ignore_event,       /* RRM_UE_CGI_TIMER_EXPIRY_EVENT */
        /*Code Removed */
       /* SPR 17784 End */
        /*SPR 12658:end*/
        /* SPR_16053_Fix: End */
        /*SPR 11535:start*/
        rrm_ue_handle_log_and_ignore_event      /* RRC_RRM_UE_INACTIVE_EVENT */
            /*SPR 11535:end*/
/* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
        ,rrm_ue_handle_log_and_ignore_event      /* RRC_RRM_UE_DC_BEARER_CHANGE_CNF_EVENT */
#endif
/* OPTION3X Changes End */
    },
    /** RRM_UE_STATE_ACTIVE */
    {
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_ADMISSION_REQ*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_ADMISSION_CNF*/
        rrm_ue_handle_ue_capability_ind,		/** RRC_RRM_UE_CAPABILITY_IND*/
        /*SPR_17893_START*/
        rrm_ue_handle_log_and_ignore_event,             /** RRC_RRM_UE_CAPABILITY_ENQUERY_RESP*/
        /*SPR_17893_END*/
        rrm_ue_handle_erb_setup_req,			/** RRC_RRM_ERB_SETUP_REQUEST*/
        rrm_ue_handle_erb_setup_cnf,			/** RRC_RRM_ERB_SETUP_CNF 	*/
        rrm_ue_handle_meas_results_ind,			/** RRC_RRM_MEASURMENT_RESULTS_
                                                  IND*/
        rrm_ue_handle_erb_modify_req,			/** RRC_RRM_ERB_MODIFY_REQUEST*/
        rrm_ue_handle_erb_release_req,			/** RRC_RRM_ERB_RELEASE_
                                                  REQUEST*/
        rrm_ue_handle_erb_modify_cnf,			/** RRC_RRM_ERB_MODIFY_CNF 	*/
        rrm_ue_handle_erb_release_cnf,			/** RRC_RRM_ERB_RELEASE_CNF */
        rrm_ue_handle_ue_release_req,			/** RRC_RRM_UE_RELEASE_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_HO_ADM_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_HO_ADM_CNF 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_HO_CMD_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_HO_FAILURE 		*/
        rrm_ue_handle_log_and_ignore_event,	   	/** RRC_RRM_HO_CANCEL_RESP 	*/
        rrm_ue_handle_context_mod_req,                   /** RRC_RRM_UE_CONTEXT_MOD_REQ_EVENT*/
        rrm_ue_handle_context_mod_cnf,         /** RRC_RRM_UE_CONTEXT_MOD_CNF_EVENT */
        rrm_ue_handle_meas_config_resp,          /** RRC_RRM_MEAS_CONFIG_RESP_EVENT */
        /*MC, MR & HO  START */
        rrm_ue_handle_ho_restriction_ind,          /** RRC_RRM_HO_RESTRICTION_LIST_IND_EVENT */
        rrm_ue_handle_ue_timer_expiry,              /**RRC_RRM_UE_TIMER_EXPIRY_EVENT */
        /*MC, MR & HO  END */
        /*LTE_RRM_TM_SWITCH_START*/
        rrm_ue_handle_reconfig_resp_event,              /*RRC_RRM_UE_RECONFIG_RESP_EVENT*/
        rrm_ue_handle_mac_periodic_report_event,		/*RRM_MAC_PERIODIC_REPORTS_IND*/
        /*LTE_RRM_TM_SWITCH_END*/
        /*PROXIMITY IND START*/
        rrm_ue_handle_proximity_ind_event,      /**RRC_RRM_PROXIMITY_IND_EVENT*/
        /*PROXIMITY IND END*/
        /* MRO code changes start */
        /*RRC_RRM RLF IND START*/
        rrm_ue_handle_rlf_ind,                  /** X2AP_RLF_IND*/
        /*RRC_RRM RLF IND end*/
        /* MRO code changes end */
        rrm_ue_handle_log_and_ignore_event,   /** RRC_RRM_UE_CDMA2000_MOB_INFO_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event,   /** RRC_RRM_DL_NAS_TRANSPORT_IND_EVENT*/
        rrm_ue_intra_enb_ho_ind_event,           /*RRC_RRM_INTRA_ENB_HO_IND_EVENT*/
        /*ue pos start*/
        rrm_ue_handle_lppa_ecid_meas_init_req,   /*S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ_EVENT*/
        rrm_ue_handle_lppa_ecid_meas_termination_cmd,    /*S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND_EVENT*/
        rrm_ue_handle_lppa_error_ind,    /*S1AP_RRM_LPPA_ERROR_IND_EVENT*/
        /*ue pos end*/
        rrm_ue_handle_inter_freq_meas_ind,   /*RRC_RRM_INTER_FREQ_MEASUREMENT_IND*/
        rrm_ue_handle_local_error_ind, /* RRC_RRM_LOCAL_ERROR_IND */
        /*SPR-695 Fix Starts*/
        rrm_ue_handle_lipa_ho_required, /* RRC_RRM_HO_REQUIRED */
        /* SPR 12512 Fix Start */
        rrm_ue_handle_low_priority_ue_rel_event,     /** RRM_RELEASE_LOW_PRIORITY_UE_REL_EVENT   */
        /*SPR-695 Fix Ends*/
        /* SPR_16053_Fix: Start */
        rrm_ue_handle_ue_sync_status_ind_event,     /* RRC_RRM_UE_SYNC_STATUS_IND_EVENT */
        /* SPR 12512 Fix End */
        /* SPR 9216:MRO enhancement start */
        /*SPR 12658:start*/

        rrm_ue_handle_ue_reestab_config_cnf,      /* RRC_RRM_UE_REESTAB_CONFIG_CNF_EVENT */
        /*SPR 12658:end*/
        /* SPR 17784 Start */
        rrm_ue_process_cgi_timer_expiry,           /*RRM_UE_CGI_TIMER_EXPIRY_EVENT*/
       /* SPR 17784 End */
        /* SPR_16053_Fix: End */
        /* SPR 9216:MRO enhancement end */
        /*SPR 11535:start*/
        rrm_ue_handle_rrc_ue_inactivity      /* RRC_RRM_UE_INACTIVE_EVENT */
            /*SPR 11535:end*/
/* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
        ,rrm_ue_handle_dc_bearer_change_cnf      /* RRC_RRM_UE_DC_BEARER_CHANGE_CNF_EVENT */
#endif
/* OPTION3X Changes End */
    },
    /** RRM_UE_STATE_HO_ONGOING */
    {
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_ADMISSION_REQ*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_ADMISSION_CNF*/
 /* SPR 17850 Fix Start */
        rrm_ue_handle_ue_capability_ind_ho_ongoing,		/** RRC_RRM_UE_CAPABILITY_IND*/
        /* SPR 17850 Fix End */
        /*SPR_17893_START*/
        rrm_ue_handle_ue_capability_enquiry_resp_in_ho_ongoing,		/** RRC_RRM_UE_CAPABILITY_ENQUERY_RESP*/
        /*SPR_17893_END*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_SETUP_REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_SETUP_CNF 	*/
        rrm_ue_handle_meas_results_ind,			/** RRC_RRM_MEASURMENT_RESULTS_
                                                  IND*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_MODIFY_REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_RELEASE_REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_MODIFY_CNF 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_ERB_RELEASE_CNF */
        rrm_ue_handle_ue_release_req,			/** RRC_RRM_UE_RELEASE_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/** RRC_RRM_UE_HO_ADM_REQ 	*/
        rrm_ue_handle_ue_ho_adm_cnf,			/** RRC_RRM_UE_HO_ADM_CNF 	*/
        rrm_ue_handle_ue_ho_cmd_req,			/** RRC_RRM_UE_HO_CMD_REQ 	*/
        rrm_ue_handle_ue_ho_failure,			/** RRC_RRM_HO_FAILURE 		*/
        rrm_ue_handle_ue_ho_cancel_resp,		/** RRC_RRM_HO_CANCEL_RESP 	*/
        /*SPR 18241 14JAN START*/
        rrm_ue_handle_ue_context_mod_in_ho_ongoing_state,		/** RRC_RRM_UE_CONTEXT_MOD_REQ_EVENT*/
        /*SPR 18241 14JAN END*/
        rrm_ue_handle_log_and_ignore_event,	    /** RRC_RRM_UE_CONTEXT_MOD_CNF_EVENT */
        rrm_ue_handle_meas_config_resp,          /** RRC_RRM_MEAS_CONFIG_RESP_EVENT */
        /*MC, MR & HO  START */
        rrm_ue_handle_ho_restriction_ind,          /** RRC_RRM_HO_RESTRICTION_LIST_IND_EVENT */
        rrm_ue_handle_log_and_ignore_event,              /**RRC_RRM_UE_TIMER_EXPIRY_EVENT */
        /*MC, MR & HO  END */
        /*LTE_RRM_TM_SWITCH_START*/
        rrm_ue_handle_log_and_ignore_event,              /*RRC_RRM_UE_RECONFIG_RESP_EVENT*/
        rrm_ue_handle_log_and_ignore_event,		/*RRM_MAC_PERIODIC_REPORTS_IND*/
        /*LTE_RRM_TM_SWITCH_END*/
        /*PROXIMITY IND START*/
        rrm_ue_handle_log_and_ignore_event,      /**RRC_RRM_PROXIMITY_IND_EVENT*/
        /*PROXIMITY IND END*/
        /* MRO code changes start */
        /*RRC_RRM RLF IND START*/
        rrm_ue_handle_rlf_ind,                  /** X2AP_RLF_IND*/
        /*RRC_RRM RLF IND end*/
        /* MRO code changes end */
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_UE_CDMA2000_MOB_INFO_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_DL_NAS_TRANSPORT_IND_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_INTRA_ENB_HO_IND_EVENT*/
        /*ue pos start*/
        rrm_ue_handle_lppa_ecid_meas_init_req,   /*S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ_EVENT*/
        rrm_ue_handle_lppa_ecid_meas_termination_cmd,    /*S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND_EVENT*/
        rrm_ue_handle_lppa_error_ind,    /*S1AP_RRM_LPPA_ERROR_IND_EVENT*/
        /*ue pos end*/
        rrm_ue_handle_inter_freq_meas_ind,   /*RRC_RRM_INTER_FREQ_MEASUREMENT_IND*/
        rrm_ue_handle_local_error_ind,       /* RRC_RRM_LOCAL_ERROR_IND */
        /*SPR-695 Fix Starts*/
        rrm_ue_handle_log_and_ignore_event,       /* RRC_RRM_INTER_FREQ_MEASUREMENT_IND */
        /* SPR 12512 Fix Start */
        rrm_ue_handle_low_priority_ue_rel_event,     /** RRM_RELEASE_LOW_PRIORITY_UE_REL_EVENT   */
        /*SPR-695 Fix Ends*/
        /* SPR_16053_Fix: Start */
        rrm_ue_handle_log_and_ignore_event,      /*RRC_RRM_UE_SYNC_STATUS_IND_EVENT*/
        /* SPR 12512 Fix End */
        /* SPR 9216:MRO enhancement start */
        /*SPR 12658:start*/
        /* SPR 17784 Start */
        rrm_ue_handle_ue_reestab_config_cnf,             /* RRC_RRM_UE_REESTAB_CONFIG_CNF_EVENT */
        rrm_ue_handle_ho_ongoing_ue_cgi_timer_expiry,    /*RRM_UE_CGI_TIMER_EXPIRY_EVENT*/
        /* SPR 17784 End */
        /*SPR 12658:end*/
        /* SPR_16053_Fix: End */
        /* SPR 9216:MRO enhancement end */
        /*SPR 11535:start*/
        rrm_ue_handle_rrc_ho_ongoing_ue_inactivity      /* RRC_RRM_UE_INACTIVE_EVENT */
            /*SPR 11535:end*/

/* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
        ,rrm_ue_handle_log_and_ignore_event      /* RRC_RRM_UE_DC_BEARER_CHANGE_CNF_EVENT */
#endif
/* OPTION3X Changes End */
    }
    /*SPR_17893_START*/
    /*RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES */
    ,{
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_UE_ADMISSION_REQ*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_UE_ADMISSION_CNF*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_UE_CAPABILITY_IND*/
        rrm_ue_handle_ue_capability_enquiry_resp,	/*RRC_RRM_UE_CAPABILITY_ENQUERY_RESP*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_ERB_SETUP_REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_ERB_SETUP_CNF */
        rrm_ue_handle_meas_results_ind,  		/*RRC_RRM_MEASURMENT_RESULTS_IND*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_ERB_MODIFY_REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_ERB_RELEASE_REQUEST*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_ERB_MODIFY_CNF 	*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_ERB_RELEASE_CNF */
        rrm_ue_handle_ue_release_req,	        	/*RRC_RRM_UE_RELEASE_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_UE_HO_ADM_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_UE_HO_ADM_CNF 	*/
        rrm_ue_handle_log_and_ignore_event,    	/*RRC_RRM_UE_HO_CMD_REQ 	*/
        rrm_ue_handle_log_and_ignore_event,    	/*RRC_RRM_HO_FAILURE 		*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_HO_CANCEL_RESP 	*/
        rrm_ue_handle_log_and_ignore_event,		/*RRC_RRM_UE_CONTEXT_MOD_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event,	    	/*RRC_RRM_UE_CONTEXT_MOD_CNF_EVENT */
        rrm_ue_handle_meas_config_resp,          	/*RRC_RRM_MEAS_CONFIG_RESP_EVENT */
        rrm_ue_handle_ho_restriction_ind,          	/*RRC_RRM_HO_RESTRICTION_LIST_IND_EVENT */
        rrm_ue_handle_ue_timer_expiry,		        /*RRC_RRM_UE_TIMER_EXPIRY_EVENT */
        rrm_ue_handle_reconfig_resp_event,             /*RRC_RRM_UE_RECONFIG_RESP_EVENT*/
        rrm_ue_handle_log_and_ignore_event,		/*RRM_MAC_PERIODIC_REPORTS_IND*/
        rrm_ue_handle_log_and_ignore_event,      	/*RRC_RRM_PROXIMITY_IND_EVENT*/
        rrm_ue_handle_log_and_ignore_event,         /*X2AP_RLF_IND*/
        rrm_ue_handle_log_and_ignore_event,      	/*RRC_RRM_UE_CDMA2000_MOB_INFO_REQ_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      	/*RRC_RRM_DL_NAS_TRANSPORT_IND_EVENT*/
        rrm_ue_handle_log_and_ignore_event,      	/*RRC_RRM_INTRA_ENB_HO_IND_EVENT*/
        rrm_ue_handle_lppa_ecid_meas_init_req, 		/*S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ_EVENT*/
        rrm_ue_handle_lppa_ecid_meas_termination_cmd,  	/*S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND_EVENT*/
        rrm_ue_handle_lppa_error_ind,    		/*S1AP_RRM_LPPA_ERROR_IND_EVENT*/
        rrm_ue_handle_inter_freq_meas_ind,   		/*RRC_RRM_INTER_FREQ_MEASUREMENT_IND*/
        rrm_ue_handle_local_error_ind,       	        /*RRC_RRM_LOCAL_ERROR_IND */
        rrm_ue_handle_log_and_ignore_event,       	/*RRC_RRM_INTER_FREQ_MEASUREMENT_IND */
        rrm_ue_handle_low_priority_ue_rel_event,     	/*RRM_RELEASE_LOW_PRIORITY_UE_REL_EVENT   */
        rrm_ue_handle_log_and_ignore_event,      	/*RRC_RRM_SYNC_STATUS_IND_EVENT*/
        rrm_ue_handle_ue_reestab_config_cnf,		/*RRC_RRM_UE_REESTAB_CONFIG_CNF_EVENT */
        rrm_ue_handle_ho_ongoing_ue_cgi_timer_expiry,     /**RRM_UE_CGI_TIMER_EXPIRY_EVENT*/
        rrm_ue_handle_rrc_ue_inactivity      /* RRC_RRM_UE_INACTIVE_EVENT */
/* OPTION3X Changes Start */
#ifdef ENDC_ENABLED
        ,rrm_ue_handle_log_and_ignore_event      /* RRC_RRM_UE_DC_BEARER_CHANGE_CNF_EVENT */
#endif
/* OPTION3X Changes End */
    }
    /*SPR_17893_END*/
};
/********************** Function Definitions *******************************/


/*written to remove coverity warning, aditya, rel2.0.1*/
rrm_action_prfmd_et
rrm_map_rrm_action_performed(rrm_oam_action_required_et action)
{
    rrm_action_prfmd_et ret_action = EVENT_ACTION_NONE;

    switch(action)
    {
    case RRM_OAM_EVENT_LOG:
	ret_action = EVENT_ACTION_LOG;
        break;

    case RRM_OAM_EVENT_NOTIFY:
	ret_action = EVENT_ACTION_NOTIFY;
        break;

    case RRM_OAM_EVENT_NOTIFY_LOG:
	ret_action = EVENT_ACTION_NOTIFY_LOG;
        break;

    case RRM_OAM_EVENT_NONE:
    default:
	ret_action = EVENT_ACTION_NONE;
    }
    return ret_action;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_find_context
 *   DESCRIPTION:
 *       Find the UE Context for the cell_index and ue_index received in 
 *       request from RRC or L2
 *   RETURNS:
 *       UE Context
 ******************************************************************************/
/* SPR 20652 Fix Start */
rrm_ue_context_t *
rrm_ue_find_context(
        rrm_ue_index_t   ue_index,
        rrm_cell_index_t cell_index
        )
{
    /*LTE_RRM_KLOCWORK_WARN_5_JULY_12_START*/
    rrm_ue_shelf_node_t *p_ue_node = RRM_PNULL ;
    rrm_cell_context_t *p_cell_ctxt = rrm_cellm_get_cell_context(cell_index);
    /*SPR 21670 Start*/
    /* Total number of ues is the max UE index that can be attached */
    rrm_ue_index_t  total_num_of_ues = RRM_INVALID_UE_INDEX;
    /* Retrieving maximum number of bits that will be used in UE index */
    total_num_of_ues = total_num_of_ues & BITMASK_FOR_UE_ID;
    /*SPR 21670 End*/
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL == p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING, "Cell Context Not Found for Cell index [%d]", cell_index);
        return RRM_PNULL;
    }
    /*SPR 21670 Start*/
    if(total_num_of_ues > ue_index)
    {    
        /*SPR 21670 End*/
    if(RRM_NULL != p_cell_ctxt->rrm_ue_db.p_ue_idx_list)
    {
        if(RRM_ZERO != ylCount(&(p_cell_ctxt->rrm_ue_db.p_ue_idx_list[ue_index].rrm_ue_info_list)))
        {
            p_ue_node = (rrm_ue_shelf_node_t*)ylFirst(&(p_cell_ctxt->rrm_ue_db.p_ue_idx_list[ue_index].rrm_ue_info_list));
            while(p_ue_node != RRM_PNULL)
            {   
                if((rrm_ue_context_t*)p_ue_node->p_ue_context != RRM_PNULL)
                {
                    if(ue_index == ((rrm_ue_context_t*)p_ue_node->p_ue_context)->ue_index)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,"[UE:%d] found for cell index [%d]", ue_index, cell_index);
                        RRM_UT_TRACE_EXIT();
                        return (rrm_ue_context_t*)p_ue_node->p_ue_context;
                    }
                }
                p_ue_node = (rrm_ue_shelf_node_t *)ylNext(&p_ue_node->node); 
            }
        }
    }
    /*SPR 21670 Start*/
    }
    /*SPR 21670 End*/
    RRM_UT_TRACE_EXIT();
    return RRM_PNULL;
   /*LTE_RRM_KLOCWORK_WARN_5_JULY_12_END*/
}
/* SPR 20652 Fix End */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_clean_proc_queue 
 *   DESCRIPTION:
 *       Cleans the procedure queue.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_clean_proc_queue(
        rrm_ue_context_t *p_ue_context 
        )
{
    rrm_return_et 				ret_val = RRM_SUCCESS;
    rrm_ue_procedure_record_t       *p_rrm_ue_procedure_record = RRM_PNULL;

    /* SPR 15849 Start */
    p_rrm_ue_procedure_record = rrm_request_dequeue( p_ue_context );
    /* SPR 15849 End */
    while(RRM_PNULL != p_rrm_ue_procedure_record)
    {
        if (RRM_PNULL != p_rrm_ue_procedure_record->proc_queue.p_proc_data)
        {
            RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
        }
        RRM_MEM_FREE(p_rrm_ue_procedure_record);
        /* SPR 15849 Start */
        p_rrm_ue_procedure_record = rrm_request_dequeue( p_ue_context );
        /* SPR 15849 End */
    }

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_clean_esmlc_meas_queue 
 *   DESCRIPTION:
 *       Cleans the esmlc meas queue.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_clean_esmlc_meas_queue(
        rrm_ue_context_t    *p_ue_context 
        )
{
    rrm_return_et      				 ret_val = RRM_SUCCESS;
    rrm_ue_procedure_record_t       *p_rrm_ue_procedure_record = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /* SPR 15849 Start */
    p_rrm_ue_procedure_record = rrm_request_esmlc_dequeue( p_ue_context );
    /* SPR 15849 End */
    while(RRM_PNULL != p_rrm_ue_procedure_record)
    {
        if (RRM_PNULL != p_rrm_ue_procedure_record->proc_queue.p_proc_data)
        {
            RRM_MEM_FREE(p_rrm_ue_procedure_record->proc_queue.p_proc_data);
        }
        RRM_MEM_FREE(p_rrm_ue_procedure_record);
        /* SPR 15849 Start */
        p_rrm_ue_procedure_record = rrm_request_esmlc_dequeue( p_ue_context );
        /* SPR 15849 End */
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 16406 Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_reset_cell_selection_and_cgi_pending_list 
 *   DESCRIPTION:
 *      This function deletes the existing cell selection list for input ue_context
 *              and also deallocate its cgi pending entry kept in cell context 
 *   RETURNS: NONE
 ******************************************************************************/

rrm_void_t
    rrm_reset_cell_selection_and_cgi_pending_list
(
 rrm_ue_context_t *p_ue_context
 )
{
    ho_pending_cgi_node_t *p_temp_cgi_pending_node = RRM_PNULL;
    ho_pending_cgi_node_t *p_next_cgi_pending_node = RRM_PNULL;
    U16 cgi_node_count = RRM_ZERO;
    YLIST ho_pending_cgi_list;   
    RRM_UT_TRACE_ENTER();

    rrm_cell_context_t *p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    if(RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off,
                p_rrm_uem_facility_name,
                RRM_ERROR,
                "p_cell_context not found for [UE:%u]", p_ue_context->ue_index);
        RRM_UT_TRACE_EXIT();
        return;
    }

    ylInit(&ho_pending_cgi_list);


    /* First reset all the ho cell selection list */
    p_ue_context->ho_params.eutra_known_cell_selection_list.count = RRM_ZERO;
    p_ue_context->ho_params.eutra_unknown_cell_selection_list.count = RRM_ZERO;
    p_ue_context->ho_params.eutra_confused_cell_selection_list.count = RRM_ZERO;
    p_ue_context->ho_params.utra_known_cell_selection_list.count = RRM_ZERO;
    p_ue_context->ho_params.utra_unknown_cell_selection_list.count = RRM_ZERO;
    p_ue_context->ho_params.utra_confused_cell_selection_list.count = RRM_ZERO;
    p_ue_context->ho_params.geran_known_cell_selection_list.count = RRM_ZERO;
    p_ue_context->ho_params.geran_unknown_cell_selection_list.count = RRM_ZERO;
    p_ue_context->ho_params.geran_confused_cell_selection_list.count = RRM_ZERO;

    /* Now RRM will delete all entries of this UE in ho cgi pending list if any*/

    /* Assigning actual list kept in cell context */
    ho_pending_cgi_list = p_cell_context->rrm_cgi_pending_list.
        rrm_ho_pending_cgi_list[p_cell_context->cell_index].ho_pending_cgi_list;

    cgi_node_count = ylCount(&ho_pending_cgi_list);

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
            "present count in ho cgi pending list :%u ",cgi_node_count);

    p_temp_cgi_pending_node = (ho_pending_cgi_node_t *)ylFirst(&ho_pending_cgi_list);
    while(p_temp_cgi_pending_node)
    {
        if(p_temp_cgi_pending_node->ho_pending_cgi_node_data.ue_idx == p_ue_context->ue_index )
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                    "deleting entry in ho cgi pending list [PCI:%u and EARFCN:%u] ",
                    p_temp_cgi_pending_node->ho_pending_cgi_node_data.pci,
                    p_temp_cgi_pending_node->ho_pending_cgi_node_data.earfcn);

            p_next_cgi_pending_node = (ho_pending_cgi_node_t *)ylNext(&p_temp_cgi_pending_node->node);
            ylDelete(&ho_pending_cgi_list , (YLNODE *)p_temp_cgi_pending_node);
            RRM_MEM_FREE(p_temp_cgi_pending_node);
            p_cell_context->rrm_cgi_pending_list.
                rrm_ho_pending_cgi_list[p_cell_context->cell_index].ho_pending_cgi_list
                = ho_pending_cgi_list;
            p_temp_cgi_pending_node = p_next_cgi_pending_node;
        }
        else    
        {
            p_temp_cgi_pending_node = (ho_pending_cgi_node_t *)ylNext(&p_temp_cgi_pending_node->node);
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 16406 End */
/* SPR 20652 Fix Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_delete_ue_ctxt_node
 *   DESCRIPTION:
 *      This function deletes the node corresponding to the ue_context
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_void_t
rrm_delete_ue_ctxt_node (
            rrm_ue_index_t      ue_idx,
            rrm_ue_shelf_node_t **p_ue_node,
            rrm_cell_context_t  *p_rrm_cell_ctx,
            rrm_ue_context_t    **p_ue_context
            )
{
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != *p_ue_node)
    {
        RRM_MEM_FREE (*p_ue_context);
        ylDelete(&(p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[ue_idx].rrm_ue_info_list), &((*p_ue_node)->node));
        RRM_MEM_FREE (*p_ue_node);
        if(RRM_ZERO == ylCount(&(p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[ue_idx].rrm_ue_info_list)))
        {
            if(p_rrm_cell_ctx->rrm_ue_db.head_idx == ue_idx) 
            {
                if(p_rrm_cell_ctx->rrm_ue_db.tail_idx == ue_idx)
                {
                    p_rrm_cell_ctx->rrm_ue_db.head_idx = p_rrm_cell_ctx->rrm_ue_db.tail_idx = RRM_INVALID_UE_INDEX;
                }
                else
                {
                    p_rrm_cell_ctx->rrm_ue_db.head_idx = p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_rrm_cell_ctx->rrm_ue_db.head_idx].next_idx;
                    p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_rrm_cell_ctx->rrm_ue_db.head_idx].prev_idx = RRM_INVALID_UE_INDEX; 
                }
            }
            else if(p_rrm_cell_ctx->rrm_ue_db.tail_idx == ue_idx)
            {
                p_rrm_cell_ctx->rrm_ue_db.tail_idx = p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_rrm_cell_ctx->rrm_ue_db.tail_idx].prev_idx;
                p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_rrm_cell_ctx->rrm_ue_db.tail_idx].next_idx = RRM_INVALID_UE_INDEX;
            }
            else
            {
                p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[ue_idx].prev_idx].next_idx = p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[ue_idx].next_idx;
                p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[ue_idx].next_idx].prev_idx = p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[ue_idx].prev_idx; 
            }
            /* SPR 21644 start */
            p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[ue_idx].prev_idx = RRM_INVALID_UE_INDEX;
            p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[ue_idx].next_idx = RRM_INVALID_UE_INDEX;
            /* SPR 21644 end */
        }
        RRM_UT_TRACE_EXIT();
    }

}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_get_ue_ctxt_node
 *   DESCRIPTION:
 *      This function returns the node corresponding to the ue_context
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_void_t
rrm_ue_get_ue_ctxt_node (
        rrm_ue_index_t ue_index,
        rrm_cell_index_t cell_index,
        rrm_ue_shelf_node_t **p_node,
        rrm_ue_context_t    **p_ue_context 
        )
{
    rrm_ue_shelf_node_t *p_tmp_node = RRM_PNULL;
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_ASSERT(RRM_PNULL != p_rrm_cell_ctx);
    RRM_UT_TRACE_ENTER();
    
    p_tmp_node = (rrm_ue_shelf_node_t*)ylFirst(&(p_rrm_cell_ctx->rrm_ue_db.p_ue_idx_list[ue_index].rrm_ue_info_list));
    while(p_tmp_node != RRM_PNULL)
    {   
        if(ue_index == ((rrm_ue_context_t*)p_tmp_node->p_ue_context)->ue_index)
        {
            *p_node = p_tmp_node;
            *p_ue_context = ((rrm_ue_context_t*)p_tmp_node->p_ue_context);
            return ;
        }
        p_tmp_node = (rrm_ue_shelf_node_t*)ylNext(&p_tmp_node->node);
    }
    RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR,"UE Context Node not found for ue index [%d]", ue_index);
    RRM_UT_TRACE_EXIT();

}
/* SPR 20652 Fix End */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_mgr_delete_context
 *   DESCRIPTION:
 *      This function deletes the existing ue_contexts 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_delete_context (
        rrm_cell_index_t cell_index,
        rrm_ue_index_t ue_index 
        )
{
    rrm_return_et 				ret_val = RRM_SUCCESS;
    U8                                  count = RRM_ZERO;
    /* SPR 20652 Fix Start */
    rrm_ue_context_t    *p_ue_context = RRM_PNULL;
    rrm_ue_shelf_node_t *p_ue_node = RRM_PNULL ;
    /* SPR 20652 Fix End */
    /*CA HARDENING CHANGES*/
    /* BUG_876_CHANGES_START*/
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    /* BUG_876_CHANGES_END*/

    RRM_UT_TRACE_ENTER();

    /* BUG_876_CHANGES_START*/
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_ASSERT(RRM_PNULL != p_rrm_cell_ctx);
    /* BUG_876_CHANGES_END*/

    /* SPR 20652 Fix Start */
    rrm_ue_get_ue_ctxt_node(ue_index, cell_index, &p_ue_node, &p_ue_context);
    if(RRM_PNULL != p_ue_context)
    {
        /* Code Removed */
    /* SPR 20652 Fix End */

        /*CA HARDENING CHANGES */
        /*SPR_15323 start*/
        if(RRM_TRUE == p_ue_context->srb_allocated)
        {
            /*SPR 21936 Start */
            ret_val = rrm_ue_rac_release_cell_resources(p_ue_context);
            /*SPR 21936 End */
            /*SPR_15323 end*/
            if(RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "[UE:%d],unable to release resources for the UE" ,
                        p_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, "[UE:%d],successfully released all resources for the UE" ,
                        p_ue_context->ue_index);
                /*SPR_15323 start*/
                p_ue_context->srb_allocated = RRM_FALSE;
            }
            /*SPR_15323 end*/
        }
        /* SPR 16406 Start */
        rrm_reset_cell_selection_and_cgi_pending_list(p_ue_context);
        /* SPR 16406 End */
        
        /*DYNAMIC ICIC START*/
        /*
         ** Decrement the repective dynamic ICIC counters at the time of UE release.
         ** -- Decrement CE UE'S count , if the current position of the UE gettin released is CE
         ** -- Decrement CC UE'S count , if the current position of the UE gettin released is CC
         ** -- Decrement UE'S vd max P_A count , if the currently configured P_A value or the 
         **    UE gettin released is equal to MAX possible value.
         */
        if( RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position)    
        {
             rrm_cellm_decrement_dynamic_icic_counter_in_cell(cell_index, RRM_CELLM_DYNAMIC_ICIC_CELL_EDGE_UES);
        }
        else
        {
             rrm_cellm_decrement_dynamic_icic_counter_in_cell(cell_index, RRM_CELLM_DYNAMIC_ICIC_CELL_CENTER_UES);
        }

        /* BUG_876_CHANGES_START*/
        /* This means that RM has increased the pA to maximum number and this counter will be incremented
         * only when the pA was increased through ramping step. in this case, this should be decremented
         */
        if( (MAX_VALUE_FOR_P_A == p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.p_a_configured) &&
                (MAX_VALUE_FOR_P_A != p_rrm_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a) &&
                (MAX_VALUE_FOR_P_A != p_rrm_cell_ctx->dynamic_icic_data.pdsch_config_params.pdsch_dedicated_config.pa_for_ce_ue))
       {
           rrm_cellm_decrement_dynamic_icic_counter_in_cell(cell_index,RRM_CELLM_DYNAMIC_ICIC_P_MAX_UES);
       }
        /* BUG_876_CHANGES_END*/
        /*DYNAMIC ICIC END*/
        /* CA Changes Shariq: Start */
        /* In case if Ue is released & UE was using a Scell then the UE context pointer in Cell context's Scell List 
           needs to removed before deleting UE context. */
        if(p_ue_context->ue_scell_add_params.count != RRM_ZERO)
        {
            for(count = RRM_ZERO; count < p_ue_context->ue_scell_add_params.count; count++)
            {
                rrm_delete_ue_in_scell_list_of_cell( cell_index,
                        p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index,
                        p_ue_context);
            }/*End of For*/
        }
        /* CA Changes Shariq: End */
        /* BUG_11576_FIX_START */
        /* SPR 15441 start */
        /* code removed */
        /* SPR 15441 end */
        if(RRM_PNULL != p_ue_context->current_procedure.p_erb_success_list)
        {
            RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_success_list);
        }
        if(RRM_PNULL != p_ue_context->current_procedure.p_erb_failed_list)
        {
            RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_failed_list);
        }
        /* SPR 21496 Fix Start */ 
        if (RRM_PNULL != p_ue_context->p_meas_config_of_ho_adm)
        {
          RRM_MEM_FREE(p_ue_context->p_meas_config_of_ho_adm);
        }
        if (RRM_PNULL != p_ue_context->p_ue_mac_report)
        {
          RRM_MEM_FREE(p_ue_context->p_ue_mac_report);
        }
        if (RRM_PNULL != p_ue_context->p_meas_obj_cdma2000_info)
        {
          RRM_MEM_FREE(p_ue_context->p_meas_obj_cdma2000_info);
        }
        if (RRM_PNULL != p_ue_context->p_meas_config)
        {
          RRM_MEM_FREE(p_ue_context->p_meas_config);
        }
        if (RRM_PNULL != p_ue_context->p_ue_positioing_data)
        {
          rrm_clean_ue_all_ecid_meas_related_info(p_ue_context);
          RRM_MEM_FREE(p_ue_context->p_ue_positioing_data);
        }
        /* SPR 21496 Fix End */ 
        /* BUG_11576_FIX_END */
        /* SPR 20652 Fix Start */
        rrm_delete_ue_ctxt_node(ue_index, &p_ue_node, p_rrm_cell_ctx, &p_ue_context);
        /* SPR 20652 Fix End */
    }
    else
    {
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_delete_all_ue_context 
 *   DESCRIPTION:
 *       Deletes all the ue_context of a cell.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_uem_delete_all_ue_context(
        U8 cell_index
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    rrm_seq_data_info_t     ue_node;
    rrm_ue_context_t        *p_ue_context = RRM_PNULL;
    rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
    if (RRM_PNULL == p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,"No UE present on cell index: %d", cell_index);
        ret_val = RRM_SUCCESS;
        return ret_val;
    }	
    while(p_ue_context != RRM_PNULL)
    {
        /* SPR 21412 Fix Start */
        if(p_ue_context->cell_index == cell_index)
        {
        /* SPR 21412 Fix End */
        /*SPR-668 Fix Starts*/
        if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
        {
            RRM_TRACE(g_uem_log_on_off,
                    p_g_rrm_uem_facility_name,
                    RRM_DETAILED,
                    "ue_connection_release_ind sent, \
                    Failed to clean up ue resources");
            ret_val = RRM_FAILURE;
            break;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off,
                    p_g_rrm_uem_facility_name,
                    RRM_DETAILED,
                    "successfully cleaned up resources for the ue");
            /*SPR-10279 Fix Starts */
            /* lines deleted */
            /*SPR-10279 Fix Ends */
        }
        /*SPR-668 Fix Ends*/
        /*SPR-10279 Fix Starts */
        /* lines deleted */
        /*SPR-10279 Fix Ends */
        if(RRM_FAILURE == ret_val)
        {
#ifdef RRM_UT_FLAG
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.delete_all_ue_resp_F);
#endif                
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Unable to delete context for [UE:%d]", 
                    p_ue_context->ue_index);
            break;
        }
	ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
        /* SPR 20652 Fix End */
        /* SPR 21412 Fix Start */
        }
        /* SPR 21412 Fix End */
    }
    return ret_val;
}
/** TNL feature */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_calculate_total_gbr 
 *   DESCRIPTION:
 *               Calculate total bit rate
 *   RETURNS:
 *       total bit rate
 ******************************************************************************/
void
rrm_ue_calculate_total_bit_rate
(
    rrm_ue_context_t         *p_ue_context,
    U64                      *ul_total_gbr_ue, /*outgoing total ul gbr*/
    U64                      *dl_total_gbr_ue /*outgoing total dl gbr*/
)
{
    U16         drb_configured_index = RRM_NULL;
    
    RRM_UT_TRACE_ENTER();
    for(drb_configured_index = RRM_NULL; 
            drb_configured_index<p_ue_context->drb_configured.num_of_list;
            drb_configured_index ++)
    {
            (*dl_total_gbr_ue) += p_ue_context->drb_configured.erab_item[drb_configured_index].
                         erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_dl;

            (*ul_total_gbr_ue) += p_ue_context->drb_configured.erab_item[drb_configured_index].
                         erab_level_qos_params.gbr_qos_info.erab_guar_bit_rate_ul;
    }
    /* SPR 21251 +- */

    RRM_UT_TRACE_EXIT();
}
/* SPR 21367 Fix Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_get_admitted_bit_rate 
 *   DESCRIPTION:
 *               Get already admitted bit rate
 *   RETURNS:
 *       required bit rate
 ******************************************************************************/
rrm_void_t
rrm_get_admitted_bit_rate(
        rrm_cell_context_t *p_cell_context,
        U64                *p_ul_bitrate,
        U64                *p_dl_bitrate
        )
{
    RRM_UT_TRACE_ENTER();

    (*p_ul_bitrate)+= p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.ul_bitrate;
    (*p_dl_bitrate)+= p_cell_context->rrm_ue_admitted_bitrate.ue_gbr_bitrate.dl_bitrate;

    RRM_UT_TRACE_EXIT();
}
/* SPR 21367 Fix End */
/* SPR-18654 END */
/**TNL feature */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_mgr_msg_handler
 *   DESCRIPTION:
 *       Handles the incoming messages, received from RRC.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
S32
rrm_ue_mgr_msg_handler (
        rrm_void_t *p_api_buf, 
        rrm_void_t *p_gl_ctx
        )
{
    /* BUG_11576_FIX_START */
    U16                 src_id = RRM_NULL;
    RRM_ASSERT(RRM_PNULL != p_api_buf);
    RRM_ASSERT(RRM_PNULL != p_gl_ctx);
    /** Get the source ID */
    RRM_UT_TRACE_ENTER();
    src_id = rrm_get_src_module_id((U8*)(p_api_buf));
    switch( src_id )
    {
        case RRC_MODULE_ID :
             rrm_ue_mgr_rrc_msg_handler(p_api_buf, p_gl_ctx); 
            break;
        case RRM_L2_MODULE_ID :
             rrm_ue_mgr_l2_msg_handler(p_api_buf, p_gl_ctx);
            break;
        case RRM_MIF_MODULE_ID:
             rrm_ue_mgr_rrm_if_msg_handler(p_api_buf, p_gl_ctx);
            break;
        case RRM_CM_MODULE_ID:
             rrm_ue_mgr_rrm_cm_msg_handler(p_api_buf, p_gl_ctx);
            break;
        case PDCP_MODULE_ID:
             rrm_ue_mgr_pdcp_msg_handler(p_api_buf);/*SPR 17777 +-*/
	    /*coverity 24976: break added: aditya, rel 1.3*/
	    break;
        default :
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                      "Invalid Source Id[%d]", src_id);
    }
    SET_CELL_AND_UE_INDEX(0xFF, 0xFFFF);
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS; 
    /* BUG_11576_FIX_END */
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_handle_rmif_emergency_call_active_req 
 *   DESCRIPTION:
 *       Process the emergency call active req from mif
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/

rrm_return_et 
rrm_uem_handle_rmif_emergency_call_active_req(
        rrm_void_t *p_data
         /*SPR 17777 +-*/
        )
{
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* SPR 20652 Fix End */
    rrm_cell_index_t cell_index = RRM_NULL;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_bool_et response = RRM_FALSE;
    U16 trans_id = RRM_NULL;

    rrmuem_rmif_emergency_call_active_req_t  
        *p_rrmuem_rmif_emergency_call_active_req = RRM_PNULL;
    p_rrmuem_rmif_emergency_call_active_req = 
        (rrmuem_rmif_emergency_call_active_req_t *)(p_data);

    trans_id = p_rrmuem_rmif_emergency_call_active_req->transaction_id;
    cell_index = p_rrmuem_rmif_emergency_call_active_req->cell_index;
    SET_CELL_INDEX(cell_index);

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->UEM:RRMUEM_RMIF_EMERGENCY_CALL_ACTIVE_REQ");
    /* SPR 20652 Fix Start */
    rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
    if (RRM_PNULL == p_ue_context)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"UE context not found");
		response = RRM_FALSE;
	}
    else
    {
      while(p_ue_context != RRM_PNULL)
      {
          /* Bug_12633_fix: Start */
          /* SPR 17564 Fix Start */
          if (RRM_TRUE == rrm_is_ue_special_previledge(p_ue_context))
              /* SPR 17564 Fix End */
          {
              response = RRM_TRUE;
              break;
          }
          /* Bug_12633_fix: End */
          ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
      }
    }
    /* SPR 20652 Fix End */
    ret_val = rrm_uem_send_rmif_emergency_call_active_resp(trans_id, cell_index
            , response);
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_send_rmif_emergency_call_active_resp
 *   DESCRIPTION:
 *       Send the emergency call active resp
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_uem_send_rmif_emergency_call_active_resp(
        U16 trans_id,
        rrm_cell_index_t cell_index,
        rrm_bool_et response
        )
{
    rrm_return_et ret_val = RRM_FAILURE;
    U16             api_id = RRM_ZERO;
    U16             msg_size = RRM_ZERO;
    U8              *p_msg = RRM_PNULL;

    rrmuem_rmif_emergency_call_active_res_t 
        *p_rrmuem_rmif_emergency_call_active_res;

    RRM_UT_TRACE_ENTER();
    p_rrmuem_rmif_emergency_call_active_res = 
        rrm_mem_get(sizeof(rrmuem_rmif_emergency_call_active_res_t));
    if( RRM_PNULL == p_rrmuem_rmif_emergency_call_active_res)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return RRM_FAILURE;
    }

    p_rrmuem_rmif_emergency_call_active_res->transaction_id = trans_id;
    p_rrmuem_rmif_emergency_call_active_res->cell_index = cell_index;
    p_rrmuem_rmif_emergency_call_active_res->emergency_call_ongoing = response;

    msg_size = sizeof(rrmuem_rmif_emergency_call_active_res_t);
    p_msg = (rrm_void_t *)p_rrmuem_rmif_emergency_call_active_res;
    api_id = RRMUEM_RMIF_EMERGENCY_CALL_ACTIVE_RES;

    ret_val = rrm_uem_send_internal_msg (RRM_MIF_MODULE_ID, 
            api_id,
            msg_size,
            p_msg);
    if( RRM_FAILURE == ret_val )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"RRM send to MIF failed %d\n",api_id);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Sent to MIF %d", api_id);
    }
    RRM_MEM_FREE(p_rrmuem_rmif_emergency_call_active_res);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*****************************************************************************
 * Function Name  : rrm_uem_log_enable_disable_cmd
 * Inputs         : Log Enable/Disable
 *                  Log Level to be set
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes RRM_OAM_LOG_ENABLE_DISABLE_REQ msg
 *                  to set the logging parameters for RRM UEM
 ****************************************************************************/
rrm_void_t rrm_uem_log_enable_disable_cmd (
        rrm_ue_global_context_t *p_rrm_glb_ctxt,
        rrm_uem_log_on_off_et log_on_off,
        rrm_uem_log_level_et log_level)
{
    RRM_UT_TRACE_ENTER();

    p_rrm_glb_ctxt->log_level = log_level;
    if((U32)RRM_OAM_LOG_OFF == (U32)log_on_off)
    {
        /* coverity : CID 16391*/
        log_level = RRM_UEM_LOG_LEVEL_NONE;
    }
    /* coverity : CID 16392*/
    SET_MODULE_LOG_LEVEL((rrm_oam_log_level_et)log_level);
    /* coverity : CID 16393*/
    p_rrm_glb_ctxt->log_enabled = (U8)log_on_off;
    g_uem_log_on_off = (rrm_bool_et) p_rrm_glb_ctxt->log_enabled ;
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, 
            "rrm_oam_log_enable_disable_cmd: Log enable/disable = %d",
            log_on_off);

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_handle_rmif_init_config_req
 *   DESCRIPTION:
 *        Send INIT config resp to MIF
 g_enable_disable_cmd(p_rrm_glb_ctxt,
            p_init_config->log_on_off,
                        p_init_config->log_level);
 *   RETURNS:
 *       void
 ******************************************************************************/
rrm_return_et
rrm_uem_handle_rmif_init_config_req(
        U8 *p_data,
        rrm_ue_global_context_t *p_rrm_glb_ctxt
        )
{
    U16             api_id = RRM_ZERO;
    U16             msg_size = RRM_ZERO;
    U8              *p_msg = RRM_PNULL;
    rrm_return_et   ret_val = RRM_SUCCESS;
            
    RRM_UT_TRACE_ENTER();
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->UEM:RRMUEM_RMIF_INIT_CONFIG_REQ");
    rrmuem_rmif_init_config_req_t *p_rrmuem_rmif_init_config_req = 
        (rrmuem_rmif_init_config_req_t *)p_data;
    rrmuem_rmif_init_config_res_t *p_rrmuem_rmif_init_config_res = RRM_PNULL;
    p_rrmuem_rmif_init_config_res = 
        rrm_mem_get(sizeof(rrmuem_rmif_init_config_res_t));

    if( RRM_PNULL == p_rrmuem_rmif_init_config_res)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return RRM_FAILURE;
    }
    rrm_uem_log_enable_disable_cmd(p_rrm_glb_ctxt,
            p_rrmuem_rmif_init_config_req->log_on_off,
            p_rrmuem_rmif_init_config_req->log_level);
    
    
    p_rrmuem_rmif_init_config_res->transaction_id = 
        p_rrmuem_rmif_init_config_req->transaction_id;
    p_rrmuem_rmif_init_config_res->response = RRM_TRUE;
    
#ifdef RRM_UT_FLAG
    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.init_config_resp_S_uem);
#endif                
    msg_size = sizeof(rrmuem_rmif_init_config_res_t);
    p_msg = (rrm_void_t *)p_rrmuem_rmif_init_config_res;
    api_id = RRMUEM_RMIF_INIT_CONFIG_RES;
    ret_val = rrm_uem_send_internal_msg (RRM_MIF_MODULE_ID,
            api_id,
            msg_size,
            p_msg);
    if( RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"RRM \
                 send to MIF failed %d\n",api_id);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "Sent to MIF %d", api_id);
    }
    RRM_MEM_FREE(p_rrmuem_rmif_init_config_res);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR_13117_FIX_START */
/****************************************************************************
 * Function Name  : rrm_uem_handle_rmif_get_log_level_req
 * Inputs         : rrm_ue_global_context_t *p_rrm_ue_glb_ctxt : global context
 *                : rrm_void_t *p_api :pointer to input API buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes set log level request
 ****************************************************************************/

rrm_return_et
rrm_uem_handle_rmif_get_log_level_req(
        rrm_ue_global_context_t     *p_rrm_ue_glb_ctxt,
        rrm_void_t *p_api /*Input Api buffer*/
         /*SPR 17777 +-*/
        )
{
    rrm_return_et ret_val = RRM_FAILURE;
    rrmuem_rmif_get_log_level_resp_t  rrmuem_rmif_get_log_level_resp = {RRM_ZERO} ;
    rrmuem_rmif_get_log_level_req_t *p_rrmuem_rmif_get_log_level_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->UEM:RRMUEM_RMIF_GET_LOG_LEVEL_REQ");
    
    p_rrmuem_rmif_get_log_level_req = (rrmuem_rmif_get_log_level_req_t*)p_api;

    if ((RRM_PNULL != p_rrm_ue_glb_ctxt) && (RRM_PNULL != p_rrmuem_rmif_get_log_level_req))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "received module_id is:%u",p_rrmuem_rmif_get_log_level_req->module_id);

        rrmuem_rmif_get_log_level_resp.module_id = p_rrmuem_rmif_get_log_level_req->module_id;
        rrmuem_rmif_get_log_level_resp.transaction_id = p_rrmuem_rmif_get_log_level_req->transaction_id;
        rrmuem_rmif_get_log_level_resp.log_level_on_off_on_ue = p_rrm_ue_glb_ctxt->log_enabled;
        rrmuem_rmif_get_log_level_resp.log_level_for_uem = p_rrm_ue_glb_ctxt->log_level;

        rrm_get_cellm_log_level(&rrmuem_rmif_get_log_level_resp.log_level_on_off_on_cell,
                &rrmuem_rmif_get_log_level_resp.log_level_for_cellm);

	/* SPR 18891 fix start */
	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
			"received log_eable_flag : %d\n, log_level from CELLM : %d\n",
			rrmuem_rmif_get_log_level_resp.log_level_on_off_on_cell,
			rrmuem_rmif_get_log_level_resp.log_level_for_cellm);
	/* SPR 18891 fix stop */

        ret_val = rrm_send_internal_msg(
                RRM_MIF_MODULE_ID,
                RRMUEM_RMIF_GET_LOG_LEVEL_RESP,
                sizeof(rrmuem_rmif_get_log_level_resp_t),
                &rrmuem_rmif_get_log_level_resp);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR_13117_FIX_END */

/****************************************************************************
 * Function Name  : rrm_uem_handle_rmif_set_log_level_req 
 * Inputs    	  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 *                : rrm_void_t *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes set log level request 
 ****************************************************************************/

rrm_return_et
rrm_uem_handle_rmif_set_log_level_req(
        rrm_ue_global_context_t     *p_rrm_glb_ctxt,
        rrm_void_t *p_api /*Input Api buffer*/
         /*SPR 17777 +-*/
        )
{
    rrm_return_et ret_val = RRM_FAILURE;
    
    rrm_void_t *ptr = RRM_PNULL;
    rrmuem_rmif_set_log_level_req_t *rrmuem_rmif_set_log_lvl = RRM_PNULL;
    rrmuem_rmif_set_log_level_res_t *p_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->UEM:RRMUEM_RMIF_SET_LOG_LEVEL_REQ");
    
    rrmuem_rmif_set_log_lvl =
        (rrmuem_rmif_set_log_level_req_t *)p_api;
    
    /* coverity : CID 16390*/
    rrm_uem_log_enable_disable_cmd(p_rrm_glb_ctxt,
            (rrm_uem_log_on_off_et) p_rrm_glb_ctxt->log_enabled,
            rrmuem_rmif_set_log_lvl->log_level);
    /* BUG_11576_FIX_START */
    p_resp = rrm_mem_get(sizeof(rrmuem_rmif_set_log_level_res_t));
    /* BUG_11576_FIX_END */
    if( RRM_PNULL == p_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return RRM_FAILURE;
    }
    p_resp->transaction_id = rrmuem_rmif_set_log_lvl->transaction_id;
    /* coverity : CID 16394*/
    p_resp->response = RRM_TRUE;
    ptr =(rrm_void_t *)p_resp;

    if (RRM_FAILURE == rrm_uem_send_internal_msg(
                         RRM_MIF_MODULE_ID,
                         RRMUEM_RMIF_SET_LOG_LEVEL_RES,
                         sizeof(rrmuem_rmif_set_log_level_res_t),
                         ptr))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"RRM send to MIF failed"); /* Coverity: CID 11109 */
    }

    /* COVERITY : RESOURCE LEAK : CID : 48273 fix start */
    /* BUG_11576_FIX_START */
    RRM_MEM_FREE(p_resp);
    /* BUG_11576_FIX_END */
    /* COVERITY : RESOURCE LEAK : CID : 48273 fix end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_fill_error_event_subclass_index
 * Inputs         : p_rrm_glb_ctxt
 *                : subclass
 *                : action 
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : This function fills error event subclass index
 ****************************************************************************/
rrm_bool_et
rrm_fill_error_event_subclass_index(rrm_ue_global_context_t     *p_rrm_glb_ctxt,
                                       rrm_oam_event_subclass_et    subclass,
                                       rrm_oam_action_required_et   action)
{
  rrm_bool_et ret_val = RRM_TRUE;
  RRM_UT_TRACE_ENTER();

  rrm_action_prfmd_et rrm_action = rrm_map_rrm_action_performed(action);
    
  switch (subclass)
  {
   case RRM_OAM_EE_MEMORY_SPECIFIC:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_EE_MEMORY_SPECIFIC_INDEX]= rrm_action;
   break;

   case RRM_OAM_EE_TIMER_SPECIFIC:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_EE_TIMER_SPECIFIC_INDEX]= rrm_action;
   break;

   case RRM_OAM_EE_IPC_SEND_RECV_SPECIFIC:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_EE_SEND_RECD_SPECIFIC_INDEX]= rrm_action;
   break;

   default:
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
              "invalid subclass[%d] received", subclass);
    ret_val = RRM_FALSE;
    break;
  }/*switch case ends here*/

  RRM_UT_TRACE_EXIT();
  return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_fill_protocol_event_subclass_index 
 * Inputs         : p_rrm_glb_ctxt: Pointer to global context
 *                : subclass: event subclass
 *                  action: action to be taken on event subclass
 * Returns        : void
 * Description    : This function fill index assigned for the 
 *                  subclass with action
 ****************************************************************************/
rrm_bool_et 
rrm_fill_protocol_event_subclass_index(rrm_ue_global_context_t     *p_rrm_glb_ctxt,  
                                       rrm_oam_event_subclass_et    subclass,
                                       rrm_oam_action_required_et   action)
{
  rrm_bool_et ret_val = RRM_TRUE;

  rrm_action_prfmd_et rrm_action = rrm_map_rrm_action_performed(action);
   
  RRM_UT_TRACE_ENTER();

  switch(subclass)
  {
    case RRM_OAM_PE_CELL_SPECIFIC:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_CELL_SPECIFIC_INDEX]= rrm_action;
    break;  

    case RRM_OAM_PE_UE_SPECIFIC:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_UE_SPECIFIC_INDEX]= rrm_action;
    break;  

    case RRM_OAM_PE_ERAB_SPECIFIC:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_ERAB_SPECIFIC_INDEX]= rrm_action;
    break;  

    case RRM_OAM_PE_MEAS_INFO:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_MEAS_INFO_INDEX]= rrm_action;
    break;  

    case RRM_OAM_PE_HO_OUT:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_HO_OUT_INDEX]= rrm_action;
    break;  

    case RRM_OAM_PE_HO_IN:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_HO_IN_INDEX]= rrm_action;
    break;  

    case RRM_OAM_PE_OTHERS:
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_OTHERS_INDEX]= rrm_action;
    break;  
 
    default:
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
              "invalid subclass[%d] received", subclass);
    ret_val = RRM_FALSE;
    break; 
  }/*switch case ends*/
  
  if (ret_val)
  {
    p_rrm_glb_ctxt->event_config.pe_subcls = RRM_TRUE;
  } 
  
  RRM_UT_TRACE_EXIT();
  return ret_val;
}

/**********************************************************************
 * Function Name  : rrm_set_ee_subclass_index
 * Inputs         : p_rrm_glb_ctxt
 *                : action
 * Returns        : void
 * Description    : This function sets error subclass index.
 **********************************************************************/
void rrm_set_ee_subclass_index(rrm_ue_global_context_t  *p_rrm_glb_ctxt,
                               rrm_action_prfmd_et       action)
{
  RRM_UT_TRACE_ENTER();

  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_EE_MEMORY_SPECIFIC_INDEX]= action;
  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_EE_TIMER_SPECIFIC_INDEX]= action;
  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_EE_SEND_RECD_SPECIFIC_INDEX]= action;

  RRM_UT_TRACE_EXIT();
}

/* SPR 19580 Changes Start */
/**********************************************************************
 * Function Name  : rrm_fill_dir_of_congestion_ecn
 * Inputs         : direction_of_congestion
 *                : action
 * Returns        : direction of congestion
 * Description    : This function checks the ECN applied direction and 
 * 		    fills the direction of congestion.
 **********************************************************************/
static U8
rrm_fill_dir_of_congestion_ecn(U8 direction_ecn_applied 
                                                                                        )
{
	RRM_UT_TRACE_ENTER();

	/* if ECN_APPLIED_IN_BOTH_UL_DL then direction of congestion*/
	if ((direction_ecn_applied & ECN_UL_BIT_PRESENT) && (direction_ecn_applied & ECN_DL_BIT_PRESENT))
	{
		RRM_UT_TRACE_EXIT();
		return RRM_TWO;
	}

	/* if ECN_APPLIED_IN_UL then direction of congestion*/            
	else if (direction_ecn_applied & ECN_UL_BIT_PRESENT)
	{
		RRM_UT_TRACE_EXIT();
		return RRM_ONE;
	}

	/* if ECN_APPLIED_IN_DL then direction of congestion*/             
	else 
	{
		RRM_UT_TRACE_EXIT();
		return RRM_ZERO;
	}          
}

/* SPR 19580 Changes End */

/****************************************************************************
 * Function Name  : rrm_set_pe_subclass_index
 * Inputs         : rrm_ue_global_context_t *p_rrm_glb_ctxt: global context
 *                : rrm_action_prfmd_et  action : set action on subclass index
 *
 * Returns        : void
 * Description    : This function set action on the subclass index.
 ****************************************************************************/
void rrm_set_pe_subclass_index(rrm_ue_global_context_t  *p_rrm_glb_ctxt, 
                               rrm_action_prfmd_et       action)
{
  RRM_UT_TRACE_ENTER();
  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_CELL_SPECIFIC_INDEX]= action;
  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_UE_SPECIFIC_INDEX]= action;
  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_ERAB_SPECIFIC_INDEX]= action;
  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_MEAS_INFO_INDEX]= action;
  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_HO_OUT_INDEX]= action;
  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_HO_IN_INDEX]= action;
  p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_OTHERS_INDEX]= action;
  RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_uem_handle_rmif_event_config_req
 * Inputs         : rrm_ue_global_context_t *p_rrm_glb_ctxt: global context
 *                : rrm_void_t              *p_api: pointer to input API buffer
 *
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes event config request received from MIF.
 ****************************************************************************/
rrm_return_et
rrm_uem_handle_rmif_event_config_req(rrm_ue_global_context_t  *p_rrm_glb_ctxt,
                                     rrm_void_t               *p_api)   
{

    /* coverity : CID : 31020,31016,31015,30756 */
    rrm_return_et    ret_val = RRM_SUCCESS;
    rrm_bool_et pe_all_present = RRM_FALSE;
    rrm_bool_et ee_all_present = RRM_FALSE;
    /* coverity : CID : 31020,31016,31015  */
    rrm_bool_et event_ret_val = RRM_TRUE;
    U8 event_class_index = RRM_ZERO; 
    rrmuem_rmif_event_config_req_t  *p_event_config_req = RRM_PNULL;
    rrmuem_rmif_event_config_resp_t  p_event_config_resp = {RRM_ZERO};
    rrm_action_prfmd_et rrm_action = EVENT_ACTION_NONE;

    RRM_UT_TRACE_ENTER();
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->UEM:RRMUEM_RMIF_EVENT_CONFIG_REQ");
    /* CID_17_Apr: 54939 @Indentation corrected */ 
    /* updating global context */
    p_event_config_req = (rrmuem_rmif_event_config_req_t  *)p_api;
    for (event_class_index=RRM_ZERO; 
            ((event_class_index<p_event_config_req->count)&&(event_class_index<RRM_OAM_MAX_SUBCLASS)); 
            ++event_class_index)
    {
        /* event class is protocol event */
        if (RRM_OAM_PROTOCOL_EVENT_TYPE == 
                p_event_config_req->event_config[event_class_index].event_class)
        {
            if ((p_event_config_req->event_config[event_class_index].event_sub_class!=
                        RRM_OAM_INVALID_SUBCLASS) && (pe_all_present != RRM_TRUE))
            { 
                /* coverity : CID : 31020 */ 
                event_ret_val = rrm_fill_protocol_event_subclass_index(p_rrm_glb_ctxt, 
                        p_event_config_req->event_config[event_class_index].event_sub_class,
                        p_event_config_req->event_config[event_class_index].action_reqd);
            }
            else
            {
                rrm_action = rrm_map_rrm_action_performed(p_event_config_req->event_config[event_class_index].action_reqd);
                p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_INDEX]= rrm_action;
                /* Set subclass present & initialise sublass index */ 
                p_rrm_glb_ctxt->event_config.pe_subcls = RRM_FALSE;
                rrm_set_pe_subclass_index(p_rrm_glb_ctxt, rrm_action);

                /* This flag denotes that configuration received 
                   should be applied on all the protocol event */  
                pe_all_present = RRM_TRUE;
            }
        }
        /* event class is error event/alarm */
        else if(RRM_OAM_ERROR_EVENT_TYPE == 
                p_event_config_req->event_config[event_class_index].event_class)
        {
            if ((p_event_config_req->event_config[event_class_index].event_sub_class!=
                        RRM_OAM_INVALID_SUBCLASS) && (ee_all_present != RRM_TRUE))
            {
                rrm_fill_error_event_subclass_index(p_rrm_glb_ctxt,
                        p_event_config_req->event_config[event_class_index].event_sub_class,
                        p_event_config_req->event_config[event_class_index].action_reqd);
            }
            else
            {
                rrm_action_prfmd_et rrm_action = rrm_map_rrm_action_performed(p_event_config_req->event_config[event_class_index].action_reqd);

                p_rrm_glb_ctxt->event_config.action_prfmd[RRM_EE_INDEX]= rrm_action;
                p_rrm_glb_ctxt->event_config.ee_subcls = RRM_FALSE;
                /* Set subclass present & initialise sublass index */
                rrm_set_ee_subclass_index(p_rrm_glb_ctxt, rrm_action);

                /* This flag denotes that configuration received
                   should be applied on all the protocol event */
                ee_all_present = RRM_TRUE;
            }  
        }
        else
        {
            /* coverity : CID : 31020 */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Invalid event class [%d] received from MIF", 
                    p_event_config_req->event_config[event_class_index].event_class);
        }
    }/*for-loop ends*/


    /* Sending resp message to MIF */
    /*Coverity_fix_start_54939*/
    p_event_config_resp.transaction_id = p_event_config_req->transaction_id;
    /*Coverity_fix_end_54939*/ 
    /* coverity : CID : 31020,31016 */
    p_event_config_resp.response = event_ret_val ;
    /*coverity 29032, rel2.0.1, aditya*/
    if(RRM_SUCCESS != rrm_uem_send_internal_msg(RRM_MIF_MODULE_ID,
                RRMUEM_RMIF_EVENT_CONFIG_RESP,
                sizeof(rrmuem_rmif_event_config_resp_t),
                (void *)&p_event_config_resp))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Error in sending internal msg to UEM");
        /* coverity : CID : 31016*/
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Message sent successfully");
        /* coverity : CID : 31015  */
        ret_val = RRM_SUCCESS;

    }
    /*cov_fix_start_54939*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
    /*cov_fix_end_54939*/
}
/* RACH_OPTIMIZATION_CHANGES_START */
/****************************************************************************
 * Function Name  : rrm_uem_handle_rmif_rach_info_ind
 * Inputs		  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 *                : rrm_void_t *p_api :pointer to input API buffer
 * Outputs        : NONE
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes RACH info req from MIF 
 *******************************************************************************/
rrm_return_et
rrm_uem_handle_rmif_rach_info_ind
(
 rrm_ue_global_context_t     *p_rrm_glb_ctxt,
 rrm_void_t *p_api /*Input Api buffer*/
 )
{

    rrm_return_et                     ret_val = RRM_SUCCESS;
    rrmuem_rmif_rach_info_ind_t       *p_rach_info_ind = RRM_PNULL;
    rrm_ue_timer_buf_t                timer_buff;
    rrm_ue_rach_info_list_t           *p_rach_info_list = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->UEM:RRMUEM_RMIF_RACH_INFO_IND");
    p_rach_info_ind =(rrmuem_rmif_rach_info_ind_t *)p_api;

    if(RRM_PNULL != p_rach_info_ind)
    {
        SET_CELL_INDEX(p_rach_info_ind->cell_index);
        p_rrm_glb_ctxt->rrm_uem_rach_info_data.cell_index = 
            p_rach_info_ind->cell_index;
	/*spr_20517_changes_start*/
	/*code deleted*/
	/*spr_20517_changes_end*/

        if(p_rach_info_ind->bitmask & RRM_UE_RACH_SAMPLE_COUNT_PRESENT)
        {
            p_rrm_glb_ctxt->rrm_uem_rach_info_data.rach_sample_count = 
                p_rach_info_ind->rach_sample_count;
        }

        if(p_rach_info_ind->bitmask & RRM_UE_NUM_STRONGEST_CELLS_PRESENT)
        {
            p_rrm_glb_ctxt->rrm_uem_rach_info_data.strong_cell_info_count =
                p_rach_info_ind->num_of_strongest_cells;
        }

        if((p_rach_info_ind->bitmask & RRM_UE_REPORT_PERIODICITY_PRESENT) && 
            (RRM_ZERO != p_rach_info_ind->ue_reports_periodicity) && 
            (RRM_PNULL == g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER]))
        {
            RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name, RRM_DETAILED, 
            "Req is to configure the timer, so starting the UE RACH timer");
            RRM_MEMSET (&timer_buff, 0, sizeof(rrm_ue_timer_buf_t));
            timer_buff.timer_type = RRM_UE_RACH_REPORT_TIMER;
            timer_buff.trans_id = g_uem_gbl_proc.trans_id = RRM_ZERO;
            timer_buff.cell_index = g_uem_gbl_proc.cell_index = p_rach_info_ind->cell_index;
            /* CSR-58333-fix start*/
            g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER] = rrm_ue_start_timer (
                    (p_rach_info_ind->ue_reports_periodicity * 1000),
                    &timer_buff, sizeof(rrm_ue_timer_buf_t), RRM_TRUE);
            /* CSR-58333-fix end*/
            if (g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER] == RRM_PNULL)
            {
                RRM_TRACE(g_uem_log_on_off,
                        p_g_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to start UE RACH REPORT Timer");
                ret_val = RRM_FAILURE;
            }

            /*Setting flag ue report to be TRUE if req is for start report*/
            p_rrm_glb_ctxt->rrm_uem_rach_info_data.is_ue_rach_report_active = RRM_TRUE;
        }
        /*request is to reconfigure timer*/
        else if((p_rach_info_ind->bitmask & RRM_UE_REPORT_PERIODICITY_PRESENT) &&
                (RRM_ZERO != p_rach_info_ind->ue_reports_periodicity) &&
                (p_rach_info_ind->ue_reports_periodicity != p_rrm_glb_ctxt->
                 rrm_uem_rach_info_data.ue_reports_periodicity))
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Reconfiguring the UE rach timer value, \
                    so first stopping the existing timer and then restarting it");

            /* SPR-17852 START */
            if (RRM_PNULL != g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER])
            {
                /* CSR-58333-fix start*/
                rrm_ue_stop_timer (g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER]);
            /* CSR-58333-fix end*/
            g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER] = RRM_PNULL;
            }
              /* SPR-17852 END */

            RRM_MEMSET (&timer_buff, 0, sizeof(rrm_ue_timer_buf_t));
            timer_buff.timer_type = RRM_UE_RACH_REPORT_TIMER;
            timer_buff.trans_id = g_uem_gbl_proc.trans_id = RRM_ZERO;
            timer_buff.cell_index = g_uem_gbl_proc.cell_index = p_rach_info_ind->cell_index;
            /* CSR-58333-fix start*/
            g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER] = rrm_ue_start_timer (
                    (p_rach_info_ind->ue_reports_periodicity * 1000),
                    &timer_buff, sizeof(rrm_ue_timer_buf_t), RRM_TRUE);
            /* CSR-58333-fix end*/
            if (g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER] == RRM_PNULL)
            {
                RRM_TRACE(g_uem_log_on_off,
                        p_g_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to restart UE RACH REPORT Timer");
                ret_val = RRM_FAILURE;
            }

        }
        /* request is to stop reporting and flush all the existing data */
        else
        {
            if(((p_rach_info_ind->bitmask & RRM_UE_REPORT_PERIODICITY_PRESENT) && 
                        (RRM_ZERO == p_rach_info_ind->ue_reports_periodicity)) ||
                    ((p_rach_info_ind->bitmask & RRM_UE_RACH_SAMPLE_COUNT_PRESENT) && 
                     (RRM_ZERO == p_rach_info_ind->rach_sample_count)))
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Stopping the UE rach timer value, stopping the running \
                        timer and flushing the existing data");
                p_rrm_glb_ctxt->rrm_uem_rach_info_data.is_ue_rach_report_active = RRM_FALSE;


            /* SPR-17852 START */
                if (RRM_PNULL != g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER])
                {
                    /* CSR-58333-fix start*/
                    rrm_ue_stop_timer (g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER]);
                /* CSR-58333-fix end*/
                g_uem_gbl_proc.rrm_timer_id[RRM_UE_RACH_REPORT_TIMER] = RRM_PNULL;
                }
                /* SPR-17852 END */

                while (RRM_PNULL != (p_rach_info_list = (rrm_ue_rach_info_list_t *)ylPopTail
                            (&(p_rrm_glb_ctxt->rrm_uem_rach_info_data.rach_report_list))))
                {
                    RRM_MEM_FREE(p_rach_info_list);
                }
            }
        }
	/*spr_20517_changes_start*/
	if(p_rach_info_ind->bitmask & RRM_UE_REPORT_PERIODICITY_PRESENT)
	{
		p_rrm_glb_ctxt->rrm_uem_rach_info_data.ue_reports_periodicity =
			p_rach_info_ind->ue_reports_periodicity;
	}
	/*spr_20517_changes_end*/
    }
    else
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "Context is NULL");
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_END */
/****************************************************************************
 * Function Name  : rrm_uem_handle_rmif_log_enb_dis_req 
 * Inputs		  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 *                : rrm_void_t *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes log enable/disable request 
*******************************************************************************/
rrm_return_et
rrm_uem_handle_rmif_log_enb_dis_req
(
 rrm_ue_global_context_t     *p_rrm_glb_ctxt,
 rrm_void_t *p_api, /*Input Api buffer*/
 U16 api_id /*Incoming Api id*/
         /*SPR 17777 +-*/
 )
{

    rrm_return_et ret_val = RRM_FAILURE;
    U16                     transaction_id = RRM_ZERO;
    rrmuem_rmif_log_enable_disable_req_t *p_init_config = RRM_PNULL;
    rrmuem_rmif_log_enable_disable_res_t *p_resp = RRM_PNULL;
    rrm_void_t *ptr = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->UEM:RRMUEM_RMIF_LOG_ENABLE_DISABLE_REQ");
    p_init_config =(rrmuem_rmif_log_enable_disable_req_t *)p_api;
    
    rrm_uem_log_enable_disable_cmd(p_rrm_glb_ctxt,
           p_init_config->log_on_off,
           p_init_config->log_level);

    transaction_id = p_init_config->transaction_id;
    /* BUG_11576_FIX_START */
    p_resp = rrm_mem_get(sizeof(rrmuem_rmif_log_enable_disable_res_t));
    /* BUG_11576_FIX_END */
    if( RRM_PNULL == p_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return RRM_FAILURE;
    }
    p_resp->transaction_id = transaction_id;
    p_resp->response = RRM_TRUE;
    ptr = (rrm_void_t *)p_resp;
    /*
     * sending response to MIF
     */
    if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                RRMUEM_RMIF_LOG_ENABLE_DISABLE_RES,
                sizeof(rrmuem_rmif_log_enable_disable_res_t),
                ptr))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "send reponse for api:%d",api_id);
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "failure in sending reponse for api:%d",api_id);
        ret_val = RRM_FAILURE;
    }

    /* COVERITY : RESOURCE LEAK : CID : 48272 fix start */
    /* BUG_11576_FIX_START */
    RRM_MEM_FREE(p_resp);
    /* BUG_11576_FIX_END */
    /* COVERITY : RESOURCE LEAK : CID : 48272 fix end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*ECN start*/
/****************************************************************************
 * Function Name  : rrm_ue_send_drb_ecn_ce_req 
 * Inputs		  : RrmPdcpDrbEcnCeReq          *p_pdcp_drb_ecn_req
 *                : U16 src_module_id
 *		          : U16 transaction_id
 *                : U8  cell_index
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Send request to PDCP 
*******************************************************************************/
rrm_return_et 
rrm_ue_send_drb_ecn_ce_req(
 RrmPdcpDrbEcnCeReq          *p_pdcp_drb_ecn_req,
 U16 src_module_id,
 U16 transaction_id,
 U8  cell_index 
)
{

    U16 msg_length     = RRM_ZERO;
    U16 msg_api_length = RRM_ZERO;
    U8 *p_mac_msg = RRM_PNULL;
    U8 *p_msg = RRM_PNULL;

    msg_length = sizeof(RrmPdcpDrbEcnCeReq);
    msg_api_length = msg_length + RRM_API_HEADER_SIZE + RRM_INTERFACE_API_HEADER_SIZE;

    /* Allocate buffer */
    p_msg = rrm_msg_mem_get(msg_api_length);

    if (p_msg == RRM_PNULL)
    {
        /* Not enough memory */
        return RRM_FAILURE;
    }
    p_mac_msg = p_msg;
    RRM_MEMSET(p_mac_msg, RRM_ZERO, msg_api_length);

    /* Fill CSPL header */
    rrm_construct_api_header(p_mac_msg, RRM_VERSION_ID, src_module_id,
            PDCP_MODULE_ID,RRM_PDCP_UE_DRB_ECN_CE_REQ, msg_api_length);

    p_mac_msg= p_mac_msg + RRM_API_HEADER_SIZE;
    /* Fill interface header */
    /*SPR 20856 Start*/
    rrm_construct_interface_api_header(p_mac_msg, transaction_id, src_module_id,
            PDCP_MODULE_ID, RRM_PDCP_UE_DRB_ECN_CE_REQ, msg_length, cell_index);
    /*SPR 20856 End*/
    /* Fill MAC_INIT_LAYER_REQ message */
    p_mac_msg = p_mac_msg + RRM_INTERFACE_API_HEADER_SIZE;

    RRM_MEMCPY(p_mac_msg,p_pdcp_drb_ecn_req,sizeof(RrmPdcpDrbEcnCeReq));

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
            "Src(%u)->Dst(%u):RRM_PDCP_UE_DRB_ECN_CE_REQ", src_module_id, PDCP_MODULE_ID);
    /* Send message to */
    rrm_send_message(p_msg, PDCP_MODULE_ID);
    return RRM_SUCCESS;
}

rrm_return_et 
rrm_uem_redirect_ue(
        rrm_void_t *p_api /*Input Api buffer*/
         /*SPR 17777 +-*/
)
{
   rrmuem_cm_redirect_rel_ind_t *p_redirect_ue = RRM_PNULL;
   rrm_return_et                 ret_val       = RRM_SUCCESS;
   RRM_UT_TRACE_ENTER();

   p_redirect_ue = ( rrmuem_cm_redirect_rel_ind_t*)p_api;
   SET_CELL_AND_UE_INDEX(p_redirect_ue->cell_index, p_redirect_ue->ue_index);
   RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_REDIRECT_REL_IND");
   /* Bug_944_fix */
   ret_val = rrm_redirect_ue_with_release (p_redirect_ue);
   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_uem_unset_ecn_for_all_ue_ind 
 * Inputs		  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 *                : rrm_void_t *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : as UEM has recieved all ECN unset for all. It shall send the 
 *                : PDCP_ECN_ECN_REQ for all ue which is having congestion status as TRUE
*******************************************************************************/
rrm_return_et 
rrm_uem_unset_ecn_for_all_ue_ind(
        rrm_void_t *p_api/*Input Api buffer*/
         /*SPR 17777 +-*/
)
{
    U8 index = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmuem_cm_unset_for_all_ue_ind_t *p_unset_ecb_for_all_ue = RRM_PNULL;
    RrmPdcpDrbEcnCeReq          pdcp_drb_ecn_req = {RRM_ZERO};
    
    RRM_UT_TRACE_ENTER();
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* SPR 20652 Fix End */

    p_unset_ecb_for_all_ue = (rrmuem_cm_unset_for_all_ue_ind_t *)p_api;
    SET_CELL_INDEX(p_unset_ecb_for_all_ue->cell_index);
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_UNSET_ECN_FOR_ALL_UE_IND");
    /* SPR 20652 Fix Start */
    rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, p_unset_ecb_for_all_ue->cell_index);
    if (RRM_PNULL == p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"UE context not found");
        return ret_val;
    }	
    while(p_ue_context != RRM_PNULL)
    {
        if(p_ue_context->cell_index == p_unset_ecb_for_all_ue->cell_index)
        {
            /*check that congestion is true for this UE. if yes, send req to PDCP to mark it as false*/
            if(p_ue_context->ecn_supported == RRM_TRUE)
            {
                for(index = RRM_ZERO;index <RRM_MAX_NUM_DRB_PER_UE;index++)
                {
                    if(RRM_ZERO != p_ue_context->drb_configured.erab_item[index].direction_of_congestion)
                    {
                        pdcp_drb_ecn_req.ueIndex = p_ue_context->ue_index;
                        pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].lcId= 
                            p_ue_context->drb_configured.erab_item[index].lc_id;
			/* SPR 19580 Changes Start */
                        pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].direction= 
                        rrm_fill_dir_of_congestion_ecn(p_ue_context->drb_configured.erab_item[index].direction_of_congestion);
			/* SPR 19580 Changes End */
                        pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].congestionStatus= RRM_FALSE;
                        pdcp_drb_ecn_req.numOfLc++;
        		/* SPR 18891 fix start */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "[UE:%d] lc_id :%d  direction:%d congestion status:%d",
                        pdcp_drb_ecn_req.ueIndex,
                        pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].lcId,
                        pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].direction,
                        pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].congestionStatus);
        		/* SPR 18891 fix stop */
                        /*Setting the congestion flag as false*/
                    }
                }
                ret_val = rrm_ue_send_drb_ecn_ce_req(&pdcp_drb_ecn_req, RRM_MODULE_ID,RRM_ZERO, p_ue_context->cell_index);
                RRM_MEMSET(&pdcp_drb_ecn_req, RRM_ZERO, sizeof(RrmPdcpDrbEcnCeReq));
            }
       }
       ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, p_unset_ecb_for_all_ue->cell_index);
    /* SPR 20652 Fix End */
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*ECN end*/

/****************************************************************************
 * Function Name  : rrm_uem_handle_cm_set_unset_ecn_bit_req 
 * Inputs		  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 *                : rrm_void_t *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : It shall send the 
 *                : PDCP_ECN_ECN_REQ for UE which is having congestion status as TRUE
 **********************************************************************************/
rrm_return_et
rrm_uem_handle_cm_set_unset_ecn_bit_req(
        rrm_void_t *p_api /*Input Api buffer*/
         /*SPR 17777 +-*/
)
{

    rrm_return_et ret_val = RRM_FAILURE;
    rrmuem_cm_ecn_set_unset_ind_t *p_cellm_ue_set_unset_bit = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    RrmPdcpDrbEcnCeReq            pdcp_drb_ecn_req = {RRM_ZERO};
    rrm_ue_context_t              *p_ue_context= RRM_PNULL;
    U8 ecn_bitset_list = RRM_ZERO;
    U8 drb_configured = RRM_ZERO;
    rrm_bool_et pdcp_ce_msg_send = RRM_FALSE;
    U8 prev_ecn_status                  =   RRM_ZERO;
    U8 num_ue_on_ecn = RRM_ZERO;
    U8 num_ue_to_apply_ecn = RRM_ZERO;
    U8 num_actv_ue = RRM_ZERO;
    rrm_bool_et flag_to_set_ecn = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    p_cellm_ue_set_unset_bit = (rrmuem_cm_ecn_set_unset_ind_t *)p_api;
    SET_CELL_AND_UE_INDEX(p_cellm_ue_set_unset_bit->cell_index, p_cellm_ue_set_unset_bit->ue_index);
    
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_SET_UNSET_ECN_IND");
    /*Find ue_context*/
    /* SPR 20652 Fix Start */
    p_ue_context = rrm_ue_find_context(p_cellm_ue_set_unset_bit->ue_index,
            p_cellm_ue_set_unset_bit->cell_index); 
    if (p_ue_context != RRM_PNULL)
    {
    /* SPR 20652 Fix End */
        /*First chechk that whether this UE support ECN or not*/ 
        if(p_ue_context->ecn_supported == RRM_TRUE)
        {
            /*Fill the message for PDCP */
            /* SPR 18891 fix start */
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"[UE:%d] support ECN:%d",
                    p_cellm_ue_set_unset_bit->ue_index,
                    p_ue_context->ecn_supported);
            /* SPR 18891 fix stop */
            pdcp_drb_ecn_req.ueIndex = p_cellm_ue_set_unset_bit->ue_index;
            for(ecn_bitset_list = RRM_ZERO;ecn_bitset_list <p_cellm_ue_set_unset_bit->count;ecn_bitset_list++ )
            { 
                for(drb_configured = RRM_ZERO;drb_configured < p_ue_context->drb_configured.num_of_list; drb_configured++)
                {
                    /*Find the lc_id list for a particular qci*/
                    if (p_ue_context->drb_configured.erab_item[drb_configured].erab_level_qos_params.qci == 
                        p_cellm_ue_set_unset_bit->ue_qci_list[ecn_bitset_list].qci)
                    {
                        /*Check the ecn bit status for lc_id is changed from earlier report or not
                         *If changed then no need to send the PDCP_ECN_REQ for particular lc_id
                         */
                        prev_ecn_status = p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion;
                        if (RRM_TRUE == p_cellm_ue_set_unset_bit->ue_qci_list[ecn_bitset_list].congestion_status) 
                        {
                            switch (p_cellm_ue_set_unset_bit->ue_qci_list[ecn_bitset_list].direction)
                            {
                                case ECN_APPLIED_IN_BOTH_UL_DL:
                                    p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion |= ECN_UL_BIT_PRESENT;
                                    p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion |= ECN_DL_BIT_PRESENT;
                                    break;

                                case ECN_APPLIED_IN_UL:
                                    p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion |= ECN_UL_BIT_PRESENT;
                                    break;

                                case ECN_APPLIED_IN_DL:
                                    p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion |= ECN_DL_BIT_PRESENT;
                                    break;

                                default:
                                    break;
                            }

                        }
                        else
                        {
                            switch (p_cellm_ue_set_unset_bit->ue_qci_list[ecn_bitset_list].direction)
                            {
                                case ECN_APPLIED_IN_BOTH_UL_DL:
                                    p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion &= ~ECN_UL_BIT_PRESENT;
                                    p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion &= ~ECN_DL_BIT_PRESENT;
                                    break;

                                case ECN_APPLIED_IN_UL:
                                    p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion &= ~ECN_UL_BIT_PRESENT;
                                    break;

                                case ECN_APPLIED_IN_DL:
                                    p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion &= ~ECN_DL_BIT_PRESENT;
                                    break;

                                default:
                                    break;
                            }
                        }

                        if (prev_ecn_status != p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion)
                        {
                            /*Filling the information for PDCP*/
                            pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].lcId= 
                                p_ue_context->drb_configured.erab_item[drb_configured].lc_id;
				/* SPR 19580 Changes Start */
                            pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].direction=
                               rrm_fill_dir_of_congestion_ecn(p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion);
				/* SPR 19580 Changes End */
                            pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].congestionStatus= 
                                p_cellm_ue_set_unset_bit->ue_qci_list[ecn_bitset_list].congestion_status;
                            /* SPR 18891 fix start */
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "[UE:%d] lc_id :%d  direction:%d congestion status:%d",
                                    pdcp_drb_ecn_req.ueIndex,
                                    pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].lcId,
                                    pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].direction,
                                    pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].congestionStatus);  
			    /* SPR 18891 fix stop */ 
                            pdcp_drb_ecn_req.numOfLc++;
                            pdcp_ce_msg_send = RRM_TRUE;
                            if (RRM_ZERO != p_ue_context->drb_configured.erab_item[drb_configured].direction_of_congestion)
                            {
                                flag_to_set_ecn = RRM_TRUE;
                            }
                        }
                    }
                }
            }

            if (RRM_TRUE == pdcp_ce_msg_send)
            {
                num_ue_on_ecn = rrm_cellm_get_num_ue_on_ecn(p_cellm_ue_set_unset_bit->cell_index);
                num_ue_to_apply_ecn = rrm_cellm_num_ue_to_apply_ecn(p_cellm_ue_set_unset_bit->cell_index);
                num_actv_ue = rrm_cellm_get_num_active_ue(p_cellm_ue_set_unset_bit->cell_index); 
                /* SPR 18891 fix start */ 
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "num_ue_on_ecn:%d\n num_ue_to_apply_ecn :%d\n num_actv_ue:%d\n",
                        num_ue_on_ecn,num_ue_to_apply_ecn,num_actv_ue);
	        /* SPR 18891 fix stop */ 
                if (RRM_TRUE == p_ue_context->ecn_applied)
                {
                    /*send to pdcp */
                    ret_val = rrm_ue_send_drb_ecn_ce_req(&pdcp_drb_ecn_req, RRM_MODULE_ID,RRM_ZERO, p_ue_context->cell_index);
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            "pdcp_drb_ecn_req send for [UE:%d]",pdcp_drb_ecn_req.ueIndex);
                }
                else if(RRM_ZERO == num_ue_to_apply_ecn)
                {
                    if (RRM_SUCCESS != (ret_val = rrm_ue_send_drb_ecn_ce_req(&pdcp_drb_ecn_req, RRM_MODULE_ID,RRM_ZERO, p_ue_context->cell_index)))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "Failed to send pdcp_drb_ecn_req for [UE:%d]",pdcp_drb_ecn_req.ueIndex);
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "pdcp_drb_ecn_req send for [UE:%d]",pdcp_drb_ecn_req.ueIndex);
                    }
                }
                else if((num_ue_on_ecn < num_ue_to_apply_ecn) && (num_ue_on_ecn < num_actv_ue))
                {
                    /*send to pdcp */
                    if (RRM_SUCCESS != (ret_val = rrm_ue_send_drb_ecn_ce_req(&pdcp_drb_ecn_req, RRM_MODULE_ID,RRM_ZERO, p_ue_context->cell_index)))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Failed to send pdcp_drb_ecn_req for [UE:%d]",pdcp_drb_ecn_req.ueIndex);
                    }
                    else
                    {
                        rrm_cellm_increment_ecn_ue(p_cellm_ue_set_unset_bit->cell_index);
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,"pdcp_drb_ecn_req send for [UE:%d]",pdcp_drb_ecn_req.ueIndex);
                        p_ue_context->ecn_applied = RRM_TRUE;
                    }
                }

                if (RRM_TRUE != flag_to_set_ecn)
                {
                    p_ue_context->ecn_applied = RRM_FALSE;
                }
            }

        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "[UE:%d] context not found", p_cellm_ue_set_unset_bit->ue_index);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_uem_handle_cm_delete_all_ue_context_req 
 * Inputs    	  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 *                : rrm_void_t *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes delete all ue context from cellm 
 ****************************************************************************/

rrm_return_et
rrm_uem_handle_cm_delete_all_ue_context_req(
        rrm_ue_global_context_t     *p_rrm_glb_ctxt,
        rrm_void_t *p_api /*Input Api buffer*/
         /*SPR 17777 +-*/
        )
{
#ifdef RRM_UT_FLAG
    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.delete_all_ue_req);
#endif                
    rrm_return_et ret_val = RRM_FAILURE;
    rrmuem_cm_delete_all_ue_context_req_t *p_delete_all_ue_context_req = 
        RRM_PNULL;
    rrmuem_cm_delete_all_ue_context_res_t *p_resp = RRM_PNULL;

    /* bug_14007_start */
    /* eICIC_PHASE_1_2_CHANGES_START */
    rrm_cell_context_t            *p_cell_context = RRM_NULL;
    /* eICIC_PHASE_1_2_CHANGES_END */
    /* bug_14007_end */

    RRM_UT_TRACE_ENTER();
    p_delete_all_ue_context_req =
        (rrmuem_cm_delete_all_ue_context_req_t*)p_api;

    SET_CELL_INDEX(p_delete_all_ue_context_req->cell_index);
    /* eICIC_PHASE_1_2_CHANGES_START */

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_DELETE_ALL_UE_CONTEXT_REQ");
    
    /* bug_14007_start */
    p_cell_context = rrm_cellm_get_cell_context(p_delete_all_ue_context_req->cell_index);
    /* cov 69662 fix */
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        return RRM_FAILURE;
    }

    if( p_cell_context->operator_info.eicic_info.eicic_provisioned_type & RRM_OAM_ACT_AS_VICTIM ||
            p_cell_context->operator_info.eicic_info.eicic_provisioned_type & RRM_OAM_ACT_AS_AGGRESSOR_AND_VICTIM)
    {
        /* SPR 14960 start */
        rrm_uem_flush_victim_and_aggressor_node(p_rrm_glb_ctxt); 
        /* SPR 14960 end */
    }
    /* bug_14007_end */
    /* eICIC_PHASE_1_2_CHANGES_END */

    ret_val = rrm_uem_delete_all_ue_context(
            p_delete_all_ue_context_req->cell_index);
    /* BUG_11576_FIX_START */
    p_resp = rrm_mem_get(sizeof(rrmuem_cm_delete_all_ue_context_res_t));
    /* BUG_11576_FIX_END */
    if( RRM_PNULL == p_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return RRM_FAILURE;
    }
    /* Start fix for SPR 285 */
    p_resp->cell_index = p_delete_all_ue_context_req->cell_index;
    /* End fix for SPR 285 */
    p_resp->transaction_id = p_delete_all_ue_context_req->transaction_id;
    /*coverity 13580, rel2.0.1, aditya, typecasted to rrm_bool_et*/
    if(RRM_SUCCESS == ret_val)
    {
	p_resp->response = RRM_TRUE;
    }
    else
    {
	p_resp->response = RRM_FALSE;
    }

    if(RRM_FAILURE == rrm_uem_send_internal_msg(
            RRM_CM_MODULE_ID,
            RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP,
            sizeof(rrmuem_cm_delete_all_ue_context_res_t),
           (rrm_void_t *)p_resp))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "RRM send to MIF failed");
    }

    /* COVERITY : RESOURCE LEAK : CID : 48271 fix start */
    /* BUG_11576_FIX_START */
    RRM_MEM_FREE(p_resp);
    /* BUG_11576_FIX_END */
    /* COVERITY : RESOURCE LEAK : CID : 48271 fix end */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_mgr_rrm_if_msg_handler
 *   DESCRIPTION:
 *       Handles the incoming messages, received from RRM_IF.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_mgr_rrm_if_msg_handler (
        rrm_void_t *p_api_buf,
        rrm_void_t *p_gl_ctx
        )
{
    rrm_ue_global_context_t     *p_rrm_glb_ctxt = RRM_PNULL;
    rrm_return_et 				ret_val = RRM_SUCCESS;
    U16							api_id = RRM_NULL;
         /*SPR 17777 +-*/
    RRM_UT_TRACE_ENTER();

    p_rrm_glb_ctxt = (rrm_ue_global_context_t *)p_gl_ctx;
    api_id   = rrm_get_word_from_header((U8*)(p_api_buf) + STACK_API_API_OFFSET);
         /*SPR 17777 +-*/
    p_api_buf = p_api_buf + RRM_API_HEADER_SIZE; 

    switch(api_id)
    {
        case RRMUEM_RMIF_INIT_CONFIG_REQ:
            ret_val = rrm_uem_handle_rmif_init_config_req(p_api_buf, 
                    p_rrm_glb_ctxt);
            break;

        case RRMUEM_RMIF_LOG_ENABLE_DISABLE_REQ:
         /*SPR 17777 +-*/
            ret_val = rrm_uem_handle_rmif_log_enb_dis_req(p_rrm_glb_ctxt, 
                    p_api_buf, api_id);
            break;

        case RRMUEM_RMIF_SET_LOG_LEVEL_REQ:
            ret_val = rrm_uem_handle_rmif_set_log_level_req(p_rrm_glb_ctxt, 
                    p_api_buf);
            break;
            /* SPR_13117_FIX_START */
        case RRMUEM_RMIF_GET_LOG_LEVEL_REQ:
            ret_val = rrm_uem_handle_rmif_get_log_level_req(p_rrm_glb_ctxt,
                    p_api_buf);
         /*SPR 17777 +-*/
            break;

            /* SPR_13117_FIX_END */

        case RRMUEM_RMIF_EMERGENCY_CALL_ACTIVE_REQ:
            ret_val = rrm_uem_handle_rmif_emergency_call_active_req(p_api_buf);
         /*SPR 17777 +-*/
            break;
   /*UE REL FROM OAM */
    
       case RRMUEM_RMIF_UE_REL_REQ:
            ret_val = rrm_uem_handle_rmif_ue_release_from_oam_req(p_api_buf );
       break ;
       
            /* Soft Lock Feature */
       
       case RRMUEM_RMIF_RELEASE_ALL_EXISTING_UE_FORCEFULLY_REQ:
            ret_val = rrm_uem_handle_rmif_release_all_existing_ue_forcefully_req (p_api_buf);
            break;
            
       case RRMUEM_RMIF_NON_EMRGNCY_ACTIVE_CALLS_HO_REQ:
            ret_val = rrm_uem_handle_rmif_non_emrgncy_active_calls_ho_req (p_api_buf);
            break;
       /*Event Config Req Start*/
       case RRMUEM_RMIF_EVENT_CONFIG_REQ:
            ret_val = rrm_uem_handle_rmif_event_config_req(p_rrm_glb_ctxt, p_api_buf);
            break;
       /*Event Config Req End*/

       /* RACH_OPTIMIZATION_CHANGES_START */
       case RRMUEM_RMIF_RACH_INFO_IND:
            ret_val = rrm_uem_handle_rmif_rach_info_ind(p_rrm_glb_ctxt, p_api_buf);
            break;
       /* RACH_OPTIMIZATION_CHANGES_END */

       default:
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
rrm_return_et 
rrm_uem_handle_pdcp_ue_drb_ecn_ce_req
(
         /*SPR 17777 +-*/
 rrm_void_t *p_api, /*Input Api buffer*/
         /*SPR 17777 +-*/
 U8  cell_index
)
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    RrmPdcpDrbEcnCeInd *p_pdcp_drb_ind = RRM_PNULL;

   RRM_UT_TRACE_ENTER();
   
   
   p_pdcp_drb_ind= (RrmPdcpDrbEcnCeInd *)p_api;
   /*0 = Congestion set in IP packet
    1 = Congestion could not be set in IP packet
   */
   SET_UE_INDEX(p_pdcp_drb_ind->ueIndex);
   RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"PDCP->RRM:RRM_PDCP_UE_DRB_ECN_CE_IND [UE:%d]", p_pdcp_drb_ind->ueIndex);
   if(p_pdcp_drb_ind->congestionStatus == RRM_TRUE)
   {
       /*Block the UE for ECN. No Further ECN request should be send for this UE*/
        if(cell_index < RRM_MAX_NUM_CELLS)
        {
            /* SPR 20652 Fix Start */
            p_ue_context = rrm_ue_find_context(p_pdcp_drb_ind->ueIndex, cell_index); 
            if (p_ue_context != RRM_PNULL)
            {
                /*Set the Flag. So that in future no PDCP_ECN_DRB_CE_REQ send to PDCP
                  As the UE doesn't support ECN functoinalty
                  */
                p_ue_context->ecn_supported = RRM_FALSE;
                /* SPR 20652 Fix End */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                        " ECN not supported for UE:%d" ,p_pdcp_drb_ind->ueIndex);
            }
            else
            {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                "[UE:%d] context not found", p_pdcp_drb_ind->ueIndex);
            }
        }
        else
        {
             RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                       "Invalid cell index :%d" ,cell_index);
             ret_val = RRM_FAILURE;
        }
   }
   RRM_UT_TRACE_EXIT();
   return ret_val;
}

/********************************************************************LSE*****
 *   FUNCTION NAME: rrm_ue_mgr_pdcp_msg_handler 
 *   DESCRIPTION:
 *       Handles the incoming messages, received from PDCP.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_mgr_pdcp_msg_handler(
        rrm_void_t *p_api_buf
         /*SPR 17777 +-*/
)
{
    rrm_return_et 				ret_val = RRM_SUCCESS;
    U16							api_id = RRM_NULL;
    U16							msg_size = RRM_NULL;
    U8   cell_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

         /*SPR 17777 +-*/
    api_id   = rrm_get_word_from_header((U8*)(p_api_buf) + RRM_CSPL_API_ID_INDEX/*5*/);
    p_api_buf = (U8*)p_api_buf + RRM_API_HEADER_SIZE;
    msg_size = rrm_get_word_from_header((U8*)(p_api_buf) +RRM_INTF_MSG_ID_INDEX/*8*/);
/*BUG 585 FIX START*/
    cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
    SET_CELL_INDEX(cell_index);
    msg_size = msg_size - RRM_INTERFACE_API_HEADER_SIZE;
    p_api_buf  = p_api_buf + RRM_INTERFACE_API_HEADER_SIZE;

    switch(api_id)
    {
        case RRM_PDCP_UE_DRB_ECN_CE_CNF:
                /*Chechk the confirmation recievd from PDCP*/
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"PDCP->RRM:RRM_PDCP_UE_DRB_ECN_CE_CNF");
            break;
        case RRM_PDCP_UE_DRB_ECN_CE_IND:
            /*SPR 17777 +-*/
            ret_val = rrm_uem_handle_pdcp_ue_drb_ecn_ce_req(p_api_buf,cell_index);
            break;
        default:
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                    "Invalid API %u is received", api_id);
            break;
    }
   RRM_UT_TRACE_EXIT(); 
   return ret_val;
}

/* Carrier Aggregation start */

/******************************************************************************
 *   FUNCTION NAME: rrm_function_check_empty_tb_block    
 *   DESCRIPTION:
 *       process mac ue reconfig cnf api  
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
S16  rrm_function_check_empty_tb_block( void )
{
    S16  index = RRM_MINUS_ONE ;
    U8   i = RRM_ZERO;
    rrm_ue_global_context_t   *p_rrm_glb_ctxt = (rrm_ue_global_context_t *)qvThisContext();

    if( RRM_NULL != p_rrm_glb_ctxt )
    for(  i  = RRM_ZERO ; i < RRM_FIFTY ; i++ )
    {
	  if( RRM_MINUS_ONE == p_rrm_glb_ctxt->tb_block[i].transaction_id  )
	  {
                index = i;
		break;
	  }
    }
   
    return index;
}



/******************************************************************************
 *   FUNCTION NAME: rrm_maintain_transaction_block    
 *   DESCRIPTION:
 *       process mac ue reconfig cnf api  
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
/* BUG_11907_FIX_START */
S16 rrm_maintain_transaction_block( register_handler handler, rrm_void_t *p_data)
/* BUG_11907_FIX_END */
{
    RRM_UT_TRACE_ENTER();

    rrm_ue_global_context_t   *p_rrm_glb_ctxt = (rrm_ue_global_context_t *)qvThisContext();
    S16                        transaction_id = rrm_function_check_empty_tb_block();

    if( RRM_NULL != p_rrm_glb_ctxt )
    {
	if( RRM_MINUS_ONE != transaction_id )
    {
        p_rrm_glb_ctxt->tb_block[transaction_id].handler = handler;
        p_rrm_glb_ctxt->tb_block[transaction_id].transaction_id = (transaction_id + RRM_FIFTY);
        /* BUG_11907_FIX_START */
        p_rrm_glb_ctxt->tb_block[transaction_id].p_data= p_data;
        /* BUG_11907_FIX_END */

        transaction_id = (transaction_id + RRM_FIFTY);
    }
	else
	{
	    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR , \
	    "Invalid Transaction ID[%d] is received ", RRM_MINUS_ONE);
	}
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR , \
	"NULL pointer retrieved for p_rrm_glb_ctxt ");
    }

    RRM_UT_TRACE_EXIT();
    
    return transaction_id;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_invoke_tb_handler    
 *   DESCRIPTION:
 *       process mac ue reconfig cnf api  
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
void rrm_invoke_tb_handler(S16  transaction_id ,rrm_cell_index_t cell_index, void  *p_api)
{
    rrm_return_et            ret_val = RRM_SUCCESS;
    U32 idx = RRM_ZERO;
    rrm_ue_global_context_t   *p_rrm_glb_ctxt = (rrm_ue_global_context_t *)qvThisContext(); 
    RRM_UT_TRACE_ENTER();
    /* CID : 61030 */
    if( RRM_NULL != p_rrm_glb_ctxt )
    {
	if( (transaction_id >= RRM_FIFTY) && ( transaction_id < RRM_HUNDRED) )
	{
        idx = transaction_id % RRM_FIFTY;
	   if( RRM_MINUS_ONE != p_rrm_glb_ctxt->tb_block[idx].transaction_id )
	   {
	       if( p_rrm_glb_ctxt->tb_block[idx].handler )
	       {
           /* BUG_11907_FIX_START */
		   ret_val = p_rrm_glb_ctxt->tb_block[idx].
					    handler(cell_index ,(void*) p_api, (void*)p_rrm_glb_ctxt, (void*)p_rrm_glb_ctxt->tb_block[idx].p_data );
          /* BUG_11907_FIX_END */
		   if( RRM_SUCCESS == ret_val )
		   {
		       RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
		       "Success returned from registered handler for MAC UE RECONFIG CNF");
		   }
		   else
		   {
		       RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
		       "Failure returned from registered handler for MAC UE RECONFIG CNF");
		   }
	       }
	       /* resetting the tb block's transaction id with -1 and handler with NULL 
		  deregistering the handler and empty the transaction id */
	       p_rrm_glb_ctxt->tb_block[idx].transaction_id = RRM_MINUS_ONE ;
	       p_rrm_glb_ctxt->tb_block[idx].handler = RRM_NULL;
	       p_rrm_glb_ctxt->tb_block[idx].p_data= RRM_PNULL;
	   }
	   else
	   {
	       RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR , \
	       "No Handler is registered for this transaction ID ");
	   }
	}
	else
	{
	    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR , \
	    "Invalid Transaction ID[%d] is received ", transaction_id);
	}
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR , \
        "NULL pointer retrieved for p_rrm_glb_ctxt ");
    }

    RRM_UT_TRACE_EXIT();
}



/******************************************************************************
 *   FUNCTION NAME: rrm_pick_relative_scell_index_of_actual_scell_index    
 *   DESCRIPTION:
 *       process mac ue reconfig cnf api  
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/

U8 rrm_pick_relative_scell_index_of_actual_scell_index( rrm_ue_context_t   *p_ue_context,
                                                        rrm_cell_index_t    scell_index,
                                                        U8                 *scell_array_index )
{

    U8     index = RRM_ZERO;
    U8     relative_scell_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    for( index = RRM_ZERO; (index < p_ue_context->ue_scell_add_params.count) && 
                           (index < RRM_MAX_SCELL ) ; index++ )
    {

        if( (U8)scell_index == p_ue_context->ue_scell_add_params.
                               rrm_scell_info_for_ue[index].scell_cell_index )
        {
            relative_scell_index = p_ue_context->ue_scell_add_params.
                                   rrm_scell_info_for_ue[index].scell_index;
            *scell_array_index = index;
            break;
        }
    }

    RRM_UT_TRACE_EXIT();

    return relative_scell_index;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_set_scell_info_state_active     
 *   DESCRIPTION:
 *       function set the state active  
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/

rrm_void_t  rrm_set_scell_info_state_active( rrm_ue_context_t  *p_ue_context,
                                             U8                 scell_array_index )
                                       
{
    RRM_UT_TRACE_ENTER();

    if( (scell_array_index < p_ue_context->ue_scell_add_params.count ) && 
                   ( scell_array_index < RRM_MAX_SCELL ))
    {
        /* mark scell activate : RRM_TRUE */
        if (SCELL_DEACTIVE_FOR_MEASUREMENT != p_ue_context->ue_scell_add_params.
                rrm_scell_info_for_ue[scell_array_index].scell_state)
        {

            p_ue_context->ue_scell_add_params.
                rrm_scell_info_for_ue[scell_array_index].scell_state = SCELL_ACTIVE;
        }
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED , \
        " [UE:%d], scell_array_index [%d], scell active state [%d]",p_ue_context->ue_index,
        scell_array_index, p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_array_index].scell_state );
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR , \
        "Invalid scell array index[%d] is passed ", scell_array_index);
    }

    RRM_UT_TRACE_EXIT();

}



/******************************************************************************
 *   FUNCTION NAME: rrm_set_scell_info_state_deactive     
 *   DESCRIPTION:
 *       function set the scell state deactive   
 *   RETURNS:
 *       rrm_void_t
 ******************************************************************************/

rrm_void_t  rrm_set_scell_info_state_deactive( rrm_ue_context_t  *p_ue_context,
                                               U8                 scell_array_index )
                                       
{
    RRM_UT_TRACE_ENTER();

    if( (scell_array_index < p_ue_context->ue_scell_add_params.count ) && 
                   ( scell_array_index < RRM_MAX_SCELL ))
    {
        /* mark scell deactivate : RRM_FALSE */
        if (SCELL_DEACTIVE_FOR_MEASUREMENT != p_ue_context->ue_scell_add_params.
                rrm_scell_info_for_ue[scell_array_index].scell_state)
        {
            p_ue_context->ue_scell_add_params.
                rrm_scell_info_for_ue[scell_array_index].scell_state = SCELL_DEACTIVE;
        }

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED , \
        " [UE:%d], scell_array_index [%d], scell deactive state [%d]",p_ue_context->ue_index,
        scell_array_index, p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_array_index].scell_state );
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR , \
        "Invalid scell array index[%d] is passed ", scell_array_index);
    }

    RRM_UT_TRACE_EXIT();
}



/******************************************************************************
 *   FUNCTION NAME: rrm_ue_scell_state_backp     
 *   DESCRIPTION:
 *       function takes the backup of scell state  
 *   RETURNS:
 *       rrm_void_t
 ******************************************************************************/

rrm_void_t rrm_ue_scell_state_backp( rrm_ue_context_t   *p_ue_context)
{

    U8        index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    for( index = RRM_ZERO ;( (index < p_ue_context->ue_scell_add_params.count ) && 
                            (index < RRM_MAX_SCELL) ); index++ )
    {
        /* back up of scell state*/
        p_ue_context->ue_scell_add_params.
        rrm_scell_state_backup[index].scell_state = 
        p_ue_context->ue_scell_add_params.
        rrm_scell_info_for_ue[index].scell_state ;

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED , \
        " [UE:%d], scell_array_index [%d], scell bckp state [%d] ",p_ue_context->ue_index,
        index, p_ue_context->ue_scell_add_params.rrm_scell_state_backup[index].scell_state); 
    }

    RRM_UT_TRACE_EXIT();
}




/******************************************************************************
 *   FUNCTION NAME: rrm_revert_ue_scell_state_info     
 *   DESCRIPTION:
 *       revert the ue scell state   
 *   RETURNS:
 *       rrm_void_t
 ******************************************************************************/

rrm_void_t rrm_revert_ue_scell_state_info( rrm_ue_context_t  *p_ue_context )
{

    U8  index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    for( index = RRM_ZERO; (index < p_ue_context->ue_scell_add_params.count) && 
                           ( index < RRM_MAX_SCELL ) ; index++ )
    {

        p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_state =
        p_ue_context->ue_scell_add_params.rrm_scell_state_backup[index].scell_state;

    }
    RRM_UT_TRACE_EXIT();

}


/******************************************************************************
 *   FUNCTION NAME: rrm_set_state_scell_state     
 *   DESCRIPTION:
 *       set the state of scell    
 *   RETURNS:
 *       rrm_void_t
 ******************************************************************************/

rrm_void_t rrm_set_state_scell_state( rrm_ue_context_t    *p_ue_context,
                                      U8                  scell_array_index,
                                      rrm_ue_scell_state_et state )
{
    RRM_UT_TRACE_ENTER();

    /* First take the backup of sate of scell using array index
       this index is neither scell index nor actual cell_index */
    rrm_ue_scell_state_backp( p_ue_context);
 
    /* set the active  state of scell*/ 
    if( SCELL_ACTIVE == state )
    {
        rrm_set_scell_info_state_active( p_ue_context ,
                                         scell_array_index );
    }
    else
    {
       /* set the deactive  state of scell*/ 
        rrm_set_scell_info_state_deactive( p_ue_context ,
                                         scell_array_index );
    }

    RRM_UT_TRACE_EXIT();
}




/******************************************************************************
 *   FUNCTION NAME: rrm_was_any_scell_activated_for_ue      
 *   DESCRIPTION:
 *       function return true if any of added scell is acticated   
 *   RETURNS:
 *       RRM_TRUE on Success
 *       RRM_FALSE on Failure
 ******************************************************************************/
/*Note: rrm_scenario_flag will be TRUE in HO scenario & hence the Scell State 
 *      should be read from backup structure.
 *      rrm_scenario_flag will be FALSE in re-estab scenario & hence the Scell State
 *      should be read from rrm_scell_info_for_ue structure 
 */
rrm_bool_et
rrm_was_any_scell_activated_for_ue( const rrm_ue_context_t    *p_ue_context,
                                    rrm_bool_et                rrm_scenario_flag)
{
    rrm_bool_et    was_activated = RRM_FALSE;
    U8             scell_count_on_ue = RRM_ZERO;
    U8             index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();


    /* this handling is required to reactivate the scell when it seems
       at any point of time to reactivate the scell which is recently
       deactivated on MAC
       So this function will check on back up date of scell which 
       we store before sendding configuration to mac  */

    /* Shariq code dependency */
    scell_count_on_ue = p_ue_context->ue_scell_add_params.count;

    for( index = RRM_ZERO; ( index < scell_count_on_ue ) &&
                           ( index < RRM_MAX_SCELL); index++ )
    {
        if(rrm_scenario_flag == RRM_TRUE)
        {
        if( SCELL_ACTIVE == p_ue_context->ue_scell_add_params.rrm_scell_state_backup[index].scell_state )
        {
            was_activated = RRM_TRUE;
            break;
        }
    }
        else
        {
            if( SCELL_ACTIVE == p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_state )
            {
                was_activated = RRM_TRUE;
                break;
            }

        }
    }

    RRM_UT_TRACE_EXIT();

    return was_activated ; 
}




/******************************************************************************
 *   FUNCTION NAME: rrm_mac_ue_reconfig_scell_reactivation_on_ho_out_failure     
 *   DESCRIPTION:
 *       function reactivate the scell on ho failure   
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_mac_ue_reconfig_scell_reactivation_on_ho_out_failure( rrm_ue_context_t    *p_ue_context,
                                                          rrm_bool_et          rrm_scenario_flag)
{
    U8                             index = RRM_ZERO;
    U8                             deact_scell_count_to_reactivate = RRM_ZERO;
    S16                            transaction_id = RRM_ZERO;
    RrmMacUeReconfigReq     *p_mac_ue_reconfig_req = RRM_NULL;
 
    RRM_UT_TRACE_ENTER();

    if(  RRM_NULL != p_ue_context )
    {
        // allocate the memory 
        p_mac_ue_reconfig_req = (RrmMacUeReconfigReq*)rrm_mem_get(sizeof(RrmMacUeReconfigReq));

        if( RRM_NULL != p_mac_ue_reconfig_req )
        {
            /* rrm_revert the scell state info */
            if(rrm_scenario_flag)
            rrm_revert_ue_scell_state_info( p_ue_context );

            p_mac_ue_reconfig_req->bitmask = UE_CA_CONFIG_INFO_LIST_RECONFIG_BIT;

	    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.numOfUE = RRM_ONE;

            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
            ueScellSchedulingInfo[RRM_ZERO].ueIndex = p_ue_context->ue_index;

	    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
	    " numOfUE [%d] , [UE:%d] ", p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.numOfUE,
            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].ueIndex );

            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
            ueScellSchedulingInfo[RRM_ZERO].isMACCESendToUE = RRM_ONE;

            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
            ueScellSchedulingInfo[RRM_ZERO].numOfScellsSchedulingNotAllowed  = RRM_ZERO ;

	    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
	    " isMACCESendToUE [%d] , numOfScellsSchedulingNotAllowed [%d] ",
            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].isMACCESendToUE ,
            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].numOfScellsSchedulingNotAllowed );


            // look for backup data for scell configuration to reactivate the scell again at MAC 
	    for( index = RRM_ZERO; (index < p_ue_context->ue_scell_add_params.count) &&
                                   (index < RRM_MAX_SCELL ) ; index++ )
	    {
                /* if scell is active the scell state will be true : based on shariq code */
                if( SCELL_ACTIVE == p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_state )
                {
                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[RRM_ZERO].
                    schedulingActivateScell[deact_scell_count_to_reactivate] = p_ue_context->ue_scell_add_params.
                                                                   rrm_scell_info_for_ue[index].scell_index;

	            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
	            "scell arry index [%u], Relative scell index [%u] ",index , p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
                    ueScellSchedulingInfo[RRM_ZERO].schedulingActivateScell[deact_scell_count_to_reactivate] );
                     
                    deact_scell_count_to_reactivate++;
                }

	    }

            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
            ueScellSchedulingInfo[RRM_ZERO].numOfScellsSchedulingAllowed = deact_scell_count_to_reactivate ;

	    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
	    "Total numOfScellsSchedulingAllowed [%d]",
            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.
            ueScellSchedulingInfo[RRM_ZERO].numOfScellsSchedulingAllowed );

        /* BUG_11907_FIX_START */
	    transaction_id = rrm_maintain_transaction_block( rrm_mac_ue_reconfig_cnf_scell_activation_or_deactivation_action,RRM_PNULL );
        /* BUG_11907_FIX_END */
	    /* check whether invalid transaction id is not received*/
	    if( RRM_MINUS_ONE != transaction_id )
	    {
		if( RRM_SUCCESS == rrm_send_mac_ue_reconfig_req( p_mac_ue_reconfig_req ,
								 RRM_MODULE_ID,
								 (U16)transaction_id,
								 p_ue_context->cell_index))
		{
		    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
		    "Successfully sent RRM_MAC_UE_RECONFIG_REQ to  L2 for scell deactivation ,transac_id[%d]", 
                    transaction_id );

		}
		else
		{
		    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
		    "Could not send Successfully RRM_MAC_UE_RECONFIG_REQ to  L2 for scell deactivation , trns_id [%d]",
                    transaction_id );
		}
	    }
	    else
	    {
		/* here maximux number of transaction is already going on for mac ue econfig req,
		   thats why abort the task to send the deactivation req for remainng ue on the scell*/
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_ERROR,
		"Invalid transaction Id[%d] is generated for MAC_UE_RECONFIG_REQ API in case ho scell deactivation", RRM_MINUS_ONE);
	    }

        /* deallocate the memory */
            rrm_mem_free(p_mac_ue_reconfig_req);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
            "NULL Pointer mac ue reconfig req ");
        }

    }
   
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}




/***********************************************************************************
 *   FUNCTION NAME: rrm_mac_ue_reconfig_cnf_scell_activation_or_deactivation_action   
 *   DESCRIPTION:
 *       process mac ue reconfig cnf api  
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ***********************************************************************************/
rrm_return_et
/* BUG_11907_FIX_START */
rrm_mac_ue_reconfig_cnf_scell_activation_or_deactivation_action( rrm_cell_index_t            cell_index,
                                                                 void                        *p_api,
                                                                 void                        *p_gb_context,
                                                                 void                        *p_cell_stop_params )
/* BUG_11907_FIX_END */
{
    rrm_ue_context_t                     *p_ue_context = RRM_PNULL;
    RrmMacUEReConfigCnf                  *p_mac_ue_reconf_cnf = (RrmMacUEReConfigCnf*)p_api;
    U8                                   index = RRM_ZERO;
    /* +- SPR 18268 */
    U16                                   ue_count = RRM_ZERO;
    /* +- SPR 18268 */
    rrm_ue_index_t                       ue_index = RRM_ZERO ;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    /* BUG_11907_FIX_START */
    rrm_ue_reconfig_cell_stop_params_t   *p_ue_reconfig_cell_stop_params = (rrm_ue_reconfig_cell_stop_params_t*)p_cell_stop_params;
    /* BUG_11907_FIX_END */
    RRM_UT_TRACE_ENTER();

    if( (*((U32*)p_mac_ue_reconf_cnf)) & UE_CA_CONFIG_ERROR_INFO_BITMASK  )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "Mac ue reconfig cnf is handled with failure response");

        ue_count = p_mac_ue_reconf_cnf->ueCarrierAggConfigErrorInfo.numOfUE;

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "UE count [%d] for CA CONFIG ERROR info", ue_count);

        for( index = RRM_ZERO; index < ue_count ; index++ )
        {
            ue_index = p_mac_ue_reconf_cnf->ueCarrierAggConfigErrorInfo.
                ueCarrierAggConfigError[index].ueIndex;

            /* SPR 20652 Fix Start */
            p_ue_context = rrm_ue_find_context( ue_index , cell_index );

            if(RRM_PNULL != p_ue_context )
            {
                /* revert the scell info */
                rrm_revert_ue_scell_state_info(p_ue_context);
                /* SPR 20652 Fix End */
            }
            else
            {
                /*SPR 17777 +-*/
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                        "UE not found for this [UE:%d] and cell index [%d]"
                        "Unused variable p_gb_context=%p",ue_index,cell_index,p_gb_context);
                /*SPR 17777 +-*/
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
        "Mac ue reconfig cnf is handled with successful response for"
        "ca agg");
        /* BUG_11907_FIX_START */
        if(RRM_PNULL != p_cell_stop_params && (p_ue_reconfig_cell_stop_params->subsequent_resp == RRM_FALSE))
        {
            /*SPR 13316:start*/
            rrm_send_cell_stop_broadcast_resp(p_ue_reconfig_cell_stop_params->pcell_index, p_ue_reconfig_cell_stop_params->scell_index, RRM_SUCCESS, 
             p_ue_reconfig_cell_stop_params->trans_id);
            /*SPR 13316:end*/
            RRM_MEM_FREE(p_ue_reconfig_cell_stop_params);
        }
        /* BUG_11907_FIX_END */
    }

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}



/******************************************************************************
 *   FUNCTION NAME: rrm_mac_ue_reconfig_cnf_event_handler   
 *   DESCRIPTION:
 *       process mac ue reconfig cnf api  
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et rrm_mac_ue_reconfig_cnf_event_handler( rrm_ue_global_context_t   *p_rrm_glb_ctxt,
                                                     RrmMacUEReConfigCnf *p_api,
                                                     rrm_cell_index_t           cell_index,
                                                     U16                        trans_id )
{
    rrm_return_et      ret_val = RRM_SUCCESS;
    rrm_ue_procedure_record_t		*p_rrm_ue_procedure_record = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    if( ( RRM_NULL !=  p_rrm_glb_ctxt ) && ( RRM_NULL != p_api ) )
    {
            /*SPR 7892 FIX START*/
	switch(rrm_get_mac_ue_reconfig_mutex(cell_index))
	{
	     
	    case W_FOR_MAC_UE_RECONF_CNF_FOR_UL_MIMO:
		{
		    ret_val = rrm_handler_mac_ue_reconfig_cnf_event( cell_index,
								     p_api );
		    break;
		}
	    case W_FOR_MAC_UE_RECONF_CNF_FOR_ICIC:
		{
		    /*  DYNAMIC ICIC CHANGES START  */
		    rrm_mac_process_ue_reconfig_cnf_event( p_api, p_rrm_glb_ctxt ,cell_index);

		    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
			    "Successfully processed MAC UE RECONFIG CNF...");
		    break;
		}
	    case W_FOR_MAC_UE_RECONF_CNF_FOR_BEAMFRMG :
		{
		    /* Tm-7 , Tm-8 beamforming algo */
		    rrm_process_mac_ue_reconfig_cnf_for_beamforming( cell_index,p_api);

		    break;
		}
		/*  DYNAMIC ICIC CHANGES END  */
        case W_FOR_MAC_UE_RECONF_CNF_FOR_CA:
        {
          /*if failure is received revert the state and cause*/
          rrm_process_mac_ue_reconfig_for_ca(cell_index, p_api);
        }
        break;

        /* eICIC_PHASE_1_2_CHANGES_START */
        case W_FOR_MAC_UE_RECONF_CNF_FOR_EICIC :
        {
            /* SPR 14471 start */
            if(RRM_UE_RECONFIG_FOR_VICTIM == p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag)
            {
                ret_val = rrm_uem_process_ue_reconfig_for_victim_ue(p_rrm_glb_ctxt, cell_index, p_api);
                if(ret_val == RRM_SUCCESS)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                            "Successfully processed MAC UE RECONFIG CNF for eICIC...");
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                        "Received MAC UE RECONFIG CNF for eICIC for making UE non victim ...");
                /*SPR 15362 start */
                rrm_set_mac_ue_reconfig_mutex(cell_index,MAC_UE_RECONF_NOT_ONGOING);
                p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM;
                /*SPR 15362 start */

            }
            /* SPR 14471 end */
            break;
        }
        /* eICIC_PHASE_1_2_CHANGES_END */

	    default :
	    {
		    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
			    "Default case...... MAC UE RECONFIG CNF...");
	    }

	}
   /*CA Stage3:start*/ 
    /* Dequeue the ue_reconfig message */
    if (rrm_get_queue_count(&p_rrm_glb_ctxt->procedure_queue))
    {
        /** Dequeue the events from event queue and call message handler */
        /* SPR 15849 Start */
        /*SPR 21479 Fix start*/
        p_rrm_ue_procedure_record = rrm_ue_glb_dequeue_req( &(p_rrm_glb_ctxt->procedure_queue));
        /*SPR 21479 Fix end*/
        /* SPR 15849 End */
        if(RRM_PNULL != p_rrm_ue_procedure_record)
        { 
            p_rrm_glb_ctxt->p_proc_data = 
                p_rrm_ue_procedure_record->proc_queue.p_proc_data;
            rrm_ue_handle_dequeued_msg(p_rrm_ue_procedure_record, p_rrm_glb_ctxt, cell_index);
            RRM_MEM_FREE(p_rrm_ue_procedure_record);
        }
    }
   /*CA Stage3:end*/ 

	/*SPR 7892 FIX END*/
        /* in current we have defiend the range of transaction id from 50 to 99 
           for scell deactivation and activation param in mac ue reconfig req */
        if( trans_id >= RRM_FIFTY )
        {
            rrm_invoke_tb_handler( trans_id ,cell_index,(void*)p_api );
        }
        

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
	"Null pointer for gobal conetxt or api data ");
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/* BUG_11648_FIX_START */
/******************************************************************************
 *   FUNCTION NAME: rrm_send_cell_stop_broadcast_resp
 *   DESCRIPTION:
 *       process function for deactivating / activating the ue on scell
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_send_cell_stop_broadcast_resp( rrm_cell_index_t  pcell_index ,
                                    rrm_cell_index_t  scell_index ,
                                    rrm_return_et     status,
                                    /*SPR 13316:start*/
                                    U16               trans_id)
                                    /*SPR 13316:end*/
{

    rrmuem_rcm_cell_stop_broadcast_resp_t *p_rrmuem_rcm_cell_stop_broadcast_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_rrmuem_rcm_cell_stop_broadcast_resp = (rrmuem_rcm_cell_stop_broadcast_resp_t*)rrm_mem_get
        (sizeof(rrmuem_rcm_cell_stop_broadcast_resp_t));

    if( RRM_NULL != p_rrmuem_rcm_cell_stop_broadcast_resp)
    {
        RRM_MEMSET(p_rrmuem_rcm_cell_stop_broadcast_resp, RRM_NULL, sizeof(rrmuem_rcm_cell_del_resp_t));

        p_rrmuem_rcm_cell_stop_broadcast_resp->status = status;
        /*SPR 13316:start*/
        p_rrmuem_rcm_cell_stop_broadcast_resp->trans_id = trans_id;
        /*SPR 13316:end*/
        p_rrmuem_rcm_cell_stop_broadcast_resp->pcell_index = pcell_index;
        p_rrmuem_rcm_cell_stop_broadcast_resp->scell_index = scell_index;

        if (RRM_FAILURE == rrm_uem_send_internal_msg(RRM_CM_MODULE_ID,
                    RRMUEM_CM_CELL_STOP_RESP,
                    sizeof(rrmuem_rcm_cell_stop_broadcast_resp_t),
                    p_rrmuem_rcm_cell_stop_broadcast_resp))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRM send scell stop resp to CM failed");
        }
    }
    /*cov_fix_64284_start*/
    RRM_MEM_FREE(p_rrmuem_rcm_cell_stop_broadcast_resp);
    /*cov_fix_64284_end*/
    RRM_UT_TRACE_EXIT();
    /*Cov_fix_64281_start*/
    return RRM_SUCCESS;
    /*Cov_fix_64281_end*/
}

/* BUG_11648_FIX_END */

/******************************************************************************
 *   FUNCTION NAME: rrm_send_cell_info_change_ind_resp
 *   DESCRIPTION:
 *       process function for deactivating / activating the ue on scell
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_send_cell_info_change_ind_resp( rrm_cell_index_t  pcell_index ,
                                    rrm_cell_index_t  scell_index ,
                                    rrm_return_et     status,
        /*SPR 13316:start*/
                                    U16               trans_id)
        /*SPR 13316:end*/
{

    rrmuem_rcm_cell_del_resp_t *p_uem_cm_cell_del_resp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    p_uem_cm_cell_del_resp = (rrmuem_rcm_cell_del_resp_t *)rrm_mem_get
        (sizeof(rrmuem_rcm_cell_del_resp_t));

    if( RRM_NULL != p_uem_cm_cell_del_resp )
    {
        RRM_MEMSET(p_uem_cm_cell_del_resp, RRM_NULL, sizeof(rrmuem_rcm_cell_del_resp_t));

        p_uem_cm_cell_del_resp->status = status;
        p_uem_cm_cell_del_resp->pcell_index = pcell_index;
        p_uem_cm_cell_del_resp->scell_index = scell_index;
        /*SPR 13316:start*/
        p_uem_cm_cell_del_resp->trans_id = trans_id;
        /*SPR 13316:end*/

        if (RRM_FAILURE == rrm_uem_send_internal_msg(RRM_CM_MODULE_ID,
                    RRMUEM_CM_CELL_INFO_CHANGE_RESP,
                    sizeof(rrmuem_rcm_cell_del_resp_t),
                    p_uem_cm_cell_del_resp))
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"RRM send scell delete resp to CM failed");
        }
    }
    RRM_MEM_FREE(p_uem_cm_cell_del_resp);
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_find_ca_deactivation_activation_param_chaged  
 *   DESCRIPTION:
 *       process function for deactivating / activating the ue on scell 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_void_t rrm_find_ca_deactivation_activation_param_chaged( rrm_cell_index_t   pcell_index,
                                                             rrm_cell_index_t   scell_index,
                                                             U64                ca_bitmap,
        /*SPR 13316:start*/
                                                             U16                trans_id)
        /*SPR 13316:end*/
{

    rrm_bool_et		deact = RRM_FALSE;
    rrm_bool_et         scell_rel = RRM_FALSE;
    rrm_bool_et         scell_reconfig = RRM_FALSE;
    rrm_cell_index_t    arr_cell_index[RRM_MAX_SCELL] = {RRM_OUT_OF_RANGE};
    /* BUG_11907_FIX_START */
    rrm_ue_reconfig_type_et      reconfig_type;
    /* BUG_11907_FIX_END */

    RRM_UT_TRACE_ENTER();

    if (ca_bitmap & RRM_CA_CELL_STOP_BITMASK) 
    {
        deact = RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
                "RRM_CA_CELL_STOP_BITMASK is enabled");
        /* BUG_11907_FIX_START */
        reconfig_type = RRM_UE_RECONFIG_FOR_CELL_STOP;
        /* BUG_11907_FIX_END */
    }
    else if( ca_bitmap & RRM_CA_CELL_DELETE_BITMASK )
    {
        scell_rel = RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
                "RRM_CA_CELL_DELETE_BITMASK is enabled");
    }
    else if(( ca_bitmap & RRM_CA_CELL_CA_TO_NON_CA ) ||(ca_bitmap & RRM_CA_CELL_STOP_ADM_BITMASK))
    {
        deact = RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
                "RRM_CA_CELL_CA_TO_NON_CA or RRM_CA_CELL_STOP_ADM_BITMASK is enabled");
        /* BUG_11907_FIX_START */
        reconfig_type = RRM_UE_RECONFIG_FOR_OTHER;
        /* BUG_11907_FIX_END */
    }
    else if( ca_bitmap & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_COMMON_SCELL )
    {
        scell_rel = RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
                "RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_COMMON_SCELL is enabled");
    }
    else if( ca_bitmap & RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_SCELL )
    {
        scell_reconfig = RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_DETAILED,
                "RRM_SCELL_ADD_MOD_RADIO_RESOURCE_CONFIG_DEDICATED_SCELL is enabled");
    }
    if( RRM_TRUE == deact )
    {
        /* BUG_11907_FIX_START */
        /*SPR 13316:start*/
        rrm_perform_cell_deactivation_on_ca_configuration_change(pcell_index , scell_index, RRM_ZERO,reconfig_type, trans_id);
        /*SPR 13316:end*/
        /* BUG_11907_FIX_END */
    }
    else
    {
        if(scell_rel == RRM_TRUE)
        {
            arr_cell_index[RRM_ZERO] = scell_index;
            /* release Scell from all UEs in case of Radio resource config common param change and
               again add the scell on those UEs */
            /*SPR 13316:start*/
            rrm_fill_scell_to_remove_list(RRM_PNULL, pcell_index, RRM_ONE, arr_cell_index, ca_bitmap, trans_id);
            /*SPR 13316:end*/
       }
        else if(scell_reconfig == RRM_TRUE)
        {
            arr_cell_index[RRM_ZERO] = scell_index;
            /* Get all UEs reconfigured associated to the Scell. */
            rrm_send_ue_reconfig_on_rr_config_dedicated_param_upd(pcell_index, scell_index, ca_bitmap);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_ERROR,
                    "Invalid bitmask[%llu] sent to UEM.", ca_bitmap);
        }
        /* implement other algo's action */
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_send_ue_reconfig_on_rr_config_dedicated_param_upd  
 *   DESCRIPTION: Reconfig all UEs associated to Scell which reported updated 
 *           Radio resource config dedicated params updation.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_send_ue_reconfig_on_rr_config_dedicated_param_upd(
rrm_cell_index_t        pcell_index,
rrm_cell_index_t        scell_index,
U64                     ca_bitmask)
{
    rrm_return_et                 ret_val = RRM_SUCCESS; 
    rrm_ue_context_t              *p_ue_context = RRM_NULL;
    rrm_cell_context_t            *p_pcell_context = RRM_NULL;
    YLNODE                        *p_node = RRM_NULL;
    rrm_cell_index_t              arr_cell_index_add[RRM_MAX_SCELL] = {RRM_OUT_OF_RANGE};
    RRM_UT_TRACE_ENTER();
    p_pcell_context = rrm_cellm_get_cell_context(pcell_index);

    /*Coverity:65784 Start*/
    if (RRM_PNULL != p_pcell_context)
    {
        /*Coverity:65784 End*/
        p_node = ylFirst(&(p_pcell_context->scell_info[scell_index].list));
        while(p_node)
        {
            p_ue_context = (rrm_ue_context_t *)p_node;
            arr_cell_index_add[RRM_ZERO] = scell_index;
            /* ca bitmask added with RRM_UE_RECONFIG_REQ_SCELL_CONFIG_PARAMS_PRESENT 
               to hit only Scell add_mod_list part of the scell addition */
            ca_bitmask |= RRM_UE_RECONFIG_REQ_SCELL_CONFIG_PARAMS_PRESENT;
            ret_val = rrm_fill_scell_add_params(p_ue_context, RRM_ONE, arr_cell_index_add, ca_bitmask);
            p_node = ylNext(p_node); /* CID: 61041 - Fix */ 
        }
    }
    RRM_UT_TRACE_EXIT(); /* CID: 61040 - Fix */
    return ret_val;     
}

/******************************************************************************
 *   FUNCTION NAME: rrm_perform_cell_deactivation_on_ca_configuration_change  
 *   DESCRIPTION:
 *       process function for deactivating / activating the ue on scell 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_perform_cell_deactivation_on_ca_configuration_change( rrm_cell_index_t             pcell_index,
                                                          rrm_cell_index_t             scell_index,
                                                          U16                          num_of_user,
                                                          rrm_ue_reconfig_type_et      reconfig_type,
                                                          /*SPR 13316:start*/
                                                          U16                          trans_id)
                                                          /*SPR 13316:end*/
{

    YLIST                              *p_scell_list = RRM_NULL;
    YLNODE                             *next_ue_node = RRM_NULL;
    rrm_ue_context_t                   *p_ue_context = RRM_NULL;
    RrmMacUeReconfigReq                *p_mac_ue_reconfig_req = RRM_NULL ;
    U8                                  index = RRM_ZERO;
    U8                                  scell_array_index = RRM_ZERO;
    S16                                 transaction_id = RRM_ZERO;
    U16                                 total_ue_count = RRM_ZERO;
    U16                                 mac_ue_reconfig_req_count = RRM_ONE ; 
    /* BUG_11907_FIX_START */
    rrm_ue_reconfig_cell_stop_params_t  *p_reconfig_cell_stop_params = RRM_PNULL;
    /* BUG_11907_FIX_END */
    RRM_UT_TRACE_ENTER(); 

    p_scell_list = rrm_get_scell_list_of_cell(pcell_index , scell_index );

    if( RRM_NULL != p_scell_list )
    {
        /* allocate the memory for ue reconfig message */
        p_mac_ue_reconfig_req = (RrmMacUeReconfigReq*)rrm_mem_get(sizeof(RrmMacUeReconfigReq));

        total_ue_count = ylCount(p_scell_list);

        if( RRM_ZERO != num_of_user )
        { 
            total_ue_count = ( (num_of_user > total_ue_count)? total_ue_count: num_of_user ) ;
        }
        // find the number of request is required to be deactivated the ues  

        if( (RRM_NULL != p_mac_ue_reconfig_req) && (RRM_ZERO != total_ue_count ) )
        {
            if( total_ue_count > MAX_NUM_OF_UE )
            {
                if( RRM_ZERO == ( total_ue_count % MAX_NUM_OF_UE) )
                {
                    mac_ue_reconfig_req_count = ( total_ue_count / MAX_NUM_OF_UE);
                }
                else
                {
                    mac_ue_reconfig_req_count = (( total_ue_count / MAX_NUM_OF_UE) + RRM_ONE);
                }
            }

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                    "Total number of mac ue reconfig req for scell deactivation is [%d]",
                    mac_ue_reconfig_req_count);

            // get the very first node pointer of list 
            next_ue_node = ylFirst( p_scell_list );

            p_mac_ue_reconfig_req->bitmask = UE_CA_CONFIG_INFO_LIST_RECONFIG_BIT ;

            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.numOfUE = MAX_NUM_OF_UE;

            while( mac_ue_reconfig_req_count > RRM_ZERO )
            {
                /* BUG_11907_FIX_START */
                if (reconfig_type == RRM_UE_RECONFIG_FOR_CELL_STOP)
                {
                    p_reconfig_cell_stop_params = (rrm_ue_reconfig_cell_stop_params_t*)
                        rrm_mem_get(sizeof(rrm_ue_reconfig_cell_stop_params_t));
                    /*Cov_fix_start_64966*/
                    if( RRM_NULL !=  p_reconfig_cell_stop_params )
                    {

                        p_reconfig_cell_stop_params->subsequent_resp = RRM_TRUE;
                        p_reconfig_cell_stop_params->ue_reconfig_reason = reconfig_type;
                        p_reconfig_cell_stop_params->pcell_index = pcell_index;
                        p_reconfig_cell_stop_params->scell_index = scell_index;
                        /*SPR 13316:start*/
                        p_reconfig_cell_stop_params->trans_id = trans_id;
                        /*SPR 13316:end*/
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "Unable to allocate memory to p_reconfig_cell_stop_params");

                        /* coverity_64993_fix: Start */
                        if (RRM_PNULL != p_mac_ue_reconfig_req)
                        {
                            rrm_mem_free(p_mac_ue_reconfig_req);
                        }
                        /*Cov_fix_start_64987*/
                        return RRM_FAILURE;
                        /*Cov_fix_end_64987*/
                    }
                    /*Cov_fix_end_64966*/
                }
                /* BUG_11907_FIX_END */

                if( RRM_ONE == mac_ue_reconfig_req_count )
                {
                    /* BUG_11907_FIX_START */
                    if (reconfig_type == RRM_UE_RECONFIG_FOR_CELL_STOP)
                    {
                        p_reconfig_cell_stop_params->subsequent_resp = RRM_FALSE; 
                    }
                    /* BUG_11907_FIX_END */
                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.numOfUE = 
                        ((total_ue_count%MAX_NUM_OF_UE)? (total_ue_count%MAX_NUM_OF_UE): MAX_NUM_OF_UE);
                }

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                        "NumOfUE [%d] in request ", p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.numOfUE );

                for( index = RRM_ZERO ; index < (p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.numOfUE);
                        index++ )
                {
                    if( RRM_NULL == next_ue_node )
                        break;

                    p_ue_context = ( (rrm_scell_node_t *)next_ue_node)->p_ue_context;

                    /* perform the filling of deactivation data using ue context for each scell ue */

                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].
                        ueIndex = p_ue_context->ue_index;

                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].
                        isMACCESendToUE = RRM_ONE;

                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].
                        numOfScellsSchedulingAllowed = RRM_ZERO;

                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].
                        numOfScellsSchedulingNotAllowed = RRM_ONE;

                    p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].
                        schedulingDeactivateScell[RRM_ZERO] =
                        rrm_pick_relative_scell_index_of_actual_scell_index( p_ue_context,
                                scell_index,
                                &scell_array_index ); 

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_INFO,
                            " [UE:%d] , isMACCESendToUE [%d], numOfScellsSchedulingAllowed [%d] ",
                            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].ueIndex,
                            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].isMACCESendToUE,
                            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].
                            numOfScellsSchedulingAllowed);

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                            " NumOfScellsSchedulingNotAllowed [%d], relative scell index [%d] ",
                            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].
                            numOfScellsSchedulingNotAllowed,
                            p_mac_ue_reconfig_req->ueCarrierAggConfigInfoList.ueScellSchedulingInfo[index].
                            schedulingDeactivateScell[RRM_ZERO] );

                    /*cov fix start 63907*/
                    rrm_set_state_scell_state( p_ue_context ,scell_array_index,SCELL_DEACTIVE);
                    /*cov fix end 63907*/

                    /* ue pointing to next node in scell ue list */
                    next_ue_node = ylNext( next_ue_node );


                }

                /* this function will generate the transaction id and this transaction id will be registered 
                   with its confirmation handler function */
                /* BUG_11907_FIX_START */  
                transaction_id = rrm_maintain_transaction_block( rrm_mac_ue_reconfig_cnf_scell_activation_or_deactivation_action,
                                                                 p_reconfig_cell_stop_params );
                /* BUG_11907_FIX_END */
                /* check whether invalid transaction id is not received*/
                if( RRM_MINUS_ONE != transaction_id )
                {
                    if( RRM_SUCCESS == rrm_send_mac_ue_reconfig_req( p_mac_ue_reconfig_req ,
                                RRM_MODULE_ID,
                                (U16)transaction_id,
                                pcell_index))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                                "Successfully sent RRM_MAC_UE_RECONFIG_REQ to  L2 for scell deactivation , transaction id [%d]",
                                transaction_id );

                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                                "Could not send Successfully RRM_MAC_UE_RECONFIG_REQ to  L2 for scell deactivation, transc id [%d]",
                                transaction_id );
                    }
                }
                else
                {
                    /* here maximux number of transaction is already going on for mac ue econfig req,
                       thats why abort the task to send the deactivation req for remainng ue on the scell*/
                    break;
                }
                /* decrement the req for api by one */
                mac_ue_reconfig_req_count--;
            }

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING ,
                    "No of UE count is zero , so not sending the req  mac ue reconfig req ");
            /* BUG_11907_FIX_START */
            if(reconfig_type == RRM_UE_RECONFIG_FOR_CELL_STOP)
            {
                /*SPR 13316:start*/
                rrm_send_cell_stop_broadcast_resp(pcell_index ,scell_index,RRM_SUCCESS, trans_id);
                /*SPR 13316:end*/
            }
            /* BUG_11907_FIX_START */
        }

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED ,
                "rrm_perform_cell_deactivation_on_cell_stop function finds that No ue"
                "have added this cell in scell list");
    }

    /* free the allocated message memory */
    if( RRM_NULL != p_mac_ue_reconfig_req )
    {
        rrm_mem_free(p_mac_ue_reconfig_req);                    
    }

    RRM_UT_TRACE_EXIT(); 

    return RRM_SUCCESS;
}







/******************************************************************************
 *   FUNCTION NAME: rrm_perform_carrier_aggregation_related_action  
 *   DESCRIPTION:
 *       process function for deactivating / activating the ue on scell 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et 
rrm_perform_carrier_aggregation_related_action(rrm_cell_change_notification_object_t  *
                                                                        p_cell_ca_modfication_obj )
{
    rrm_cell_context_t     *p_pcell_context = RRM_NULL;
    rrm_cell_index_t        scell_index = RRM_ZERO;
    rrm_cell_index_t        pcell_index = RRM_ZERO;
    U64                     ca_config_bitmap = RRM_ZERO;
    /*SPR 13316:start*/
    U16                    trans_id = RRM_ZERO;
    /*SPR 13316:end*/

    RRM_UT_TRACE_ENTER();

    if( RRM_NULL != p_cell_ca_modfication_obj )
    {
        pcell_index = p_cell_ca_modfication_obj->cell_index;
        scell_index = p_cell_ca_modfication_obj->cell_broadcast_ca_info.cell_index;
        /*SPR 13316:start*/
        trans_id = p_cell_ca_modfication_obj->trans_id;
        /*SPR 13316:end*/
        p_pcell_context = rrm_cellm_get_cell_context(pcell_index );
        

        // carrier aggration related paramter reconfiguration during cell reconfiguration 
        ca_config_bitmap = p_cell_ca_modfication_obj->cell_broadcast_ca_info.ca_config_bitmask;


	if( RRM_NULL != p_pcell_context )
	{
	    /* p_cell_ca_modfication_obj->cell_index cell index will work as pcell index 
	       because when cell reconfiguration is triggered and ca configuration is 
	       changed during the cell reconfiguration. then cell manager sends the changed
	       cells cell index and various ca related parameters bitmask to ue manager
	       to indentify the which parameters are changed .
	       1) changed parameter can work as to active scell selection algorthim,
	       2) chnaged parameter can work as to active scell addition logic and release logic agaain
	       3) chnaged parameter can work as to active the scell deactivation  */
        /*SPR 13316:start*/
               rrm_find_ca_deactivation_activation_param_chaged(pcell_index, scell_index, ca_config_bitmap, trans_id);
        /*SPR 13316:end*/
	}
	else
	{
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "NULL pointer for p_pcell_context");
	}
    }

    RRM_UT_TRACE_EXIT(); 

    return RRM_SUCCESS; 
}

/*****************************************************************************
 *   FUNCTION NAME: rrm_uem_handler_cell_info_change_notification  
 *   DESCRIPTION:
 *       Handles the incoming messages, received from cell mgr 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_uem_handler_cell_info_change_notification(
                                /*SPR 17777 +-*/
                                rrm_void_t                 *p_api,
                                /*SPR 17777 +-*/
                                U16                         data_len )
{
    rrm_cell_change_notification_object_t      cell_info_transfer_obj = { RRM_ZERO };
    rrm_cell_change_notification_object_t      *temp_api = (rrm_cell_change_notification_object_t *)p_api;
    RRM_UT_TRACE_ENTER();
   
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_CELL_INFO_CHNANGE_IND");
    /* incorrect api buffer is received during the message processing */ 
    if( data_len < sizeof( rrm_cell_info_transfer_object ) )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
        "rrm_cell_info_transfer_object Message Buffer corruption at UE Mgr");
    }
    else 
    {
        SET_CELL_INDEX(temp_api->cell_index);
        cell_info_transfer_obj.cell_index = temp_api->cell_index;
        cell_info_transfer_obj.cell_broadcast_ca_info = temp_api->cell_broadcast_ca_info ;
        cell_info_transfer_obj.trans_id= temp_api->trans_id ;
      
        /* perform the carrier aggregation related action based on
           modified bitmap */ 
        rrm_perform_carrier_aggregation_related_action( &cell_info_transfer_obj ); 
    }

    RRM_UT_TRACE_EXIT(); 

    return RRM_SUCCESS;
}



/*****************************************************************************
 *   FUNCTION NAME: rrm_uem_handler_cell_info_change_notification  
 *   DESCRIPTION:
 *       Handles the incoming messages, received from cell mgr 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et 
rrm_uem_handler_scell_deact_notofication(
                                /*SPR 17777 +-*/
                                rrm_void_t                 *p_api,
                                /*SPR 17777 +-*/
                                U16                         data_len )
{

    rrm_scell_deactivation_notification_t      scell_deact_info = { RRM_ZERO };
    rrm_scell_deactivation_notification_t      *temp_api = (rrm_scell_deactivation_notification_t *)p_api;
    /* BUG_11907_FIX_START */
    rrm_ue_reconfig_type_et      reconfig_type = RRM_UE_RECONFIG_FOR_OTHER;
    /* BUG_11907_FIX_END */
    RRM_UT_TRACE_ENTER();
   
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_SCELL_DEACT_ON_LOAD");
    /* incorrect api buffer is received during the message processing */ 
    if( data_len < sizeof( rrm_scell_deactivation_notification_t ) )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
        "rrm_cell_info_transfer_object Message Buffer corruption at UE Mgr");
    }
    else 
    {
        SET_CELL_INDEX(temp_api->cell_index);
        scell_deact_info.cell_index = temp_api->cell_index;
        scell_deact_info.scell_deact_user = temp_api->scell_deact_user ;
        /*SPR 13316:start*/
        scell_deact_info.trans_id = temp_api->trans_id ;
        /*SPR 13316:end*/
        /* perform the carrier aggregation related action based on
           modified bitmap */ 
        /* BUG_11907_FIX_START */
        rrm_perform_cell_deactivation_on_ca_configuration_change( 
                                 scell_deact_info.cell_index ,
                                 scell_deact_info.scell_deact_user.cell_index,
                                 scell_deact_info.scell_deact_user.num_of_user,
                                 reconfig_type,
                                    /*SPR 13316:start*/
                                 scell_deact_info.trans_id); 
                                /*SPR 13316:end*/
        /* BUG_11907_FIX_END */
    }

    RRM_UT_TRACE_EXIT(); 
    return RRM_SUCCESS;
}
/* Carrier Aggregation end */



/*****************************************************************************
 *   FUNCTION NAME: rrm_uem_handler_deact_all_scell_ue_on_ca_to_no_ca  
 *   DESCRIPTION:
 *       Handles the incoming messages, received from cell mgr 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_uem_handler_deact_all_scell_ue_on_ca_to_no_ca(
         /*SPR 17777 +-*/
                                 rrm_void_t                *p_api,
         /*SPR 17777 +-*/
                                 U16                        data_len )
{

    YLIST                         *p_scell_list = RRM_NULL;
    rrm_cell_context_t            *p_cell_context = RRM_NULL;
    rrm_cell_index_t               scell_index = RRM_ZERO;
    rrm_cell_index_t               pcell_index = RRM_ZERO;
    /* BUG_11907_FIX_START */
    rrm_ue_reconfig_type_et      reconfig_type = RRM_UE_RECONFIG_FOR_OTHER;
    /* BUG_11907_FIX_END */
    /*SPR 13316:start*/
    U16                          trans_id = RRM_ZERO;
    /*SPR 13316:end*/

    RRM_UT_TRACE_ENTER();
 
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_SCELL_DEACT_ON_CA_TO_NON_CA");
    
    if( data_len < sizeof( rrm_cell_info_transfer_object ) )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
        "rrm_cell_info_transfer_object Message Buffer corruption at UE Mgr");
    }
    else 
    {
        pcell_index = ((rrm_cell_info_transfer_object*)p_api)->cell_index;
        SET_CELL_INDEX(pcell_index);
        /*SPR 13316:start*/
        trans_id = ((rrm_cell_info_transfer_object*)p_api)->trans_id;
        /*SPR 13316:end*/

        p_cell_context = rrm_cellm_get_cell_context( pcell_index );

        if( RRM_NULL != p_cell_context )
        {
            /* iterate for all scell index to find the pcell index and scell index based list */
            for( scell_index = RRM_ZERO; scell_index < RRM_MAX_SCELL; scell_index++ )
            {

                p_scell_list = rrm_get_scell_list_of_cell(pcell_index , scell_index );

                /* FIX CID :61032 */
                if( RRM_NULL != p_scell_list )
                {
                    if( ylCount(p_scell_list) )
                    {
                        /* BUG_11907_FIX_START */
                        rrm_perform_cell_deactivation_on_ca_configuration_change( pcell_index, 
                                                                                  scell_index,
                                                                                  RRM_ZERO,
                                                                                  reconfig_type,
                                                                                /*SPR 13316:start*/
                                                                                  trans_id);
                                                                                /*SPR 13316:end*/
                        /* BUG_11907_FIX_END */
                    }
                    else
                    {
			RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
			" No . of ue count in list is zero for scell ");
                    }

                }

            }
 
        }
    }

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_ue_mgr_rrm_cm_msg_handler
 *   DESCRIPTION:
 *       Handles the incoming messages, received from RRM Cell Manager.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_mgr_rrm_cm_msg_handler (
        rrm_void_t *p_api_buf,
        rrm_void_t *p_gl_ctx
        )
{
    rrm_ue_global_context_t     *p_rrm_glb_ctxt = RRM_PNULL;
    rrm_return_et 				ret_val = RRM_SUCCESS;
    U16							api_id = RRM_NULL;
    U16							msg_size = RRM_NULL;
    RRM_UT_TRACE_ENTER();

    p_rrm_glb_ctxt = (rrm_ue_global_context_t *)p_gl_ctx;
    api_id   = rrm_get_word_from_header((U8*)(p_api_buf) + STACK_API_API_OFFSET);
    msg_size = rrm_get_word_from_header((U8*)(p_api_buf) + STACK_API_PARAM_LEN_OFFSET);
    p_api_buf = p_api_buf + RRM_API_HEADER_SIZE; 

    switch(api_id)
    {
        case  (U16)RRMUEM_CM_DELETE_ALL_UE_CONTEXT_REQ: /* Coverity: CID 29469 */
         /*SPR 17777 +-*/
            ret_val = rrm_uem_handle_cm_delete_all_ue_context_req(
                    p_rrm_glb_ctxt, p_api_buf);
            break;
        case  (U16)RRMUEM_CM_SET_UNSET_ECN_IND: /* Coverity: CID 29469 */
            ret_val = rrm_uem_handle_cm_set_unset_ecn_bit_req(p_api_buf);
            break;
        case  (U16)RRMUEM_CM_UNSET_ECN_FOR_ALL_UE_IND: /* Coverity: CID 29469 */
            ret_val = rrm_uem_unset_ecn_for_all_ue_ind(p_api_buf);
	    /*coverity 24977: break addded: aditya, rel 1.3*/
	    break;
        case (U16)RRMUEM_CM_REDIRECT_REL_IND: /* Coverity: CID 29469 */
            ret_val = rrm_uem_redirect_ue(p_api_buf);
            break;
        /*  DYNAMIC ICIC CHANGES START  */
        case  (U16)RRMUEM_CM_UPDATE_UE_INFO_REQ: /* Coverity: CID 29469 */
            ret_val = rrm_uem_handle_cm_update_ue_info_req(
                    p_rrm_glb_ctxt, p_api_buf);
            break;
        /*  DYNAMIC ICIC CHANGES END  */
        case (U16)RRMUEM_CM_PRB_THRESHOLD_REACHED_IND: /* Coverity: CID 29469 */
             ret_val = rrm_uem_handle_prb_threshold_indication( 
                                                                p_api_buf,
                                                                msg_size );
         /*SPR 17777 +-*/
             break;
        /*SPR-695 Fix Starts*/
        case  RRMUEM_CM_DELETE_LOW_PRIORITY_UE_REQ:
            ret_val = rrm_uem_handle_low_priority_ue_del_req(
                    p_rrm_glb_ctxt, p_api_buf);
            break;
        /*SPR-695 Fix Ends*/
        /* SPR 16406 Start */
        /*coverity_fix 29469 ++  */
        case (U16)RRMUEM_CM_AWAITED_HO_TRIGGER_IND:
        /*coverity_fix 29469 --  */
            ret_val = rrm_uem_handle_awaited_ho_trigger_ind(p_api_buf); 
            /* Coverity Fix 94845 Start */
            if(RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "CellM->UEM:RRMUEM_CM_AWAITED_HO_TRIGGER_IND failed to process");
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                        "CellM->UEM:RRMUEM_CM_AWAITED_HO_TRIGGER_IND successfully processed");
            }
            /* Coverity Fix 94845 End */
        /* SPR 16406 End */
        case (U16)RRMUEM_CM_CELL_INFO_CHNANGE_IND:
         /*SPR 17777 +-*/
             ret_val = rrm_uem_handler_cell_info_change_notification( 
                                                                      p_api_buf,
                                                                      msg_size );
             break;
        case (U16)RRMUEM_CM_SCELL_DEACT_ON_LOAD :
             ret_val = rrm_uem_handler_scell_deact_notofication( 
                                                                 p_api_buf,
                                                                 msg_size );
             break;
        case (U16)RRMUEM_CM_SCELL_DEACT_ON_CA_TO_NON_CA:
             ret_val = rrm_uem_handler_deact_all_scell_ue_on_ca_to_no_ca( 
                                                                          p_api_buf,
                                                                          msg_size);
         /*SPR 17777 +-*/
             break;
             /* eICIC_PHASE_1_2_CHANGES_START */
        case  (U16)RRMUEM_CM_GET_AGGRESSOR_REQ: 
             ret_val = rrm_uem_handle_cm_get_aggressor_req(p_rrm_glb_ctxt, p_api_buf);
             break;
        case (U16)RRMUEM_CM_SCHEDULE_VICTIM_UE_IND:
             ret_val = rrm_uem_handler_schedule_victim_ue(p_rrm_glb_ctxt,
                     p_api_buf,
                    /*SPR 17777 +-*/
                     msg_size);
             break;
        case  (U16)RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_REQ: 
             ret_val = rrm_uem_handle_eicic_provision_req(p_rrm_glb_ctxt, p_api_buf);
             break;
             /* eICIC_PHASE_1_2_CHANGES_END */

#ifdef LTE_EMBMS_SUPPORTED
        case (U16)RRMUEM_CM_MBMS_RECONFIG_UE_IND:
             ret_val = rrm_uem_handler_mbms_reconfig_ue(
                     p_api_buf,
                     msg_size);
             break;
#endif

        default:
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "Received invalid request[api_id=%d] from CellManager", api_id);
            ret_val = RRM_SUCCESS;
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Spr 18748 Fix Start */
/****************************************************************************
 *  * Function Name  : rrm_check_if_sec_meas_configured
 *  * Inputs         : p_ue_context, 
 *  * Outputs        : None
 *  * Returns        : RRM_TRUE/RRM_FALSE 
 *  * Description    : This function checks whether secondary meas object or 
 *  *                  b2 event is configured 
 *****************************************************************************/
rrm_bool_et
    rrm_check_if_sec_meas_configured
(
 rrm_ue_context_t *p_ue_context
 )
{
    rrm_bool_et retVal = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_ue_context)
    {
        if ((p_ue_context->ho_params.bitmask &
                    RRM_UE_SECONDARY_MEAS_OBJ_CONFIGURED)||
                (p_ue_context->ho_params.bitmask &
                 RRM_UE_B2_MEAS_OBJ_CONFIGURED))
        {     
            retVal = RRM_TRUE;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Secondary meas obj is configured for ue_index = %d",
                    p_ue_context->ue_index);
        }     
    }
    else  
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "input pointer p_ue_context is null !!!");
    }

    RRM_UT_TRACE_EXIT();
    return retVal;
}
/* Spr 18748 Fix End */

/* SPR 16406 Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_handle_awaited_ho_trigger_ind 
 *   DESCRIPTION:   This function attempts HO for awaited UE kept in cgi pending list
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_uem_handle_awaited_ho_trigger_ind
(
    rrm_void_t *p_api_buf
)
{
    rrm_cellm_uem_ho_trigger_ind_t *p_uem_ho_trigger_ind = RRM_PNULL;
    rrm_return_et ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    rrm_ue_context_t *p_ue_context = RRM_PNULL;
    rrm_cell_context_t *p_cell_context = RRM_PNULL;
    /* SPR 16406 8SEP start */
    /* SPR 16406 18sep Start */
    phy_cell_id_info_t phy_cell_id_info = {RRM_ZERO, INVALID_PHYSICAL_CELL_ID, RRM_ZERO, RRM_FALSE, RRM_FALSE, {{{RRM_ZERO}, RRM_ZERO, {RRM_ZERO}}, {RRM_ZERO}}};
    /* SPR 16406 18sep End */
    /* SPR 16406 8SEP end */
    U16 transaction_id = rrm_generate_txn_id();
    ho_pending_cgi_node_t *p_temp_cgi_pending_node = RRM_PNULL;
    ho_pending_cgi_node_t *p_next_cgi_pending_node = RRM_PNULL;
    /* SPR 16406 8SEP start */
    YLIST *p_ho_pending_cgi_list                    = RRM_PNULL;
    /* SPR 16406 8SEP end */

    RRM_UT_TRACE_ENTER();
    
    p_uem_ho_trigger_ind = (rrm_cellm_uem_ho_trigger_ind_t*)p_api_buf;
    p_cell_context = rrm_cellm_get_cell_context(p_uem_ho_trigger_ind->cell_index);
    /*Coverity 94784 Fix Start*/ 
    if(RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Cell Context not found[%d]",p_uem_ho_trigger_ind->cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*Coverity 94784 Fix End*/ 
    /* Assigning to actual list kept in cell context */
    /* SPR 16406 8SEP start */
    p_ho_pending_cgi_list = &p_cell_context->rrm_cgi_pending_list.
        rrm_ho_pending_cgi_list[p_cell_context->cell_index].ho_pending_cgi_list;
    /* SPR 16406 8SEP end */

    /* SPR 16406 8SEP start */
    /* Code removed */
    /* SPR 16406 8SEP end */

    /* SPR 16406 8SEP start */
    p_temp_cgi_pending_node = (ho_pending_cgi_node_t *)ylFirst(p_ho_pending_cgi_list);
    /* SPR 16406 8SEP end */
    while(p_temp_cgi_pending_node)
    { 
        p_next_cgi_pending_node = (ho_pending_cgi_node_t *)ylNext(&p_temp_cgi_pending_node->node);
        if((p_temp_cgi_pending_node->ho_pending_cgi_node_data.pci == p_uem_ho_trigger_ind->pci) 
                &&(p_temp_cgi_pending_node->ho_pending_cgi_node_data.earfcn == p_uem_ho_trigger_ind->earfcn))
        {
            /* SPR 16406 18sep Start */
            if(p_uem_ho_trigger_ind->bitmask & RRM_UEM_HO_TRIGGER_IND_CGI_PRESENT)
            {
                if(RRM_SUCCESS == compare_global_cell_id(&(p_uem_ho_trigger_ind->cgi), 
                            &(p_temp_cgi_pending_node->ho_pending_cgi_node_data.cgi)))
                {
                    RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_DETAILED,
                            " CGI match found for PCI[%u]",p_uem_ho_trigger_ind->pci);

                    phy_cell_id_info.bitmask = RRM_PHY_CELL_ID_INFO_CGI_PRESENT; 
                    RRM_MEMCPY(&(phy_cell_id_info.cgi),
                            &(p_uem_ho_trigger_ind->cgi),
                            sizeof(rrm_oam_eutran_global_cell_id_t));
                }
                else
                {
                    p_temp_cgi_pending_node = p_next_cgi_pending_node;
                    continue;
                }
            }
            /* SPR 16406 18sep End */
            /* UE found for PCI+Earfcn combination send HO required for this UE and delete its node then*/
            /* SPR 20652 Fix Start */
            p_ue_context = rrm_ue_find_context(p_temp_cgi_pending_node->ho_pending_cgi_node_data.ue_idx,
                    p_uem_ho_trigger_ind->cell_index);
            /*Coverity 88580 Fix Start*/
            if (RRM_PNULL == p_ue_context) 
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                        "[UE:%d]CELL_INDEX[%d], failed to find ue context",p_temp_cgi_pending_node->ho_pending_cgi_node_data.ue_idx,
                        p_uem_ho_trigger_ind->cell_index);
                /* CID 97022 Fix Start */
                ret_val = RRM_FAILURE;
                RRM_UT_TRACE_EXIT();
                return ret_val;
                /* CID 97022 Fix End */
            }
            else
            {
                /* SPR 20652 Fix End */
                p_ue_context->target_cell_type = EUTRA_CELL;	
                phy_cell_id_info.phy_cell_id = p_uem_ho_trigger_ind->pci;
                phy_cell_id_info.carr_earfcn = p_uem_ho_trigger_ind->earfcn;
            }
            /*Coverity 88580 Fix End*/
            ret_val = rrm_build_and_send_ho_required (
                    phy_cell_id_info,
                    p_ue_context,
                    transaction_id);
            if(RRM_SUCCESS == ret_val)
            {
                RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_DETAILED,
                        "Ho Triggered for PCI[%u] + Earfcn[%u] for [UE:%u]",
                        phy_cell_id_info.phy_cell_id,
                        phy_cell_id_info.carr_earfcn,
                        p_ue_context->ue_index);
                /* SPR 16406 8SEP start */
                /* Code removed */
                /* SPR 16406 8SEP end */
            }
            else
            {
                /* SPR 16406 8SEP start */
                RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_ERROR,
                        "Ho cannot be Triggered for PCI[%u] + Earfcn[%u] for [UE:%u]",
                        phy_cell_id_info.phy_cell_id,
                        phy_cell_id_info.carr_earfcn,
                        p_ue_context->ue_index);
                /* SPR 16406 8SEP end */
            }
            /* SPR 16406 8SEP start */
            ylDelete(p_ho_pending_cgi_list , &p_temp_cgi_pending_node->node);
            RRM_MEM_FREE(p_temp_cgi_pending_node);
            /* SPR 16406 8SEP end */
        }
        /* SPR 16406 8SEP start */
        p_temp_cgi_pending_node = p_next_cgi_pending_node;
        /* SPR 16406 8SEP end */
    }

    RRM_UT_TRACE_EXIT(); 
    return ret_val;
}
/* SPR 16406 End */

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_send_internal_msg
 *   DESCRIPTION:
 *        This function sends messages to internal modules i.e. RRM_MIF and CM
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_uem_send_internal_msg(
        U16  dst_module_id,
        U16  api_id,
        U16  msg_size,
        rrm_void_t *p_msg
        )
{
    U8 *p_api          = RRM_PNULL;
    U16 msg_api_length = (U16)(msg_size + RRM_API_HEADER_SIZE);

    RRM_UT_TRACE_ENTER();
    /* Allocate buffer */
    p_api = rrm_msg_mem_get(msg_api_length);
    if (RRM_PNULL == p_api)
    {
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_api, RRM_ZERO, msg_api_length);
    rrm_construct_cspl_header(p_api,
            RRM_VERSION_ID,
            RRM_UEM_MODULE_ID,
            dst_module_id,
            api_id,
            RRM_API_PRIORITY,
            msg_api_length);
    RRM_MEMCPY(p_api + RRM_API_HEADER_SIZE, p_msg, msg_size);
    /** Send message to required destination*/
    /*SPR 20172 Fix Start*/
    rrm_send_message(p_api, dst_module_id);
    /*SPR 20172 Fix End*/
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_send_rrmim_init_req
 *   DESCRIPTION:
 *        Send INIT request to MIF
 *   RETURNS:
 *		void
 ******************************************************************************/
void
rrm_ue_send_rrmim_init_req(
        U16 src_id
         /*SPR 17777 +-*/
        )
{
    U16             api_id = RRM_ZERO;
    U16             msg_size = RRM_ZERO;
    U8              *p_msg = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    rrmuem_rmif_init_ind_t *p_rrmuem_rmif_init_ind;
    p_rrmuem_rmif_init_ind = rrm_mem_get(sizeof(rrmuem_rmif_init_ind_t));
    if( RRM_PNULL == p_rrmuem_rmif_init_ind )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return ;
    }
    /* coverity : CID 16397*/
    p_rrmuem_rmif_init_ind->module_id = (rrm_internal_module_id_et)src_id;

    msg_size = sizeof(rrmuem_rmif_init_ind_t);
    p_msg = (rrm_void_t *)p_rrmuem_rmif_init_ind;
    api_id = RRMUEM_RMIF_INIT_IND;
    if( RRM_FAILURE == rrm_uem_send_internal_msg (RRM_MIF_MODULE_ID,
                api_id,
                msg_size,
                p_msg))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"RRM send to MIF failed %d\n",api_id);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Sent to MIF %d", api_id);
    }
    RRM_MEM_FREE(p_rrmuem_rmif_init_ind);

    RRM_UT_TRACE_EXIT();
    return;
}

/****************************************************************************
 * Function Name  : rrm_get_csg_non_csg_ues
 * Inputs         : none
 * Outputs        : number of connected csg and non
                    csg ues
 * Returns        : void
 * Description    : This function finds the number of admitted
                    csg and non csg ues
****************************************************************************/
void
rrm_get_csg_non_csg_ues(
        U8 *num_connected_csg_ue,
        U8 *num_connected_non_csg_ue,
        rrm_cell_index_t cell_index
        )
{
    rrm_cell_info_for_ue_mgr_t *p_rrm_cell_info_for_ue_mgr = RRM_NULL;
    RRM_UT_TRACE_ENTER();
    p_rrm_cell_info_for_ue_mgr = rrm_cellm_get_cell_resource_info(cell_index);
    (*num_connected_csg_ue) = p_rrm_cell_info_for_ue_mgr->admitted_csg_user;
    (*num_connected_non_csg_ue) = p_rrm_cell_info_for_ue_mgr->admitted_non_csg_user;
    RRM_UT_TRACE_EXIT();

}
/**CLPC_MR_START*/
/******************************************************************************
 *   FUNCTION NAME: rrm_de_allocate_tpc_rnti for and pusch pucch
 *
 *   DESCRIPTION:
 *       releases the tpc rnti(pusch and pucch) on ue release
 *
 *   RETURNS:
 *       void
 *****************************************************************************/
void
rrm_de_allocate_tpc_rnti(
        U16 tpc_rnti_pucch,
        U16 tpc_rnti_pusch,
        U8 tpc_rnti_index_pucch,
        U8 tpc_rnti_index_pusch,
        rrm_cell_index_t            
        cell_index
        )
{
    U8 tpc_index = RRM_ZERO;
    U16 start_tpc_rnti_pucch = RRM_ZERO;
    U16 start_tpc_rnti_pusch = RRM_ZERO;
    rrm_ue_tpc_rnti_tbl_pusch_t *p_rrm_ue_tpc_rnti_tbl_pusch = RRM_PNULL;
    rrm_ue_tpc_rnti_tbl_pucch_t *p_rrm_ue_tpc_rnti_tbl_pucch = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_rrm_ue_tpc_rnti_tbl_pusch = (rrm_ue_tpc_rnti_tbl_pusch_t*)rrm_cellm_get_tpc_rnti_allocation_table_pusch(cell_index);
    
    p_rrm_ue_tpc_rnti_tbl_pucch = (rrm_ue_tpc_rnti_tbl_pucch_t*)rrm_cellm_get_tpc_rnti_allocation_table_pucch(cell_index);
    /*Start:SPR 8715*/
    U8 num_tpc_id_dci_3=rrm_cm_get_num_tpc_id_dci3(cell_index);
    U8 num_tpc_id_dci_3a=rrm_cm_get_num_tpc_id_dci3a(cell_index);
    /*End:SPR 8715*/
                
    /*de allocate pucch*/
    start_tpc_rnti_pucch = rrm_return_start_tpc_rnti_pucch(cell_index);
    /*Start:SPR 8715*/
    for(tpc_index = RRM_ZERO;
            tpc_index<num_tpc_id_dci_3a;tpc_index++)
    /*End:SPR 8715*/
    {
        if(tpc_rnti_index_pucch == tpc_index+RRM_ONE)
        {
            p_rrm_ue_tpc_rnti_tbl_pucch->p_p_rrm_ue_tpc_rnti_row_pucch[
                tpc_rnti_pucch-start_tpc_rnti_pucch]->
                p_tpc_id[tpc_index]=RRM_RNTI_FREE;

            p_rrm_ue_tpc_rnti_tbl_pucch->p_p_rrm_ue_tpc_rnti_row_pucch[
                tpc_rnti_pucch-start_tpc_rnti_pucch]->
                busy_field=RRM_RNTI_FREE;

            p_rrm_ue_tpc_rnti_tbl_pucch->p_p_rrm_ue_tpc_rnti_row_pucch[
                tpc_rnti_pucch-start_tpc_rnti_pucch]->
                occupied_tpc_id_count -= RRM_ONE;
        }
    }

    /*de allocate pusch*/
    start_tpc_rnti_pusch = rrm_return_start_tpc_rnti_pusch(cell_index);
    /*Start:SPR 8715*/
    for(tpc_index = RRM_ZERO;
            tpc_index<num_tpc_id_dci_3;tpc_index++)
    /*End:SPR 8715*/
    {
        if(tpc_rnti_index_pusch == tpc_index+RRM_ONE)
        {
            p_rrm_ue_tpc_rnti_tbl_pusch->p_p_rrm_ue_tpc_rnti_row_pusch[
                tpc_rnti_pusch-start_tpc_rnti_pusch]->
                p_tpc_id[tpc_index]=RRM_RNTI_FREE;

            p_rrm_ue_tpc_rnti_tbl_pusch->p_p_rrm_ue_tpc_rnti_row_pusch[
                tpc_rnti_pusch-start_tpc_rnti_pusch]->
                busy_field=RRM_RNTI_FREE;

            p_rrm_ue_tpc_rnti_tbl_pusch->p_p_rrm_ue_tpc_rnti_row_pusch[
                tpc_rnti_pusch-start_tpc_rnti_pusch]->
                occupied_tpc_id_count -=RRM_ONE;
        }
    }
    RRM_UT_TRACE_EXIT();
}

void 
rrm_handle_ue_reconfig_resp_fail(
        rrm_ue_context_t *p_ue_context
        )
{
    RRM_UT_TRACE_ENTER();
    rrm_de_allocate_tpc_rnti(
            p_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch,
            p_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch,
            p_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pucch,
            p_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pusch,
            p_ue_context->cell_index);

    p_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch = RRM_ZERO;
    p_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch  = RRM_ZERO;
    p_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pucch  = RRM_ZERO;
    p_ue_context->rrm_ue_clpc_params.tpc_rnti_index_pusch  = RRM_ZERO;
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_send_l2_msg
 *   DESCRIPTION:
 *        Send message to L2 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_send_l2_msg(
         /*SPR 17777 +-*/
        U16  msg_size,
        rrm_void_t *p_msg
        )
{
    U8 *p_api          = RRM_PNULL;
    U8 *p_mac_msg       = RRM_PNULL;
    rrm_cell_index_t    cell_index = RRM_ZERO;
    
    
    RRM_UT_TRACE_ENTER();
    
    U16 msg_api_length = (U16)(msg_size + RRM_INTERFACE_API_HEADER_SIZE + RRM_API_HEADER_SIZE);
    /* Allocate buffer */
    p_api = rrm_msg_mem_get(msg_api_length);
    if (RRM_PNULL == p_api)
    {
        return RRM_FAILURE;
    }
    p_mac_msg = p_api;
    RRM_MEMSET(p_api, RRM_ZERO, msg_api_length);
    rrm_construct_api_header(p_mac_msg, RRM_VERSION_ID, RRM_MODULE_ID,
            RRM_L2_MODULE_ID,RRM_L2_GET_SNR_REPORT, msg_api_length);

    p_mac_msg= p_mac_msg + RRM_API_HEADER_SIZE;

    /* Fill interface header */
    rrm_construct_interface_api_header(p_mac_msg, 1, RRM_MODULE_ID,
            RRM_L2_MODULE_ID,RRM_L2_GET_SNR_REPORT , sizeof(rrm_l2_get_snr_report_t),cell_index);

    /* Fill MAC_INIT_LAYER_REQ message */
    p_mac_msg = p_mac_msg + RRM_INTERFACE_API_HEADER_SIZE;

    RRM_MEMCPY(p_mac_msg, (rrm_l2_get_snr_report_t*)p_msg, sizeof(rrm_l2_get_snr_report_t));
    /** Send message to required destination*/
    /*SPR 20172 Fix Start*/
    rrm_send_message(p_api, RRM_L2_MODULE_ID);
    /*SPR 20172 Fix End*/
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/*LTE_RRM_KLOCWORK_WARN_30_JULY_START*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_emergency_establishment_operation
 *   DESCRIPTION:
 *       Process the UE's Emergency establishment opeation
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
/* SPR 17564 Fix Start */
rrm_ue_emergency_establishment_operation(
                     rrm_ue_context_t      *p_ue_context,	
                     U8                    trans_id,
/* SPR 17564 Fix End */
    rrm_cell_index_t                cell_index
)
{

    rrm_return_et                               ret_val = RRM_FAILURE;
    rrm_ue_index_t 				ue_index = RRM_ZERO;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_temp = RRM_PNULL;
    /* SPR 20652 Fix End */

    RRM_UT_TRACE_ENTER();
  
    /* SPR 17564 Fix Start */
    if (RRM_TRUE == rrm_is_ue_special_previledge(p_ue_context))
    /* SPR 17564 Fix End */
    {
        /*Bug_721_changes_start*/
/*spr_22158_changes_start*/
        if(RRM_SUCCESS ==  rrm_ue_get_low_priority_ue(p_ue_context->cell_index, &ue_index, RRM_ZERO,RRM_ZERO, RRM_FALSE))
/*spr_22158_changes_end*/
        /*Bug_721_changes_end*/
       {
         if(RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
                    ue_index,
                    RADIO_NETWORK_LAYER_TYPE,
                    REDUCE_LOAD_IN_SERVING_CELL,
                    trans_id,
                    RRM_PNULL,
                    /* SPR_10729_fix */
                    cell_index))
         {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "send release connection ind send for [UE:%d]",ue_index);
	        ret_val = RRM_SUCCESS;
            /* SPR 20652 Fix Start */
            p_temp = rrm_ue_find_context(ue_index,
                    cell_index);
            if (RRM_PNULL == p_temp)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                        "[UE:%d]CELL_INDEX[%d], failed to find ue context",ue_index,cell_index);
                ret_val = RRM_FAILURE;
            }
            else
            {
                if(RRM_FAILURE == rrm_ue_resource_clean_up(p_temp))
                    /* SPR 20652 Fix End */
                {
                    RRM_TRACE(g_uem_log_on_off,
                            p_g_rrm_uem_facility_name,
                            RRM_ERROR,
                            "ue_connection_release_ind sent, Failed to clean up ue resources");
                    ret_val = RRM_FAILURE;

                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off,
                            p_g_rrm_uem_facility_name,
                            RRM_DETAILED,
                            "successfully cleaned up resources for the [UE:%d]",
                            ue_index);
                }
            }
         }
         else
         {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "Failed to send release connection ind send for [UE:%d]",
                    ue_index);
            ret_val = RRM_FAILURE;

         }
      }
      else
      {
            /* SPR 14961 Fix start */
          /* SPR 20652 Fix Start */
          p_temp = rrm_ue_find_context(ue_index,
                  cell_index);
          if(RRM_PNULL == p_temp)
          {
              /* SPR 20652 Fix End */
              RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "There is no UE present in the cell so no need to delete low priority UE");
                ret_val = RRM_SUCCESS;
            }
            /* SPR 14961 Fix end */
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                        "Unable to find any lower priority UE than UE index");
                ret_val = RRM_FAILURE;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_KLOCWORK_WARN_30_JULY_END*/

/******************************************************************************
 *   FUNCTION NAME: rrm_hold_ue
 *   DESCRIPTION:
 *       Holds a ue when max num ue threshold is reached
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_hold_ue_for_ho(
        rrm_ue_context_t *p_ue_context
        )
{
    rrm_return_et ret_val = RRM_FAILURE;
    access_mgmt_params_t     *p_access_mgmt_params = RRM_PNULL;
    U8 num_connected_non_csg_ue = RRM_ZERO;
    U8 num_connected_csg_ue = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    rrm_get_csg_non_csg_ues(&num_connected_csg_ue,&num_connected_non_csg_ue,p_ue_context->cell_index);
    p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(p_ue_context->cell_index);
    if((p_access_mgmt_params->max_csg_members == RRM_INDEX_ERR) &&
            num_connected_csg_ue < rrm_cellm_get_max_num_ue_per_cell(p_ue_context->cell_index))
    {
        p_ue_context->rrm_ue_in_hold = RRM_TRUE;
        ret_val = RRM_SUCCESS;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_hold_ue
 *   DESCRIPTION:
 *       Holds a ue when max num ue threshold is reached  
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_hold_ue(
        rrm_ue_context_t *p_ue_context
        )
{
    rrm_return_et ret_val = RRM_FAILURE;
    access_mgmt_params_t     *p_access_mgmt_params = RRM_PNULL;
    U8 num_connected_non_csg_ue = RRM_ZERO;
    U8 num_connected_csg_ue = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    rrm_get_csg_non_csg_ues(&num_connected_csg_ue,&num_connected_non_csg_ue,p_ue_context->cell_index);
    p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(p_ue_context->cell_index);
    /*hold the UE if max_num_ue is reached and if the ue is emergency
      or max_csg_member is set as -1*/
    /* SPR 17564 Fix Start */
    if (RRM_TRUE == rrm_is_ue_special_previledge(p_ue_context))
    /* SPR 17564 Fix End */
    {
            p_ue_context->rrm_ue_in_hold = RRM_TRUE;
            ret_val = RRM_SUCCESS;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "UE kept in hold, preemption will be done from "
                    "non_csg/csg UEs during bearer setup");
    }
    else if((p_access_mgmt_params->max_csg_members == RRM_INDEX_ERR) &&
          num_connected_csg_ue < rrm_get_max_allowed_user(p_ue_context->cell_index))
    {
        p_ue_context->rrm_ue_in_hold = RRM_TRUE;
        ret_val = RRM_SUCCESS;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "UE kept in hold, preemption will be done from "
            "non_csg/csg UEs during bearer setup");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/*CID 54940 Start*/
/*SPR_15323 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_process_ue_admission_req 
 *   DESCRIPTION:
 *       Process the UE admission request from RRC
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_rrc_process_ue_admission_req(
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_global_context_t *p_rrm_ue_glb_ctxt
        )
{
    rrm_return_et 				ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_temp = RRM_PNULL;
    /* SPR 20652 Fix End */
    rrm_ue_rrc_msg_t            rrm_ue_rrc_msg = {RRM_ZERO};
    U8							trans_id = p_rrm_ue_glb_ctxt->trans_id;
    rrm_ue_context_t            *p_ue_context = RRM_PNULL;	
    rrm_uem_s_tmsi_t            s_tmsi = {RRM_ZERO};
    /*csg start*/
    access_mgmt_params_t            *p_access_mgmt_params = RRM_PNULL;
    /*csg end*/
    rrm_bool_et                 is_new_context = RRM_FALSE;
    /*SPR 15439 Fix Start*/
    rrc_ue_adm_resp_fail_cause_et   ue_adm_fail_cause = FAIL_CAUSE_UNSPECIFIED;
    /*SPR 15439 Fix End*/


    RRM_UT_TRACE_ENTER();

    ret_val = rrm_ue_rrc_parse_ue_admission_req(p_api_buf,
         /*SPR 17777 +-*/
            data_len,
            &rrm_ue_rrc_msg,
            s_tmsi);

    if ( RRM_SUCCESS == ret_val )
    {
        /* SPR 21251 Start */
        SET_CELL_AND_UE_INDEX(rrm_ue_rrc_msg.cell_index, rrm_ue_rrc_msg.ue_index);
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"RRC->RRM:RRC_RRM_UE_ADMISSION_REQ [UE:%d] successfully parsed",
                rrm_ue_rrc_msg.ue_index);
        /* SPR 21251 End */
        /** Find the UE context */
        p_temp = rrm_ue_find_context(rrm_ue_rrc_msg.ue_index,
                rrm_ue_rrc_msg.cell_index);
        if ( RRM_PNULL == p_temp ) /*UE Doesn't exist, 
                                     Proceed to create one*/
            {
            /* SPR 20652 Fix Start */
            if (RRM_SUCCESS == rrm_ue_get_new_context(
              rrm_ue_rrc_msg.ue_index,
                        rrm_ue_rrc_msg.cell_index,
                        &p_ue_context))
                /* SPR 20652 Fix End */
        {
            is_new_context = RRM_TRUE;
            /*SPR_17047_START*/	 
            p_ue_context->meas_gap_sent_status = RRM_SET_INVALID; 
            /*SPR_17047_END*/	  
            p_ue_context->ue_index = rrm_ue_rrc_msg.ue_index;
            p_ue_context->cell_index = rrm_ue_rrc_msg.cell_index;
            p_ue_context->establishment_cause =  *((rrm_ue_establishment_cause_et*)
                    rrm_ue_rrc_msg.p_msg_data);
                /* SPR 21496 Fix Start */ 
                /* Code removed */
                /* SPR 21496 Fix End */ 

            /* Start: Enh 317 */
            rrm_uem_init_meas_config_struct(p_ue_context);
            /* End: Enh 317 */

            p_ue_context->ul_sch_config.retx_bsr_timer_present = RRM_ZERO;

            /* SPR 9948 fix start */
            /* Assigning the maximum value at the start */
            p_ue_context->ul_sch_config.retx_bsr_timer_past = RRC_RETX_BSR_TIMER_SF_10240;
            /* SPR 9948 fix end */

            /* Fix for CSR: 00059124 */
            /* SPR 12973 Start */
            p_ue_context->cdrx_status = RRM_UE_CDRX_DISABLED;
            /* SPR 12973 End */
            /* Fix for CSR: 00059124 */

            /* Fix for CSR 58972 start*/
            p_ue_context->pci_for_which_cgi_required     = INVALID_PHYSICAL_CELL_ID;
            /* SPR 16406 18sep Start */
            /* Code Removed */
            /* SPR 16406 18sep End */
            /* Fix for CSR 58972 end*/

            p_ue_context->srb_allocated                  = RRM_FALSE;

#ifdef ENDC_ENABLED
/* NR_BAND_FIX_START */
            /* Initialize ENDC data */
            RRM_MEMSET(&(p_ue_context->rrm_endc_nr_data),RRM_ZERO,
                          sizeof(rrm_endc_nr_data_t));
            RRM_MEMSET(p_ue_context->nr_band_bitmap_fdd,RRM_ZERO,
                         (sizeof(U64) * MAX_NR_FREQ_BANDS_OCT));
            RRM_MEMSET(p_ue_context->nr_band_bitmap_tdd,RRM_ZERO,
                         (sizeof(U64) * MAX_NR_FREQ_BANDS_OCT));
            RRM_MEMSET(&(p_ue_context->short_drx),RRM_ZERO,
                         sizeof(rrc_short_drx_t));
            RRM_MEMSET(&(p_ue_context->long_drx_cycle_start_offset_r15),RRM_ZERO,
                         sizeof(rrc_long_drx_cycle_start_offset_r15_t));
            RRM_MEMSET(&(p_ue_context->allowed_bc_list_mrdc),RRM_ZERO,
                         sizeof(band_combination_index_list_t));
            p_ue_context->is_sgnb_param_reqd = RRM_FALSE;
            p_ue_context->split_bearer_threshold_exceed_count = RRM_ZERO;
            p_ue_context->split_bearer_threshold_not_exceed_count = RRM_ZERO;
            p_ue_context->is_drx_configured = RRM_FALSE;
            p_ue_context->is_short_drx_configured = RRM_FALSE;
            p_ue_context->rrm_endc_nr_data.mrdc_capability_valid = RRM_FALSE;
/* NR_BAND_FIX_END */
#endif
         
            /*DYNAMIC ICIC START*/
            /*
             ** Initialze the Dynamic ICIC data , at UE admission request
             ** -- initialize UE's position as CE
             ** -- initialize the time UE was last re-configured as ZERO
             */
            /* Location change fix in UE RECONFIG*/
            if(RRM_UE_POSITION_AT_CELL_EDGE == rrm_cellm_get_initial_ue_loc_configured_in_cell(p_ue_context->cell_index))
            {
                    /* SPR 21251 +- */
                /* Coverity_ID : 41578 */
                if (((ICIC_SCHEME_FFR == (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))) ||
                            (ICIC_SCHEME_SFR == (rrm_cellm_get_icic_scheme_configured_in_cell(p_ue_context->cell_index))))  
                        &&
                        (RRM_TRUE == rrm_cellm_ce_partition_configured_in_cell(p_ue_context->cell_index)))
                {
                    /* SPR 18891 Fix Start */
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                            "Initial Configured UE location : Cell Edge\n"
                            " ICIC configuration : supports\n "
                            "initial UE location : Cell Edge ");
                    p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position = RRM_UE_POSITION_AT_CELL_EDGE;  
                    p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position = RRM_UE_POSITION_AT_CELL_EDGE;
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                            "Initial Configured UE location : Cell Edge\n"
                            "ICIC configuration : Does not support it\n"
                            "initial UE location : Cell Center ");
                    p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position = RRM_UE_POSITION_AT_CELL_CENTER;  
                    p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position = RRM_UE_POSITION_AT_CELL_CENTER;
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                        "Initial Configured UE location : Cell Center");
                /* SPR 18891 Fix End */
                p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position = RRM_UE_POSITION_AT_CELL_CENTER;  
                p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position = RRM_UE_POSITION_AT_CELL_CENTER;
            }
            /*Location change fix in UE RECONFIG*/
            /*Coverity_fix_start_54940*/ 
            p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_time_ue_reconfigured.sec = RRM_ZERO;
            p_ue_context->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.last_time_ue_reconfigured.msec = RRM_ZERO;
            p_ue_context->dynamic_icic_info.location_update_req_for_ue_reconfig = RRM_FALSE;
            /* SPR_8315_PART2_FIX_START */
            p_ue_context->srs_params.srs_res_type = RRM_UE_SRS_TYPE_UNDEF; 
            p_ue_context->srs_params_last_used.srs_res_type = RRM_UE_SRS_TYPE_UNDEF; 
            /* SPR_8315_PART2_FIX_END */

            /* SPR 10450 Fix Start */
            p_ue_context->applied_drx_config.num_of_released_erab =  RRM_ZERO;
            /* SPR 10450 Fix Start */

            /*DYNAMIC ICIC END*/
            p_rrm_ue_glb_ctxt->p_ue_context = p_ue_context;
            RRM_STRNCPY(p_rrm_ue_glb_ctxt->p_ue_context->ue_s_tmsi,s_tmsi,
                    RRM_UEM_S_TMSI_SIZE);


            p_ue_context->ue_release_cause = RRM_UE_REL_CAUSE_UNDEFINED;
            switch (rrm_cellm_ue_admission_allowed(rrm_ue_rrc_msg.cell_index))
            {
                case RRM_ALL_CALLS:
                ret_val = RRM_SUCCESS;
                break;

                case RRM_EMRGCY_CALLS:
                /* SPR 17564 Fix Start */
                ret_val = rrm_ue_emergency_establishment_operation(p_ue_context,
                        /* SPR 17564 Fix End */
                        trans_id,p_rrm_ue_glb_ctxt->p_ue_context->cell_index);
                break;

                case RRM_PRIVILEGE_CALLS:
                /* SPR 17564 Fix Start */
                if (RRM_TRUE == rrm_is_ue_special_previledge(p_ue_context))
                    /* SPR 17564 Fix End */
                {
                    ret_val = RRM_SUCCESS;
                }
                else
                {
                    ret_val = RRM_FAILURE;
                }
                break;

                default:
                {
                    ret_val = RRM_FAILURE;
                }
                break;
            }
            /*Coverity_fix_end_54940*/
            if (RRM_SUCCESS == ret_val)
            {
                if(RRM_TRUE == rrm_cellm_is_rac_enabled(p_rrm_ue_glb_ctxt->p_ue_context->cell_index))
                {
                    /* Perform RAC on UE Admission, here reserved resources factor would be considered */
                    ret_val = rrm_ue_rac_srb_for_new_users(p_rrm_ue_glb_ctxt->p_ue_context);
                        if(RRM_SUCCESS != ret_val)
                        {
                            /*SPR 15439 Fix Start*/
                            ue_adm_fail_cause = FAIL_CAUSE_CONGESTION;
                            /*SPR 15439 Fix End*/
                        }
                }
                else
                {
#ifdef RRM_UT_FLAG
                    /* This flag will ensure that neither the UE count nor the PUCCH resources has to be freed */
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F);
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F_rac_disabled);
#endif                
                    ret_val	= RRM_FAILURE;
                }

                /*csg start*/
                /*if max ue is attached
                  1) If ue is emergency we shall keep ue in hold.
                  2) If max_csg_member is set as -1 and all UEs are not
                  attached as csg_member we shall keep UE in hold*/
                p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(p_ue_context->cell_index);
                if ( (RRM_PNULL != p_access_mgmt_params) && 
                        (p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_HYBRID) &&
                        /* SPR 17564 Fix Start */
                        (RRM_TRUE == rrm_is_ue_special_previledge(p_ue_context)))
                    /* SPR 17564 Fix End */
                {
                    if(ret_val == RRM_FAILURE)
                    {
                        /* CSR-00058598 and SPR-837-fix start*/
                        /*
                         ** RRM is holding the UE in Hybrid mode because RRM dont know yet whether
                         ** the UE is a CSG or a non-CSG. RRM will get to know that at the time of ERB
                         ** setup request and then RRM decide whether to release a low priority CSG UE or a NON-CSG UE.
                         */
                        /* CSR-00058598 and SPR-837-fix end */
                        ret_val = rrm_hold_ue(p_ue_context);
                        /*SPR 15439 Fix Start*/
                        if(ret_val == RRM_FAILURE)
                        {
                            ue_adm_fail_cause = FAIL_CAUSE_CONGESTION;
                        }
                        /*SPR 15439 Fix End*/
                    }
                }
                /*bug 794 start*/
                else
                {
                    if(ret_val == RRM_FAILURE)
                    {
                        /* SPR 17564 Fix Start */
                        ret_val = rrm_ue_emergency_establishment_operation(p_ue_context,
                                /* SPR 17564 Fix End */
                                trans_id,p_rrm_ue_glb_ctxt->p_ue_context->cell_index);
                        /*SPR 15439 Fix Start*/
                        if(ret_val == RRM_FAILURE)
                        {
                            ue_adm_fail_cause = FAIL_CAUSE_CONGESTION;
                        }
                        /*SPR 15439 Fix End*/
                    }
                }
                /*bug 794 end*/
                /*csg end*/

                if( RRM_SUCCESS == ret_val )
                {
                    ret_val = rrm_ue_assign_srb_params(p_rrm_ue_glb_ctxt->p_ue_context);
                    if(RRM_SUCCESS == ret_val)
                    {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                                    "[UE:%d],SRB params assigned for the UE" ,rrm_ue_rrc_msg.ue_index );
#ifdef RRM_UT_FLAG
                        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_S);

                        /*SPR 15439 Fix Start*/
                        ue_adm_fail_cause = FAIL_CAUSE_UNSPECIFIED;
                        /*SPR 15439 Fix End*/

#endif                      
                        /*SPR 15439 Fix Start - Last parameter added*/ 
                        ret_val = rrm_build_and_send_ue_admission_resp(
                                &rrm_ue_rrc_msg, 
                                RRM_UE_SUCCESS, 
                                p_rrm_ue_glb_ctxt->p_ue_context, 
                                trans_id, ue_adm_fail_cause);
                        /*SPR 15439 Fix End*/

                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                                    "[UE:%d], Unable to assign SRB params for the UE", rrm_ue_rrc_msg.ue_index);
                            /*SPR 15439 Fix Start*/
                            ue_adm_fail_cause = FAIL_CAUSE_CONGESTION;
                            /*SPR 15439 Fix End*/
                        }
                    }
                    else
                    {
                        /* This else block hits only if RAC is unsuccessful */
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "[UE:%d],RAC unsuccessful for the UE", rrm_ue_rrc_msg.ue_index);
                    }
                }
                else
                {
                    p_ue_context->ue_release_cause = RRM_UE_REL_CAUSE_CONGESTION;
                    /*SPR 15439 Fix Start*/
                    ue_adm_fail_cause = FAIL_CAUSE_CONGESTION;
                    /*SPR 15439 Fix End*/
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,\
                            "[UE:%d],Cell is not in state to allow UE Admission",rrm_ue_rrc_msg.ue_index);
#ifdef RRM_UT_FLAG
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F);
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F_admission_not_alwd);
#endif                
                }
            }
            else
            {
                /*Unable to get context*/
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                        "[UE:%d],Failed to create new UE_CONTEXT",rrm_ue_rrc_msg.ue_index);
#ifdef RRM_UT_FLAG
                RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F);
                RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F_admission_not_alwd);
#endif                
                ret_val = RRM_FAILURE;
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d],Received Admission request for existing UE", rrm_ue_rrc_msg.ue_index); 
#ifdef RRM_UT_FLAG
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F);
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F_new_context);
#endif                
            ret_val = RRM_FAILURE;
        }
        /* SPR 20742 start */
        /* Code removed */
        /* SPR 20742 end */
        if(RRM_FAILURE == ret_val)
        {
            /*SPR-687 Fix Starts*/
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                    "[UE:%d],Sending UE ADMISSION RESPONSE with response failure", rrm_ue_rrc_msg.ue_index);
            /*SPR 15439 Fix Start - Last parameter added*/
            ret_val = rrm_build_and_send_ue_admission_resp(
                    &rrm_ue_rrc_msg, 
                    RRM_UE_FAILURE, 
                    p_rrm_ue_glb_ctxt->p_ue_context, 
                    trans_id, ue_adm_fail_cause);
            /*SPR 15439 Fix End*/

            if(is_new_context)
            {
                if(RRM_FAILURE == rrm_ue_delete_context(
                            rrm_ue_rrc_msg.cell_index, 
                            rrm_ue_rrc_msg.ue_index))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "[UE:%d], Failed to delete ue context for the UE" ,
                            rrm_ue_rrc_msg.ue_index);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "[UE:%d], successfully deleted ue context for the UE",
                            rrm_ue_rrc_msg.ue_index);
                }
            }

            ret_val = RRM_FAILURE;
            /*SPR-687 Fix Ends*/
        }
    }
    else {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                "[UE:%d],Sending UE ADMISSION RESPONSE with response failure", rrm_ue_rrc_msg.ue_index); 
#ifdef RRM_UT_FLAG
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F);
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_resp_F_parse_err);
#endif                
    }
    rrm_mem_free(rrm_ue_rrc_msg.p_msg_data);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR_15323 end*/
/*CID 54940 End*/
/* RACH_OPTIMIZATION_CHANGES_START */

/******************************************************************************
 *   FUNCTION NAME: post_stored_data_to_son
 *   DESCRIPTION:
 *       Send UE report data to MIF.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
post_stored_data_to_son
(
 rrm_ue_global_context_t     *p_rrm_glb_ctxt,
 /* SPR 20439 Fix Start */
 rrm_cell_index_t cell_index
 /* SPR 20439 Fix End */
 )
{
    rrmuem_rmif_ue_rach_report_t      *p_ue_rach_report  = RRM_PNULL;
    rrm_ue_rach_info_list_t           *p_rach_info_list = RRM_PNULL;
    U16                               index = RRM_ZERO;
    U8                                count = RRM_ZERO;
    rrm_return_et                     ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    p_ue_rach_report = (rrmuem_rmif_ue_rach_report_t *)rrm_mem_get
        (sizeof(rrmuem_rmif_ue_rach_report_t));

    /* coverity  : CID 41507 */
    if( RRM_NULL != p_ue_rach_report )
    {
        RRM_MEMSET(p_ue_rach_report, RRM_NULL, sizeof(rrmuem_rmif_ue_rach_report_t));
        /* SPR 20439 Fix Start */
        p_ue_rach_report->cell_index = cell_index;
        /* SPR 20439 Fix End */
        p_ue_rach_report->count = ylCount(&(p_rrm_glb_ctxt->
                                  rrm_uem_rach_info_data.rach_report_list));

        while(RRM_PNULL != (p_rach_info_list = (rrm_ue_rach_info_list_t *)ylPopTail
                     (&(p_rrm_glb_ctxt->rrm_uem_rach_info_data.rach_report_list))))
        {
            p_ue_rach_report->rach_data[index].cause =
            p_rach_info_list->ue_rach_info.cause;
            p_ue_rach_report->rach_data[index].number_of_preambles_sent = 
            p_rach_info_list->ue_rach_info.number_of_preambles_sent;
            p_ue_rach_report->rach_data[index].contention_detected = 
            p_rach_info_list->ue_rach_info.contention_detected;

            switch(p_rach_info_list->ue_rach_info.ue_location)
            {
                case RRM_UE_POSITION_AT_CELL_CENTER:
                p_ue_rach_report->rach_data[index].ue_location = cell_centre;
                break;

                case RRM_UE_POSITION_AT_CELL_EDGE:
                p_ue_rach_report->rach_data[index].ue_location = cell_edge;
                break;

                case RRM_UE_POSITION_FRM_CE_to_CC:
                /*Do nothing*/
                break;

                case RRM_UE_POSITION_FRM_CC_to_CE:
                /*Do nothing*/
                break;

                default:
               /* SPR 20439 Fix Start */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "Invalid value for \
                            UE location");
               /* SPR 20439 Fix End */

            }
            p_ue_rach_report->rach_data[index].strong_cell_info_count = 
            p_rach_info_list->ue_rach_info.strong_cell_count;

            for(count = RRM_ZERO; count < p_ue_rach_report->rach_data[index].
                strong_cell_info_count; count++)
            {
                p_ue_rach_report->rach_data[index].strong_cell_info[count].pci = 
                p_rach_info_list->ue_rach_info.strong_cell_info[count].pci;
                p_ue_rach_report->rach_data[index].strong_cell_info[count].rsrp =
                p_rach_info_list->ue_rach_info.strong_cell_info[count].rsrp;
            }

            index++;

            RRM_MEM_FREE(p_rach_info_list);
        }
        /* Releasing Remaining from the list if any */
        while (RRM_PNULL != (p_rach_info_list = (rrm_ue_rach_info_list_t *)ylPopTail
                (&(p_rrm_glb_ctxt->rrm_uem_rach_info_data.rach_report_list))))
        {
            RRM_MEM_FREE(p_rach_info_list);
        }
        /* SPR 20527 Fix Start */
        /* Code Deleted */
        /* SPR 20527 Fix End */
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Sending UE report data to SON via MIF");

        if (RRM_FAILURE == rrm_uem_send_internal_msg(RRM_MIF_MODULE_ID,
            RRMUEM_RMIF_RACH_REPORT,
            sizeof(rrmuem_rmif_ue_rach_report_t),
            p_ue_rach_report))
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"RRM send to MIF failed"); /* Coverity : CID 41375 */
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR ,
        "Null pointer exception, could not allocate memory for p_ue_rach_report ");
        ret_val = RRM_FAILURE;
    }

    /* COVERITY : RESOURCE LEAK : CID : 54368 fix start */
    if( RRM_NULL != p_ue_rach_report )
        RRM_MEM_FREE(p_ue_rach_report);
    /* COVERITY : RESOURCE LEAK : CID : 54368 fix end */
    /*Coverity_fix_start_54942*/
    RRM_UT_TRACE_EXIT();
    /*Coverity_fix_end_54942*/
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: store_rach_info_in_global_list
 *   DESCRIPTION:
 *       Stores RACH info from temp context to global context.
 *   RETURNS: NONE
 ******************************************************************************/
void
store_rach_info_in_global_list
(
 rrm_ue_global_context_t     *p_rrm_glb_ctxt,
 rrm_ue_context_t            *p_ue_ctxt,
 rrm_bool_et                 strong_cell_info_reqd,
 /*BUG_965_CHANGES_START*/
 U8                          count
 /*BUG_965_CHANGES_END*/
 )
{
    rrm_ue_rach_info_list_t     *p_rach_info_list = RRM_PNULL;
    U8                           index    = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* coverity : CID 41510 :*/
    if(RRM_TRUE == p_rrm_glb_ctxt->rrm_uem_rach_info_data.
            is_ue_rach_report_active)
    {
        /* Coverity fix 54381 */
        p_rach_info_list = (rrm_ue_rach_info_list_t *)rrm_mem_get
            (sizeof(rrm_ue_rach_info_list_t));
        if( RRM_NULL != p_rach_info_list )
        {
            p_rach_info_list->ue_rach_info.cause = 
                p_ue_ctxt->temp_rach_data.cause;
            p_rach_info_list->ue_rach_info.number_of_preambles_sent = 
                p_ue_ctxt->temp_rach_data.number_of_preambles_sent;
            /*CID 97150 Start*/
            p_rach_info_list->ue_rach_info.contention_detected = 
              (rrm_bool_et)p_ue_ctxt->temp_rach_data.contention_detected;
            /*CID 97150 End*/
            /* SPR-19276 START */
            p_rach_info_list->ue_rach_info.ue_location = rrm_get_ue_location(p_ue_ctxt);
            /* SPR-19276 END */
            /*BUG_965_CHANGES_START*/
            p_rach_info_list->ue_rach_info.strong_cell_count =
                count;
            /*BUG_965_CHANGES_END*/

            if(RRM_TRUE == strong_cell_info_reqd)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Strongest cell info being provided, so storing that also");
                for(index=RRM_ZERO; index < count; index++)
                {
                    p_rach_info_list->ue_rach_info.strong_cell_info[index].pci = 
                        p_ue_ctxt->temp_rach_data.strong_cell_info[index].pci;
                    p_rach_info_list->ue_rach_info.strong_cell_info[index].rsrp =
                        p_ue_ctxt->temp_rach_data.strong_cell_info[index].rsrp;
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Strongest cell info not required");
            }
            /*Cov_fix_start_64537*/

            /*storing data in the list*/
            ylPushTail(&(p_rrm_glb_ctxt->rrm_uem_rach_info_data.rach_report_list), 
                    &p_rach_info_list->pNode);

            /*If number of reports have reached maximum rach sample count then 
              empty the list and send back the data to SON */
            if(ylCount(&(p_rrm_glb_ctxt->rrm_uem_rach_info_data.rach_report_list)) >= 
                    (p_rrm_glb_ctxt->rrm_uem_rach_info_data.rach_sample_count))
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Number of \
                        reports have reached maximum limit of sample count, so posting data \
                        to SON and setting ue_rach_report_active as FALSE, so that no more reports \
                        are requested for this particular duration");
                /*Flag will be set to TRUE when UE rach report timer expires to start 
                  collection for next timer duration*/

        /* SPR 20527 Fix Start */
        p_rrm_glb_ctxt->rrm_uem_rach_info_data.is_ue_rach_report_active = RRM_FALSE;
        /* SPR 20527 Fix End */
/* SPR 20439 Fix Start */
                post_stored_data_to_son(p_rrm_glb_ctxt, p_ue_ctxt->cell_index);
/* SPR 20439 Fix End */
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR ,
                    "Null pointer Exception, Memory allocataion failed ");
        }
        /*Cov_fix_end_64537*/
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_process_ue_info_resp
 *   DESCRIPTION:
 *       Process the UE info resp.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_rrc_process_ue_info_resp
(
 U8 *p_api_buf,
         /*SPR 17777 +-*/
 U16 data_len,
 rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg,
 rrm_ue_global_context_t     *p_rrm_glb_ctxt
 )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    rrm_ue_info_resp_t          *p_rrm_ue_info_res = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    ret_val = rrm_ue_rrc_parse_ue_info_resp(
            p_api_buf,
         /*SPR 17777 +-*/
            data_len,
            /* coverity_54424_fix: Start */
            p_rrm_ue_rrc_msg);
            /* coverity_54424_fix: End */
    if(ret_val == RRM_SUCCESS)
    {
        /* SPR 21251 Start */
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->RRM:RRC_RRM_UE_INFORMATION_RESP [UE:%d] successfully parsed", p_rrm_ue_rrc_msg->ue_index);
        
        /* SPR 21251 End */
        /*Find UE context*/
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(p_rrm_ue_rrc_msg->ue_index,
                p_rrm_ue_rrc_msg->cell_index);
        if(RRM_PNULL != p_ue_context)
        {
            p_rrm_ue_info_res = (rrm_ue_info_resp_t *)p_rrm_ue_rrc_msg->p_msg_data;
            /*need to process the report if report timer is running (checked with flag),
              UE info res from RRC contains RACH data and ue report has 
              been requested from this particular UE*/
            if((p_rrm_glb_ctxt->rrm_uem_rach_info_data.is_ue_rach_report_active == RRM_TRUE)
                    && (p_rrm_ue_info_res->bitmask & RRM_UE_RACH_INFO_PRESENT) && 
                    (p_ue_context->temp_rach_data.is_ue_report_requested == RRM_TRUE))
            {
                p_ue_context->temp_rach_data.number_of_preambles_sent = 
                    p_rrm_ue_info_res->number_of_preambles_sent;
                p_ue_context->temp_rach_data.contention_detected = 
                    p_rrm_ue_info_res->contention_detected;

                if(p_rrm_ue_info_res->number_of_preambles_sent == RRM_ONE)
                {
                    /*As data has been stored so setting flag to FALSE*/
                    p_ue_context->temp_rach_data.is_ue_report_requested = RRM_FALSE;

                    /*As number of preambles sent are 1, so no strongest cell
                      information is to be provided*/
                      /*BUG_965_CHANGES_START*/
                      /*As no strongest cell information is to be sent so count (last argument)
                        should be sent as ZERO*/
                    store_rach_info_in_global_list(p_rrm_glb_ctxt, p_ue_context, 
                            RRM_FALSE, RRM_ZERO);
                      /*BUG_965_CHANGES_END*/
                }
                else if(p_rrm_ue_info_res->number_of_preambles_sent > RRM_ONE)
                {
                    /* If meas config request has already been sent for a UE for any reason,
                     * then enqueue the ESMLC request which will be dequeued later on once
                     * meas config response comes */
                    if(RRM_MEAS_CONFIG_REQ_SENT == p_ue_context->meas_status)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                                "Meas config req has already been sent for the [UE:%d], so enqueue the message" , 
                                p_ue_context->ue_index);

                        rrm_ue_procedure_queue_t    proc_queue;
                        proc_queue.api_id = p_rrm_glb_ctxt->api_id;
                        /* SPR 15441 start */
                        proc_queue.p_proc_data = (rrm_void_t *)(p_rrm_ue_rrc_msg->p_msg_data);
                        /* SPR 15441 end */
                        /*BUG 13332:start*/
                        proc_queue.trans_id = p_rrm_glb_ctxt->trans_id;
                        /*BUG 13332:end*/


                        /* Enqueue the request, reusing the code of ESMLC */
                        /* SPR 20076 Fix Start */
                        rrm_ue_mgr_enqueue_esmlc_meas_req(&proc_queue, 
                                p_ue_context);
                        /* SPR 20076 Fix End */

                    }
                    else
                    {
                        /*Send  meas_config_req and is_ue_report_requested flag would be 
                          set to FALSE when measurement result ind is received*/
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                                "Sending meas_config_req periodically (once) to request \
                                strongest cell information");
                        ret_val = rrm_build_and_send_meas_config_req_for_ue_positioning
                            (p_ue_context,
                             RRM_MAX_ESMLC_MEAS_ID - RRM_ONE,
                             RRM_LPPA_MS120/*report interval*/,
                             RRM_LPPA_ONDEMAND/*report type*/,
                             RRM_UE_POS_TRIGGER_QTY_RSRP/*quantity bitmask*/,
                             RRM_TRUE /*defines if request is for rach or ue_positioning*/);

                        /* SPR 15797 Start */

                        if(RRM_FAILURE == ret_val)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                    "Failure returned for UE meas config request for [UE:%d]",
                                    p_ue_context->ue_index);
                        }
                        else
                        {
                            p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;
                            p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING; 
                        }
                        /* SPR 20652 Fix End */
                        /* SPR 15797 End */
                    }

                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                            "No preamble count present in UE INFORMATION RESPONSE message, so not collecting the report");
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "No RACH information recieved in UE information response message from RRC");
            }

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "UE context not found");
            ret_val = RRM_FAILURE;
        }
        /* Coverity fix 54379 start */
        /* SPR 15441 start */
        if (RRM_PNULL != p_rrm_ue_rrc_msg->p_msg_data)
        {
            RRM_MEM_FREE(p_rrm_ue_rrc_msg->p_msg_data);
        }
        /* SPR 15441 end */
        /* Coverity fix 54379 end */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->RRM:RRC_RRM_UE_INFORMATION_RESP parsing failed");
        ret_val = RRM_FAILURE;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR_16053_Fix: Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_process_ue_reestab_complete_ind
 *   DESCRIPTION:
 *       Process the UE re-establishment message.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_rrc_process_ue_reestab_complete_ind
(
 U8 *p_api_buf,
         /*SPR 17777 +-*/
 U16 data_len,
 rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
         /*SPR 17777 +-*/
 )
{
    rrm_return_et               ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    ret_val = rrm_ue_rrc_parse_ue_reestab_complete_ind(
            p_api_buf,
         /*SPR 17777 +-*/
            data_len,
            p_rrm_ue_rrc_msg);
    if(ret_val == RRM_SUCCESS)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Successful to parse RRC_RRM_UE_REESTABLISHMENT_IND");
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Failed to parse RRC_RRM_UE_REESTABLISHMENT_IND");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR_16053_Fix: End */

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_process_ue_reestab_config_req
 *   DESCRIPTION:
 *       Process the UE re-establishment message.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_rrc_process_ue_reestab_config_req
(
 U8 *p_api_buf,
         /*SPR 17777 +-*/
 U16 data_len,
 rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg,
 rrm_ue_global_context_t     *p_rrm_glb_ctxt
 )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */

    RRM_UT_TRACE_ENTER();
    ret_val = rrm_ue_rrc_parse_ue_reestab_config_req(
            p_api_buf,
         /*SPR 17777 +-*/
            data_len,
            /* coverity_54424_fix: Start */
            p_rrm_ue_rrc_msg);
            /* coverity_54424_fix: End */
    if(ret_val == RRM_SUCCESS)
    {
        /* SPR 21251 Start */
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        /* SPR 21251 End */
        /*Find UE context*/
        /* SPR 20652 Fix Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->RRM:RRC_RRM_UE_REESTAB_CONFIG_REQ [%d] successfully parsed", p_rrm_ue_rrc_msg->ue_index);
        p_ue_context = rrm_ue_find_context(p_rrm_ue_rrc_msg->ue_index,
                p_rrm_ue_rrc_msg->cell_index);
        if(RRM_PNULL != p_ue_context)
        {
            if(RRM_TRUE == p_rrm_glb_ctxt->rrm_uem_rach_info_data.
                    is_ue_rach_report_active) 
            {
                /* SPR-18787 START */
                if((RRM_REL9 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                         eutra_radio_capability_info_def.access_stratum_release) && \
                        (rrm_is_set_fgi_bit(p_ue_context, RRM_SIXTEEN)))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Sending UE Info req to RRC as UE_REESTABLISHMENT_CONFIG_REQ "
                            "has been received");
                    build_and_send_ue_info_req_to_rrc(p_ue_context, RRC_RE_ESTABLISHMENT_UE );
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, \
                            "[UE:%d] has accessStratumRelease less than release9 or FGI bit 16 is not set. "
                            "Not sending UE Info req as conditions not met. access_stratum_release = %d",\
                            p_ue_context->ue_index,\
                            p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                            eutra_radio_capability_info_def.access_stratum_release);
                }
                /* SPR-18787 END */

            }
            /*CA code removed */
        }
        /* SPR 20652 Fix End */
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "UE context not found");
            ret_val = RRM_FAILURE;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->RRM:RRC_RRM_UE_REESTAB_CONFIG_REQ parsing failed");
        ret_val = RRM_FAILURE;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_rrc_process_ue_sync_status
 *   DESCRIPTION:
 *       Process the UE inactivity indication.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_rrc_process_ue_sync_status
(
 U8 *p_api_buf,
         /*SPR 17777 +-*/
 U16 data_len,
 rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg,
 rrm_ue_global_context_t     *p_rrm_glb_ctxt
 )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
/* SPR 12512 Fix Start */
/* SPR 12512 Fix End */

    RRM_UT_TRACE_ENTER();
    ret_val = rrm_ue_rrc_parse_ue_sync_status(
            p_api_buf,
         /*SPR 17777 +-*/
            data_len,
/* SPR 12512 Fix Start */
            p_rrm_ue_rrc_msg);
/* SPR 12512 Fix End */
    if(ret_val == RRM_SUCCESS)
    {
        /* SPR 21251 Start */
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->RRM:RRC_RRM_UE_SYNC_STATUS [UE:%d] successfully parsed", p_rrm_ue_rrc_msg->ue_index);
        /* SPR 21251 End */
        /*Find UE context*/
/* SPR 12512 Fix Start */
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(p_rrm_ue_rrc_msg->ue_index,
                p_rrm_ue_rrc_msg->cell_index);
        /* SPR 20652 Fix End */
/* SPR 12512 Fix End */
        if(RRM_PNULL != p_ue_context)
        {
            /*value for in_sync coming from RRC is 1*/
            if((RRM_TRUE == p_rrm_glb_ctxt->rrm_uem_rach_info_data.
                        is_ue_rach_report_active) && (*((U32 *)p_rrm_ue_rrc_msg->
                                p_msg_data) == RRM_ONE))
            {
                /* SPR-18787 START */
                if((RRM_REL9 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                         eutra_radio_capability_info_def.access_stratum_release) && \
                        (rrm_is_set_fgi_bit(p_ue_context, RRM_SIXTEEN)))
                {
                    /* coverity : CID 41556 */
                    build_and_send_ue_info_req_to_rrc(p_ue_context, IN_SYNC_IND_UE );
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, \
                            "[UE:%d] has accessStratumRelease less than release9 or FGI bit 16 is not set."\
                            "Not sending UE Info req as conditions not met. access_stratum_release = %d",\
                            p_ue_context->ue_index,\
                            p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                            eutra_radio_capability_info_def.access_stratum_release);
                }
                /* SPR-18787 END */

            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "UE context not found");
            ret_val = RRM_FAILURE;
        }
            
        /* SPR 12512 Fix Start */
        /* Code deleted */
        /* SPR 12512 Fix End */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->RRM:RRC_RRM_UE_SYNC_STATUS parsing failed");
        ret_val = RRM_FAILURE;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_END */
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_process_ue_inactive_ind
 *   DESCRIPTION:
 *       Process the UE inactivity indication.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_rrc_process_ue_inactive_ind
(
    U8 *p_api_buf,
         /*SPR 17777 +-*/
    U16 data_len,
    rrm_ue_global_context_t *p_rrm_glb_ctxt
)
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    rrm_ue_rrc_msg_t 			rrm_ue_rrc_msg = {RRM_ZERO};
    U8                          index = RRM_NULL;
    U16                         trans_id = p_rrm_glb_ctxt->trans_id;

    RRM_UT_TRACE_ENTER();
    ret_val = rrm_ue_rrc_parse_ue_inactive_ind(
              p_api_buf,
         /*SPR 17777 +-*/
              data_len,
              &rrm_ue_rrc_msg);
    if(ret_val == RRM_SUCCESS)
    {
        for (index = RRM_NULL; index < rrm_ue_rrc_msg.num_of_inactive_ue; index++ )
        {
            /*Find UE context*/
            /* SPR 20652 Fix Start */
            p_ue_context = rrm_ue_find_context(rrm_ue_rrc_msg.num_of_inactive_ue_list[index],
                    rrm_ue_rrc_msg.cell_index);
            /* SPR 20652 Fix End */
            if(RRM_PNULL != p_ue_context)
            {
                /*send RRC_RRM_UE_CONNECTION_RELEASE_IND for ue_index found*/
                ret_val = rrm_build_and_send_ue_connection_release_ind(
                        rrm_ue_rrc_msg.num_of_inactive_ue_list[index],
                        RADIO_NETWORK_LAYER_TYPE,
                        USER_INACTIVITY,
                        trans_id,
                        RRM_PNULL,
                        /* SPR_10729_fix */
                        rrm_ue_rrc_msg.cell_index);
                if(ret_val == RRM_FAILURE)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                            "Failed to send release connection ind send for [UE:%d]",
                            rrm_ue_rrc_msg.num_of_inactive_ue_list[index]);
                    ret_val = RRM_FAILURE;
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "send release connection ind send for [UE:%d]",
                            rrm_ue_rrc_msg.num_of_inactive_ue_list[index]);
                    ret_val = RRM_SUCCESS;
                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off,
                                p_g_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "ue_connection_release_ind sent, \
                                Failed to clean up ue resources");
                        ret_val = RRM_FAILURE;

                    }

                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                        "UE context not found");
                ret_val = RRM_FAILURE;
            }
        }
    }
	else
    {
         RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                   "Failed to parse inactive UES ind request\n");
         ret_val = RRM_FAILURE;

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*SPR_15323 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_rrc_process_ho_admission_req
 *   DESCRIPTION:
 *       Process the HO admission request from RRC
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_rrc_process_ho_admission_req(
        U8 *p_api_buf,
        /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_global_context_t *p_rrm_ue_glb_ctxt,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_temp = RRM_PNULL;
    /* SPR 20652 Fix End */
    U8                          trans_id = p_rrm_ue_glb_ctxt->trans_id;
    rrm_ue_context_t            *p_ue_context = RRM_PNULL;
    rrm_response_t              rrm_resp;
    /* CSR 101507 start */
    /* code deleted */
    /* CSR 101507 end */
    /*csg start*/
    access_mgmt_params_t            *p_access_mgmt_params = RRM_PNULL;
    /*csg end*/

    /* CSR-00058598 and SPR-837-fix start*/
    rrm_bool_et      is_request_is_for_emergency_arp = RRM_FALSE;
    /* CSR-00058598 and SPR-837-fix end */

    rrm_bool_et                 is_new_context = RRM_FALSE;
    /* Coverity 99669 Fix Start */
    /*SPR 16609 30 July FIX START*/
    /* SPR 19078: CID 101192 Fix Start */
    rrc_handover_type_et        ho_type = HANDOVER_TYPE_INVALID;
    /* SPR 19078: CID 101192 Fix End */
    /*SPR 16609 30 July FIX END*/
    /* Coverity 99669 Fix End */

    /* SPR 21496 Fix Start */
    S32                         length_read = RRM_NULL;
    rrc_rrm_ue_ho_adm_req_t     *p_rrc_rrm_ho_adm_req = RRM_PNULL;
    admission_control_info_t        *p_admission_control_info = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    p_rrc_rrm_ho_adm_req = (rrc_rrm_ue_ho_adm_req_t*)
                              rrm_mem_get(sizeof(rrc_rrm_ue_ho_adm_req_t));
    if (RRM_PNULL == p_rrc_rrm_ho_adm_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    /**Parse the HO_ADM_REQ */
    if ( RRM_SUCCESS == rrm_il_parse_rrc_rrm_ue_ho_adm_req(
                                p_rrc_rrm_ho_adm_req,
                                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                                data_len,
                                &length_read))
    {
        /* SPR 21496 Fix End */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->RRM:RRC_RRM_UE_HO_ADM_REQ [UE:%d] successfully parsed", p_rrm_ue_rrc_msg->ue_index);

        if(RRM_SUCCESS == rrm_ue_rrc_parse_ho_adm_req(p_rrc_rrm_ho_adm_req,
                    /*SPR 17777 +-*/
                    data_len,
                    p_rrm_ue_rrc_msg))
        {
            /*CID 63834 fix Start */
            if(RRM_PNULL != p_rrm_ue_rrc_msg->p_msg_data)
            {
                /*CID 63834 fix Stop */
                /* SPR 21496 Fix Start */
                p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));

                SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_rrm_ue_rrc_msg->ue_index);

                ho_type = (rrc_handover_type_et) (p_rrc_rrm_ho_adm_req->ho_type);
                /* SPR 21496 Fix End */

            /** Find the UE context */
            p_temp = rrm_ue_find_context(p_rrm_ue_rrc_msg->ue_index,
                    p_rrm_ue_rrc_msg->cell_index);
                if ( RRM_PNULL == p_temp ) /*UE Doesn't exist,
                                             Proceed to create one*/
                    {
                    /* SPR 20652 Fix Start */
                    if (RRM_SUCCESS == rrm_ue_get_new_context(
                            p_rrm_ue_rrc_msg->ue_index,
                                p_rrm_ue_rrc_msg->cell_index,
                                &p_ue_context))
                        /* SPR 20652 Fix End */
            {
                is_new_context = RRM_TRUE;
                /* Start :SPR 9263 */
                p_admission_control_info = rrm_cellm_get_admission_control_info(p_rrm_ue_rrc_msg->cell_index);
                /* End :SPR 9263 */

                p_ue_context->ue_index = p_rrm_ue_rrc_msg->ue_index;
                p_ue_context->cell_index = p_rrm_ue_rrc_msg->cell_index;
                p_ue_context->current_procedure.p_proc_data =
                    (rrm_ue_proc_ho_adm_data_t *)p_rrm_ue_rrc_msg->p_msg_data;
                /*SPR-650 Fix Starts*/

                        /* SPR 21496 Fix Start */
                        if(p_rrc_rrm_ho_adm_req->src_to_trg_container.rrc_radio_capability_info.\
                                bitmask & EUTRA_RADIO_CAPABILITY_PRESENT)
                        {
                            rrm_ue_rrc_parse_ho_adm_req_eutra_radio_capability(p_rrc_rrm_ho_adm_req, p_ue_context);
                        }
                        /* SPR 21496 Fix End */

                /* Start fix for SPR 14987 */
                rrm_uem_init_meas_config_struct(p_ue_context);
                /* End fix for SPR 14987 */

                /*Coverity:62002 Fix-Start */
                        p_ue_context->ho_type = ho_type;

                        /*Coverity:62002 Fix-End */
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                                "Handover %s received", rrm_get_ho_type_string(p_ue_context->ho_type));

                        /* Fix for CSR 58972 start*/
                        /* SPR 16406 18sep Start */
                        /* Code Removed */
                        /* SPR 16406 18sep End */
                        /* Fix for CSR 58972 end*/
                        /*SPR-486 Fix Starts*/
                        p_ue_context->ue_release_cause = RRM_UE_REL_CAUSE_UNDEFINED;
                        /*SPR-486 Fix End*/

                        /* Start :SPR 9263 */
                        if( p_admission_control_info->snr_map.snr_dep_params.
                                uplink_snr_dep_params.bitmask &
                                UPLINK_POW_CONTROL_INFO_SNR_MAP_PRESENT )
                        {
                            p_ue_context->ue_uplink_power_control_dedicated.p0_ue_pusch =
                                p_admission_control_info->snr_map.
                                snr_dep_params.uplink_snr_dep_params.
                                uplink_pow_control.p0_ue_pusch;
                            p_ue_context->ue_uplink_power_control_dedicated.p0_ue_pucch =
                                p_admission_control_info->snr_map.
                                snr_dep_params.uplink_snr_dep_params.
                                uplink_pow_control.p0_ue_pucch;
                        }
                        /* End :SPR 9263 */
                        p_rrm_ue_glb_ctxt->p_ue_context = p_ue_context;
                        /* SPR 16262 Fix Start */
                        p_ue_context->establishment_cause = RRM_UE_INVALID_ESTABLISHMENT_CAUSE;
                        /* CSR 101507 start */
                        if (RRM_SUCCESS == rrm_check_ue_arp_val_for_emergency_ho_admin (p_ue_context))
                        {
                            p_ue_context->establishment_cause = RRM_UE_ESTAB_CAUSE_EMERGENCY;
                            is_request_is_for_emergency_arp = RRM_TRUE;
                        }
                        /* CSR 101507 end */
                        /* SPR 16262 Fix Stop */
                        switch(rrm_cellm_ue_admission_allowed(p_rrm_ue_rrc_msg->cell_index))
                        {
                            case RRM_ALL_CALLS:
                            case RRM_PRIVILEGE_CALLS:
                                ret_val = RRM_SUCCESS;
                                break;

                            case RRM_EMRGCY_CALLS:
                                {
                                    /* CSR-00058598 and SPR-837-fix start*/
                                    /*
                                     ** Check whether received hand-in request is for emergency erab
                                     ** (i.e. requested any erab ARP value is matched with the OAM
                                     ** configured APR value), then RRM will process the Hand-In request.
                                     */
                                    /* CSR 101507 start */
                                    if (RRM_TRUE == is_request_is_for_emergency_arp)
                                    {
                                        if (RRM_SUCCESS  == rrm_ue_emergency_establishment_operation_for_ho (trans_id, p_ue_context->cell_index))
                                        {
                                            ret_val = RRM_SUCCESS;
                                        }
                                        else

                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                                    "[UE:%d], Cell is not in state to allow HO ADM REQ",p_rrm_ue_rrc_msg->ue_index);
                                            ret_val = RRM_FAILURE;
                                            /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE START*/
                                            rrm_raise_event_ho_in_prep_failure(p_ue_context, RRM_EVENT_HANDOVER_TARGET_NOT_ALLOWED);
                                            /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE END*/
                                            /*SPR 16609 FIX START*/
                                            if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                                                    (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                                                    (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
                                            {
                                                rrm_resp.cause.value =  RRM_X2AP_UNSPECIFIED;
                                            }
                                            else
                                            {
                                                rrm_resp.cause.value =  UNSPECIFIED;
                                            }
                                            /*SPR 16609 FIX END*/
                                        }
                                    }
                                    /* CSR 101507 end */
                                    else
                                    {
                                        /* Only emergency calls are allowed hence hand-in
                                         * will not be possible
                                         */
                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                                "[UE:%d], Cell is not in state to allow HO ADM REQ",p_rrm_ue_rrc_msg->ue_index);
                                        ret_val = RRM_FAILURE;
                                        /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE START*/
                                        rrm_raise_event_ho_in_prep_failure(p_ue_context, RRM_EVENT_NUMBER_OF_ACTIVE_USERS_REACHED);
                                        /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE END*/
                                        /*SPR 16609 FIX START*/
                                        if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                                                (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                                                (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
                                        {
                                            rrm_resp.cause.value =  RRM_X2AP_UNSPECIFIED;
                                        }
                                        else
                                        {
                                            rrm_resp.cause.value =  UNSPECIFIED;
                                        }
                                        /*SPR 16609 FIX END*/
                                    }
                                    /* CSR-00058598 and SPR-837-fix end */
                                }
                                break;

                            default:
                                {
                                    /* Only emergency calls are allowed hence hand-in
                                     * will not be possible
                                     */
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                            "[UE:%d], Cell is not in state to allow HO ADM REQ",p_rrm_ue_rrc_msg->ue_index);
                                    ret_val = RRM_FAILURE;
                                    /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE START*/
                                    rrm_raise_event_ho_in_prep_failure(p_ue_context, RRM_EVENT_NUMBER_OF_ACTIVE_USERS_REACHED);
                                    /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE END*/
                                    /*SPR 16609 FIX START*/
                                    if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                                            (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                                            (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
                                    {
                                        rrm_resp.cause.value =  RRM_X2AP_UNSPECIFIED;
                                    }
                                    else
                                    {
                                        rrm_resp.cause.value =  UNSPECIFIED;
                                    }
                                    /*SPR 16609 FIX END*/
                                }
                                break;
                        }
                        /*Rel 10 CR-36423.407 changes*/
                        /* CSR 101507 start */
                        if (RRM_TRUE != is_request_is_for_emergency_arp)
                        {
                            p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(p_ue_context->cell_index);

                            if((RRM_NULL != p_access_mgmt_params) && (p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_HYBRID)
                                    && (!(((rrm_ue_proc_ho_adm_data_t *)p_rrm_ue_rrc_msg->p_msg_data)->bitmask & RRM_HO_ADM_REQ_CSG_MEMBERSHIP_STATUS_PRESENT)))
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                        "[UE:%d], Cell is not in state to allow HO ADM REQ"
                                        " as target cell is of hybrid mode and csg membership status is not present",
                                        p_rrm_ue_rrc_msg->ue_index);
                                ret_val = RRM_FAILURE;
                                /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE START*/
                                rrm_raise_event_ho_in_prep_failure(p_ue_context, RRM_EVENT_HANDOVER_TARGET_NOT_ALLOWED);
                                /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE END*/
                                /*SPR 16609 FIX START*/
                                if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                                        (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                                        (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
                                {
                                    rrm_resp.cause.value =  RRM_X2AP_HO_TARGET_NOT_ALLOWED;
                                }
                                else
                                {
                                    rrm_resp.cause.value = HANDOVER_TARGET_NOT_ALLOWED;
                                }
                                /*SPR 16609 FIX END*/
                            }
                        }
                        /*Rel 10 CR-36423.407 changes*/
                        /* CSR 101507 end */

                        if (RRM_SUCCESS == ret_val)
                        {
                            if(RRM_TRUE == rrm_cellm_is_rac_enabled(p_rrm_ue_glb_ctxt->p_ue_context->cell_index))
                            {
                                /* Perform RAC on HO Admission, here reserved resources factor will not be considered */
                                if(RRM_FAILURE == rrm_ue_rac_srb_for_existing_users(p_rrm_ue_glb_ctxt->p_ue_context))
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                            "[UE:%d],RAC FAILED for the UE" ,p_rrm_ue_rrc_msg->ue_index);
                                    /*SPR 16609 FIX START*/
                                    if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                                            (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                                            (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
                                    {
                                        rrm_resp.cause.value =  RRM_X2AP_NO_RADIO_RESRCS_AVLAL_IN_TRGET_CELL;
                                    }
                                    else 
                                    {
                                        rrm_resp.cause.value =  NO_RADIO_RESOURCES_AVAILABLE_IN_TARGET_CELL;
                                    }
                                    /*SPR 16609 FIX END*/
                                    ret_val = RRM_FAILURE;
                                }
                                else
                                {  
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                                            "[UE:%d],RAC successful for the UE" ,p_rrm_ue_rrc_msg->ue_index);
                                }
                            }
                            else 
                            {
                                /*SPR 16609 FIX START*/
                                if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                                        (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                                        (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
                                {
                                    rrm_resp.cause.value =  RRM_X2AP_UNSPECIFIED;
                                }
                                else
                                {
                                    rrm_resp.cause.value =  UNSPECIFIED;
                                }
                                /*SPR 16609 FIX END*/
                                ret_val = RRM_FAILURE; 
                            }

                            p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(p_ue_context->cell_index);
                            if ( (RRM_PNULL != p_access_mgmt_params) &&
                                    (p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_HYBRID) &&
                                    (RRM_FALSE == is_request_is_for_emergency_arp))
                            {
                                if(ret_val == RRM_FAILURE)
                                {
                                    ret_val = rrm_hold_ue_for_ho(p_ue_context);
                                }
                            }
                            else
                            {
                                /* CSR 101507 start */
                                if ( (ret_val == RRM_FAILURE) && (RRM_TRUE == is_request_is_for_emergency_arp))
                                {
                                    ret_val = rrm_ue_emergency_establishment_operation_for_ho (trans_id, p_ue_context->cell_index);

                                }
                            }
                            if(RRM_SUCCESS == ret_val)
                            {
                                if(RRM_SUCCESS == rrm_ue_assign_srb_params(p_rrm_ue_glb_ctxt->p_ue_context))
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, 
                                            "[UE:%d], SRB params assigned for the UE" ,p_rrm_ue_rrc_msg->ue_index);
                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                            "[UE:%d], Unable to assign SRB params for the UE",
                                            p_rrm_ue_rrc_msg->ue_index);

                                    /* Raising event LOCAL_SRB1_SETUP_REJECT
                                       This shall be triggered in case of a hand-in request arriving at RRM and
                                       if the SRB1 can not be established for the UE due to resource constraint
                                       */
                                    rrm_raise_event_srb1_setup_reject(((rrm_ue_proc_ho_adm_data_t *)p_rrm_ue_rrc_msg->p_msg_data)->ho_type);
                                    /*SPR 17777 +-*/
                                    /*SPR 16609 FIX START*/
                                    if ((HANDOVER_TYPE_INTRA_LTE_X2 == p_ue_context->ho_type) ||
                                            (HANDOVER_TYPE_INTRA_CELL == p_ue_context->ho_type) ||
                                            (HANDOVER_TYPE_INTER_CELL == p_ue_context->ho_type))
                                    {
                                        rrm_resp.cause.value =  RRM_X2AP_UNSPECIFIED;
                                    }
                                    else
                                    {
                                        rrm_resp.cause.value =  UNSPECIFIED;
                                    }
                                    /*SPR 16609 FIX END*/
                                    ret_val = RRM_FAILURE;
                                }
                            }
                            else
                            {

                                /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE START*/
                                rrm_raise_event_ho_in_prep_failure(p_ue_context, RRM_EVENT_NUMBER_OF_ACTIVE_USERS_REACHED);
                                /* Raise Event RRM_EVENT_LOCAL_EVENT_HO_IN_PREP_FAILURE END*/
                                /*SPR 16572 fix start*/
                                //rrm_resp.cause.value =  UNSPECIFIED;
                                /*SPR 16572 fix stop*/
                            }
                        }
                        else
                        {
                            p_ue_context->ue_release_cause = RRM_UE_REL_CAUSE_CONGESTION;
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,\
                                    "[UE:%d],Cell is not in state to allow HO ADM REQ",p_rrm_ue_rrc_msg->ue_index);
                        }
                        /* CSR 101507 end */
                    }
                    else 
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                "[UE:%d], Unable to create Ue context ",p_rrm_ue_rrc_msg->ue_index);
                        /*SPR 16609 30 July FIX START*/
                        if ((HANDOVER_TYPE_INTRA_LTE_X2 == ho_type) ||
                                (HANDOVER_TYPE_INTRA_CELL == ho_type) ||
                                (HANDOVER_TYPE_INTER_CELL == ho_type))
                        {
                            rrm_resp.cause.value =  RRM_X2AP_UNSPECIFIED;
                        }
                        else
                        {
                            rrm_resp.cause.value =  UNSPECIFIED;
                        }
                        /*SPR 16609 30 July FIX END*/
                        ret_val = RRM_FAILURE;
            }
                    }
                    else
                    {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                            "[UE:%d], is already exist for HO_ADM_REQ ",p_rrm_ue_rrc_msg->ue_index);
                    /*SPR 16609 30 July FIX START*/
                    if ((HANDOVER_TYPE_INTRA_LTE_X2 == ho_type) ||
                            (HANDOVER_TYPE_INTRA_CELL == ho_type) ||
                            (HANDOVER_TYPE_INTER_CELL == ho_type))
                    {
                        rrm_resp.cause.value =  RRM_X2AP_UNSPECIFIED;
                    }
                    else
                    {
                        rrm_resp.cause.value =  UNSPECIFIED;
                    }
                    /*SPR 16609 30 July FIX END*/
                    ret_val = RRM_FAILURE;
                }
                if(RRM_FAILURE == ret_val )
                {
                    /*SPR-650 Fix Starts*/
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                            "[UE:%d], Sending HO ADMISSION RESPONSE with response failure ",
                            p_rrm_ue_rrc_msg->ue_index);
                    rrm_resp.response = RRM_UE_FAILURE;
                    rrm_resp.bitmask = RRM_ZERO;
                    rrm_resp.bitmask |= RRM_RESPONSE_CAUSE_PRESENT;
                    rrm_resp.cause.type = RADIO_NETWORK_LAYER_TYPE;

                    ret_val = rrm_build_and_send_ho_adm_resp_failure(rrm_resp,
                            p_rrm_ue_rrc_msg->ue_index,p_rrm_ue_rrc_msg->cell_index, trans_id);
                    /* Coverity Fix 75472 Start */
                    if(RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Failure returned by fuction rrm_build_and_send_ho_adm_resp_failure");
                    }
                    /* Coverity Fix 75472 End */

                    if(is_new_context)
                    {
                        if(RRM_FAILURE == rrm_ue_delete_context(
                                    p_rrm_ue_rrc_msg->cell_index,
                                    p_rrm_ue_rrc_msg->ue_index))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                    "[UE:%d], Failed to delete ue context for the UE" ,p_rrm_ue_rrc_msg->ue_index);
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO, "[UE:%d],successfully deleted ue context for the UE",
                                    p_rrm_ue_rrc_msg->ue_index);
                        }
                    }
                    ret_val = RRM_FAILURE;
                    /*SPR-650 Fix Ends*/
                }
                /*CID 63834 fix Start */
            }
            /*CID 63834 fix Stop */
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "RRC_RRM_UE_HO_ADM_REQ population of parameters failed");
            ret_val = RRM_FAILURE;
        }
        /* SPR 21496 Fix Start */
    }
    else
    {
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
			    "RRC->RRM:RRC_RRM_UE_HO_ADM_REQ parsing failed");
	    ret_val = RRM_FAILURE;
    }
    RRM_MEM_FREE(p_rrc_rrm_ho_adm_req);
    /* SPR 21496 Fix End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR_15323 end*/

/*******************************************************************************
 *   FUNCTION NAME: rrm_rrc_parse_inter_freq_measurement_ind
 *   DESCRIPTION:
 *       Parse the Inter_freq_measurement_ind request coming from RRC
 *   RETURNS: RRM_FAILURE/RRM_SUCCESS
 ******************************************************************************/
rrm_return_et
rrm_rrc_parse_inter_freq_measurement_ind(
        U8 *p_api_buf,
        /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    S32                                       length_read = RRM_NULL;
    rrc_rrm_inter_freq_rstd_measurement_ind_t inter_freq_rstd_measurement_ind;
    rrm_ue_inter_freq_meas_ind_t              *p_rrm_inter_freq_meas_ind = RRM_PNULL;
    U8 			                              index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    RRM_MEMSET(&inter_freq_rstd_measurement_ind, RRM_ZERO, sizeof(rrc_rrm_inter_freq_rstd_measurement_ind_t));

	/* Parse RRC_RRM_INTER_FREQ_MEASUREMENT_IND msg from RRC*/
	if ( RRM_FAILURE == rrm_il_parse_rrc_rrm_inter_freq_rstd_measurement_ind(&inter_freq_rstd_measurement_ind, 
									         p_api_buf + RRM_INTERFACE_API_HEADER_SIZE, 
										 data_len,
										 &length_read))
	{
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->RRM:RRC_RRM_INTER_FREQ_MEASUREMENT_IND parsing failed");
	}
	else
	{

        p_rrm_inter_freq_meas_ind = (rrm_ue_inter_freq_meas_ind_t * ) rrm_mem_get(sizeof(rrm_ue_inter_freq_meas_ind_t));

		if(RRM_PNULL == p_rrm_inter_freq_meas_ind)
    		{
		        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
       			           "Failed to allocate memory for p_rrm_inter_freq_meas_ind");
		        return RRM_FAILURE;
    		}
        /* SPR 21251 Start */
		p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
        SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, inter_freq_rstd_measurement_ind.ue_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                "RRC->RRM:RRC_RRM_INTER_FREQ_MEASUREMENT_IND [UE:%d] successfully parsed", inter_freq_rstd_measurement_ind.ue_index);
        /* SPR 21251 End */
		/* Filling data from measurement IND to RRM measurement IND*/
		p_rrm_inter_freq_meas_ind->ue_index = inter_freq_rstd_measurement_ind.ue_index;
		p_rrm_inter_freq_meas_ind->bitmask = inter_freq_rstd_measurement_ind.bitmask;

        for ( index = 0 ; index < inter_freq_rstd_measurement_ind.rstd_inter_freq_info_list.num_rstd_intfreq_list; index++)
        {
            p_rrm_inter_freq_meas_ind->rstd_interfreq_list[index].carrier_freq = 
                inter_freq_rstd_measurement_ind.rstd_inter_freq_info_list.rstd_interfreq_list[index].carrier_freq;
            p_rrm_inter_freq_meas_ind->rstd_interfreq_list[index].meas_prs_offset = 
                inter_freq_rstd_measurement_ind.rstd_inter_freq_info_list.rstd_interfreq_list[index].meas_prs_offset;
        }
        p_rrm_inter_freq_meas_ind->num_rstd_intfreq_list 
            = inter_freq_rstd_measurement_ind.rstd_inter_freq_info_list.num_rstd_intfreq_list;

        /* Adding data to FSM*/
        p_rrm_ue_rrc_msg->ue_index = inter_freq_rstd_measurement_ind.ue_index;
        p_rrm_ue_rrc_msg->p_msg_data = p_rrm_inter_freq_meas_ind;
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/* MRO code changes start */
/*******************************************************************************
 *   FUNCTION NAME: rrm_ue_x2ap_parse_rlf_ind
 *   DESCRIPTION:
 *       Parse the RLF ind
 *   RETURNS:
 ******************************************************************************/
rrm_return_et
rrm_ue_x2ap_parse_rlf_ind (
        U8 *p_api_buf,
         /*SPR 17777 +-*/
        U16 data_len,
        rrm_ue_rrc_msg_t *p_rrm_ue_rrc_msg
        )
{
    S32                         length_read = RRM_NULL;
    x2ap_rlf_ind_t              *p_x2ap_rlf_ind=  RRM_PNULL;
    rrm_ue_proc_rlf_ind_t       *p_rrm_rlf_ind = RRM_PNULL;
    rrm_return_et                ret_val= RRM_FAILURE;
    U8                           index= RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_x2ap_rlf_ind = (x2ap_rlf_ind_t *) rrm_mem_get(sizeof(x2ap_rlf_ind_t));
    if(RRM_PNULL == p_x2ap_rlf_ind )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                  "Failed to allocate memory for p_x2ap_rlf_ind"); 
        return RRM_FAILURE;

    }
   /**Parse the RLF_IND */
    if ( RRM_SUCCESS == rrm_ue_rrc_parser_rlf_ind(
                                p_x2ap_rlf_ind,
                                p_api_buf + RRM_INTERFACE_API_HEADER_SIZE,
                                data_len,
                                &length_read))
    {
        p_rrm_rlf_ind = (rrm_ue_proc_rlf_ind_t *)
                rrm_mem_get(sizeof(rrm_ue_proc_rlf_ind_t));
        if (RRM_PNULL == p_rrm_rlf_ind)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                   "Failed to allocate memory for RLF indication"); 
            RRM_MEM_FREE(p_x2ap_rlf_ind);
            ret_val = RRM_FAILURE;
        }
        else
        {
            /* 
             * Valid cell index to be filled once L3 provides cell_index
             *  in RLF indication API.
             */
            /*SPR 12059:start*/
            p_rrm_ue_rrc_msg->cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
            /*SPR 12059:end*/
            /* SPR 21251 Start */
            SET_CELL_AND_UE_INDEX(p_rrm_ue_rrc_msg->cell_index, p_x2ap_rlf_ind->ue_index);
            /* SPR 21251 End */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                    "RRC->RRM:X2AP_RLF_IND [UE:%d] successfully parsed", p_x2ap_rlf_ind->ue_index);
            if ((p_x2ap_rlf_ind->bitmask & X2AP_RLF_IND_UE_INDEX_PRESENT) &&
                !(p_x2ap_rlf_ind->bitmask & X2AP_RLF_IND_UE_CONTEXT_RELEASED_PRESENT))
			{
				
				p_rrm_rlf_ind->bitmask = p_x2ap_rlf_ind->bitmask;
				p_rrm_ue_rrc_msg->ue_index = p_x2ap_rlf_ind->ue_index;
				p_rrm_rlf_ind->ue_index = p_x2ap_rlf_ind->ue_index;
				p_rrm_rlf_ind->failure_cell_pci=p_x2ap_rlf_ind->failure_cell_pci;
				p_rrm_rlf_ind->crnti=p_x2ap_rlf_ind->crnti;
				
				RRM_MEMCPY(&p_rrm_rlf_ind->enb1_gb_id,&p_x2ap_rlf_ind->enb1_gb_id,\
					   sizeof(rrm_x2_gb_enb_id_t));
				RRM_MEMCPY(&p_rrm_rlf_ind->enb2_gb_id, &p_x2ap_rlf_ind->enb2_gb_id,\
					   sizeof(rrm_x2_gb_enb_id_t));
                for(index=RRM_ZERO;index<MAX_PLMN_ID_BYTES; index++)
                {
                    p_rrm_rlf_ind->re_est_cell_ecgi.plmn_identity.plmn_id[index]  = 
                        p_x2ap_rlf_ind->re_est_cell_ecgi.plmn_identity.plmn_id[index];
                }
                for(index=RRM_ZERO ; index<HOME_ENB_ID_OCTET_SIZE ; index++)
                {
                    p_rrm_rlf_ind->re_est_cell_ecgi.eutran_cell_id[index]  = 
                        p_x2ap_rlf_ind->re_est_cell_ecgi.eutran_cell_id[index];
                }
				RRM_MEMCPY(&p_rrm_rlf_ind->rlf_report, &p_x2ap_rlf_ind->rlf_report,\
					   sizeof(rrc_rlf_report_t));
				p_rrm_rlf_ind->ue_context_released = p_x2ap_rlf_ind->ue_context_released;
				p_rrm_ue_rrc_msg->p_msg_data = p_rrm_rlf_ind;
				ret_val = RRM_SUCCESS;
			}
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                   "UE index is not present in RLF indication");
                ret_val = RRM_FAILURE;
			}
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRC->RRM:X2AP_RLF_IND parsing failed");
        ret_val = RRM_FAILURE;
    }
    RRM_MEM_FREE(p_x2ap_rlf_ind);
    RRM_UT_TRACE_EXIT();
    return ret_val;    
}
/* MRO code changes end */

/*******************************************************************************
 *   FUNCTION NAME: rrm_ue_mgr_rrc_msg_handler
 *   DESCRIPTION:
 *       Handles the incoming messages, received from RRC.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_mgr_rrc_msg_handler (
        rrm_void_t *p_api_buf,
        rrm_void_t *p_gl_ctx
        )
{
    rrm_ue_global_context_t 	*p_rrm_glb_ctxt = RRM_PNULL;
    rrm_ue_context_t            *p_ue_context = RRM_PNULL;
    rrm_return_et				ret_val = RRM_SUCCESS;
    U16							api_id = RRM_NULL;
    rrm_ue_index_t              ue_index = RRM_NULL;
    rrm_cell_index_t            cell_index = RRM_NULL;
    U16							msg_size = RRM_NULL;
    /*CID 97165 Start*/
    rrm_ue_events_et           current_event = RRM_UE_MAX_EVENT ;
    /*CID 97165 End*/
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    rrm_ue_rrc_msg_t 			*p_rrm_ue_rrc_msg = RRM_PNULL;
    rrm_dl_nas_transport_ind_t  *p_dl_nas_trans_ind = RRM_PNULL;
    /*CA HARDENING CHANGES 6.3.0*/

    RRM_UT_TRACE_ENTER();

    p_rrm_ue_rrc_msg = 
        (rrm_ue_rrc_msg_t *)rrm_mem_get(sizeof(rrm_ue_rrc_msg_t));
    if( RRM_PNULL == p_rrm_ue_rrc_msg)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return RRM_FAILURE;
    }

    /* SPR 15441 start */
    /* coverity_54424_fix: Start */
    RRM_MEMSET(p_rrm_ue_rrc_msg , RRM_ZERO, (sizeof(rrm_ue_rrc_msg_t)));
    /* coverity_54424_fix: End */
    /* SPR 15441 end */

    /* SPR 11135 Fix Start */
    p_rrm_ue_rrc_msg->p_msg_data = RRM_PNULL;
    /* SPR 11135 Fix End */


    p_api_buf += RRM_API_HEADER_SIZE; 

    /** Store the global context */
    p_rrm_glb_ctxt = (rrm_ue_global_context_t *)p_gl_ctx;

    p_rrm_glb_ctxt->trans_id    = rrm_get_word_from_header((U8*)(p_api_buf));
    api_id   = rrm_get_word_from_header((U8*)(p_api_buf + EXT_MSG_API_OFFSET));
    msg_size = 
        rrm_get_word_from_header((U8*)(p_api_buf + EXT_MSG_BUF_LEN_OFFSET));
    p_rrm_glb_ctxt->api_id = api_id;

    switch(api_id)
    {
        case RRC_RRM_UE_ADMISSION_REQ :
#ifdef RRM_UT_FLAG
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_admission_req);
#endif                
        if(RRM_FAILURE == rrm_rrc_process_ue_admission_req(
                    p_api_buf, 
                    /*SPR 17777 +-*/
                    msg_size, 
                    p_rrm_glb_ctxt))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            /* Coverity ID 75073 Fix Start */
            /* Coverity ID 75073 Fix End */
            ret_val = RRM_SUCCESS;
        }
        /*Valgrind Memory Leak Fix Start*/
        RRM_MEM_FREE(p_rrm_ue_rrc_msg);
        return ret_val;
        /*Valgrind Memory Leak Fix End*/
        case RRC_RRM_UE_ADMISSION_CNF :
        if ( RRM_FAILURE == rrm_ue_rrc_parse_ue_admission_cnf( p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))

        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_UE_ADMISSION_CNF_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_ERB_SETUP_REQ :
#ifdef RRM_UT_FLAG
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_erb_setup_req);   //# increment ue_erb_setup_req
#endif                
        if ( RRM_FAILURE == rrm_ue_rrc_parse_ue_erab_setup_req( p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    /* SPR 17438 Fix Start */
                    p_rrm_ue_rrc_msg))
            /* SPR 17438 Fix End */
        {
#ifdef RRM_UT_FLAG
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_erb_setup_resp_F);    //#total failure
            RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.ue_erb_setup_resp_F_parse_err);  //#parsing err
#endif                

            ret_val = RRM_FAILURE;	
        }
        else
        {
            current_event = RRC_RRM_ERB_SETUP_REQUEST_EVENT;
            ret_val = RRM_SUCCESS;
        } 
        break;
        case RRC_RRM_ERB_SETUP_CNF :
        if ( RRM_FAILURE == rrm_ue_rrc_parse_ue_erab_setup_cnf ( 
                    /*SPR 17777 +-*/
                    p_api_buf,  msg_size, p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;	
        }
        else
        {
            current_event = RRC_RRM_ERB_SETUP_CNF_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_ERB_RELEASE_REQ :
        if ( RRM_FAILURE == rrm_ue_rrc_parse_ue_erab_release_req(
                    /*SPR 17777 +-*/
                    p_api_buf, msg_size, p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_ERB_RELEASE_REQUEST_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_ERB_RELEASE_CNF :
        if ( RRM_FAILURE == rrm_ue_rrc_parse_ue_erab_release_cnf(
                    /*SPR 17777 +-*/
                    p_api_buf, msg_size, p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_ERB_RELEASE_CNF_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_UE_RELEASE_REQ :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ue_release_req(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size, 
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_UE_RELEASE_REQ_EVENT;
            ret_val = RRM_SUCCESS;
        } 
        break;
        case RRC_RRM_UE_CAPABILITY_IND :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ue_capability_ind(
                    /*SPR 17777 +-*/
                    p_api_buf, msg_size, p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_UE_CAPABILITY_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_ERB_MODIFY_REQ :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ue_erab_modify_req(
                    /*SPR 17777 +-*/
                    p_api_buf, msg_size, p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_ERB_MODIFY_REQUEST_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_ERB_MODIFY_CNF :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ue_erab_modify_cnf(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_ERB_MODIFY_CNF_EVENT;	
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_INACTIVE_UES_IND:
        if(RRM_FAILURE == rrm_ue_rrc_parse_inactive_ues_ind(
                    p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,p_rrm_glb_ctxt))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            ret_val = RRM_SUCCESS;
        }
        /* COVERITY : RESOURCE LEAK : CID : 54377 fix start*/
        RRM_MEM_FREE(p_rrm_ue_rrc_msg);
        /* COVERITY : RESOURCE LEAK : CID : 54377 fix end */
        return ret_val;
        break;
        /* UE MEAS CHANGES : STARTS */
        case RRC_RRM_MEAS_CONFIG_RESP:
        if(RRM_FAILURE == rrm_ue_rrc_parse_meas_config_resp(
                    p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_MEAS_CONFIG_RESP_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_MEASURMENT_RESULTS_IND :
        if(RRM_FAILURE == rrm_ue_rrc_parse_measurement_results_ind(
                    p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg
                    /*SPR 19071 changes start */
                    /*Code removed*/
                    /*SPR 19071 changes End */
                    ))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_MEASURMENT_RESULTS_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        /* UE MEAS CHANGES : ENDS */
        case RRC_RRM_UE_HO_ADM_REQ :
        if(RRM_FAILURE == rrm_rrc_process_ho_admission_req(
                    p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_glb_ctxt,
                    p_rrm_ue_rrc_msg))

        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_UE_HO_ADM_REQ_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_UE_HO_ADM_CNF :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ho_adm_cnf(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_UE_HO_ADM_CNF_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        /*MC, MR & HO  START */
        case RRC_RRM_UE_HO_CMD_REQ :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ho_cmd_req(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_UE_HO_CMD_REQ_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_HO_FAILURE :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ho_failure(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_HO_FAILURE_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_HO_CANCEL_RESP :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ho_cancel_resp(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_HO_CANCEL_RESP_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_HO_RESTRICTION_LIST_IND :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ho_restriction_ind(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_HO_RESTRICTION_LIST_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        /*Coverity_fix_start_54938*/
        break;
        /*Coverity_fix_end_54938*/ 
        /*MC, MR & HO  END */
        /*CS-Fallback changes start*/
        case RRC_RRM_UE_CONTEXT_MOD_REQ :
        if(RRM_FAILURE == rrm_ue_rrc_parse_ue_context_mod_req(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_UE_CONTEXT_MOD_REQ_EVENT;	
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_UE_CONTEXT_MOD_CNF:
        if(RRM_FAILURE == rrm_ue_rrc_parse_ue_context_mod_cnf(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_UE_CONTEXT_MOD_CNF_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_UE_RECONFIG_RESP:
        if(RRM_FAILURE == rrm_ue_rrc_parse_ue_reconfig_resp(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_UE_RECONFIG_RESP_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        /*csg start*/
        case RRC_RRM_PROXIMITY_IND:
        if(RRM_FAILURE == rrm_ue_rrc_parse_proximity_ind(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_PROXIMITY_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        /*csg end*/
        case RRC_RRM_CSFB_PARAMETERS_REQ_CDMA2000:
        if(RRM_FAILURE == rrm_rrc_process_cdma2000_mob_info_req(
                    p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_glb_ctxt))

        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            ret_val = RRM_SUCCESS;
        }
        RRM_MEM_FREE(p_rrm_ue_rrc_msg);
        return ret_val;
        /*CS-Fallback changes end*/
        /*CS-Fallback changes end*/
        /* MRO code changes start */
        case X2AP_RLF_IND:
        if(RRM_FAILURE == rrm_ue_x2ap_parse_rlf_ind((U8 *)p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_RLF_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        case RRC_RRM_INTER_FREQ_MEASUREMENT_IND:
        if (RRM_FAILURE == rrm_rrc_parse_inter_freq_measurement_ind((U8 *)p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_INTER_FREQ_MEAS_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;

        /* MRO code changes end */
        case RRC_RRM_DL_NAS_TRANSPORT_IND:
        if(RRM_FAILURE == rrm_rrc_parse_dl_nas_transport_ind_msg(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_DL_NAS_TRANSPORT_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;

        case RRC_RRM_INTRA_ENB_HO_IND:
        if(RRM_FAILURE == rrm_rrc_parse_intra_enodeb_Ho_ind_msg(p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = RRC_RRM_INTRA_ENB_HO_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;

        case RRC_RRM_LOCAL_ERROR_IND:
        if (RRM_FAILURE == rrm_rrc_parse_local_error_ind(p_api_buf, 
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_glb_ctxt))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            ret_val = RRM_SUCCESS;
        }
        RRM_MEM_FREE(p_rrm_ue_rrc_msg);
        return ret_val;
        /* UE positioning start */
        case S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ:
        if(RRM_FAILURE == rrm_rrc_parse_s1ap_rrm_lppa_ecid_meas_init_req(p_api_buf, 
                    /*SPR 17777 +-*/
                    msg_size, 
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;

        case S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND:
        if (RRM_FAILURE == rrm_rrc_parse_s1ap_rrm_lppa_ecid_meas_termination_cmd(p_api_buf, 
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = S1AP_RRM_LPPA_ECID_MEAS_TERMINATION_COMMAND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;

        case S1AP_RRM_LPPA_ERROR_IND:
        if (RRM_FAILURE == rrm_rrc_parse_s1ap_rrm_lppa_error_ind(p_api_buf, 
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            current_event = S1AP_RRM_LPPA_ERROR_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        /* UE positioning end */
        /* RACH_OPTIMIZATION_CHANGES_START */
        case RRC_RRM_UE_SYNC_STATUS:
        if ( RRM_FAILURE == rrm_ue_rrc_process_ue_sync_status( p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg, p_rrm_glb_ctxt))

        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            /* SPR 12512 Fix Start */
            current_event = RRC_RRM_UE_SYNC_STATUS_IND_EVENT;
            ret_val = RRM_SUCCESS;
        }
        break;
        /* SPR 12512 Fix End */

      case RRC_RRM_UE_REESTAB_CONFIG_REQ:
            if ( RRM_FAILURE == rrm_ue_rrc_process_ue_reestab_config_req( p_api_buf,
                        /*SPR 17777 +-*/
                        msg_size,
                        p_rrm_ue_rrc_msg, p_rrm_glb_ctxt))

            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Failed \
                        to process UE_REESTAB_CONFIG_REQ Message");
                ret_val = RRM_FAILURE;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                        "UE_INDEX[%d],Successfully processed \
                        UE_REESTAB_CONFIG_REQ",p_rrm_ue_rrc_msg->ue_index);
                ret_val = RRM_SUCCESS;
            }
            RRM_MEM_FREE(p_rrm_ue_rrc_msg);
            return ret_val;
      /* SPR_16053_Fix: Start */
      case RRC_RRM_UE_REESTAB_COMPLETE_IND:
            {
                /* SPR 18029 Fix +- */
                break;
            }
      /* SPR_16053_Fix: End */

        case RRC_RRM_UE_INFORMATION_RESP:
        if ( RRM_FAILURE == rrm_ue_rrc_process_ue_info_resp( p_api_buf,
                    /*SPR 17777 +-*/
                    msg_size,
                    p_rrm_ue_rrc_msg, p_rrm_glb_ctxt))

        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            ret_val = RRM_SUCCESS;
        }
        RRM_MEM_FREE(p_rrm_ue_rrc_msg);
        return ret_val;

        /* RACH_OPTIMIZATION_CHANGES_END */

      /* SPR 9216:MRO enhancement start */
      case RRC_RRM_UE_REESTAB_CONFIG_CNF:
            if ( RRM_FAILURE == rrm_ue_rrc_parse_ue_reestab_config_cnf(
                                p_api_buf,
                        /*SPR 17777 +-*/
                                msg_size,
                                p_rrm_ue_rrc_msg))

            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, 
                          RRM_ERROR,"Failed to process UE_REESTAB_CONFIG_CNF message");
                ret_val = RRM_FAILURE;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,
                          RRM_DETAILED, "UE_INDEX[%d],Successfully processed UE_REESTAB_CONFIG_CNF",
                          p_rrm_ue_rrc_msg->ue_index);
                current_event = RRC_RRM_UE_REESTAB_CONFIG_CNF_EVENT;
                ret_val = RRM_SUCCESS;
            }
            break;
      /* SPR 9216:MRO enhancement end */
      /*SPR_17893_START*/
	case RRC_RRM_UE_CAPABILITY_ENQUIRY_RESP:
	    if(RRM_FAILURE == rrm_ue_rrc_process_ue_capability_enq_resp(p_api_buf, 
				    msg_size,
				    p_rrm_ue_rrc_msg))
	    {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to process UE CAPABILITY ENQ RESP Message");
	    }
	    else
	    {
                ret_val = RRM_SUCCESS;
		     current_event = RRC_RRM_UE_CAPABILITY_ENQUIRY_RESP_EVENT;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, 
                        "UE_INDEX[%d],Successfully processed \
                        UE CAPABILITY ENQ RESP",p_rrm_ue_rrc_msg->ue_index);
	    }
	    break;
      /*SPR_17893_END*/

#ifdef ENDC_ENABLED
/* OPTION3X Changes Start */            
      case RRC_RRM_DC_BEARER_CHANGE_CNF:
            if ( RRM_FAILURE == rrm_ue_rrc_parse_ue_dc_bearer_change_cnf(
                                p_api_buf,
                                msg_size,
                                p_rrm_ue_rrc_msg))

            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, 
                          RRM_ERROR,"Failed to process UE_DC_BEARER_CHANGE_CNF message");
                ret_val = RRM_FAILURE;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,
                          RRM_DETAILED, "UE_INDEX[%d],Successfully processed UE_DC_BEARER_CHANGE_CNF",
                          p_rrm_ue_rrc_msg->ue_index);
                current_event = RRC_RRM_UE_DC_BEARER_CHANGE_CNF_EVENT;
                ret_val = RRM_SUCCESS;
            }
            break;
/* OPTION3X Changes End */            
#endif


      default :
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"Invalid API ID [%d] in RRC Msg Handler",
                    api_id);
        ret_val = RRM_FAILURE;
    }
    if ((RRM_SUCCESS == ret_val)
    )
    {
        ue_index = p_rrm_ue_rrc_msg->ue_index;
        cell_index = p_rrm_ue_rrc_msg->cell_index;
        SET_CELL_AND_UE_INDEX(cell_index, ue_index);
        /** Find the UE context */
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(ue_index,
                cell_index);
        if (RRM_PNULL == p_ue_context)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "[UE:%d], failed to find ue context",ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            /* SPR 20652 Fix End */
            p_rrm_glb_ctxt->p_ue_context = p_ue_context;
            p_ue_context->ue_event = current_event;
            p_ue_context->current_procedure.p_proc_data = 
                p_rrm_ue_rrc_msg->p_msg_data;
            /** Free the memory before enter into the UE FSM */
            if ( ( RRM_UE_MAX_STATE > p_ue_context->ue_state ) &&
                    ( RRM_UE_MAX_EVENT > p_ue_context->ue_event ))
            {
                if( RRC_RRM_DL_NAS_TRANSPORT_IND_EVENT == p_ue_context->ue_event)
                {
                    ret_val = RRM_SUCCESS;
                    p_dl_nas_trans_ind = 
			    (rrm_dl_nas_transport_ind_t*)p_ue_context->current_procedure.p_proc_data;
		    /*CID 97131 Start*/
		    if(p_dl_nas_trans_ind != RRM_PNULL)
		    {
                /*SPR 22553 FIXED START*/
			    if(p_dl_nas_trans_ind->bitmask & RRM_DL_NAS_TRANSPORT_IND_SUBS_PROF_ID_PRESENT)
			    {
				    p_ue_context->rrm_sub_profile_id_info.sub_profile_id = p_dl_nas_trans_ind->subscriber_profile_id_for_rfp;
			    }
                /*SPR 22553 FIXED END*/

                    /*SPR 19195 START*/
                    /*Code deleted*/
                    /*SPR 19195 END*/
		    }
		    /*CID 97131 End*/
                }
                else 
                {
                    /************ UEM FSM TRIGERRED **************************/
                    /* SPR 15441 start */
                    ret_val = rrm_uem_process_fsm(p_rrm_glb_ctxt->p_ue_context->ue_state, 
                            p_rrm_glb_ctxt->p_ue_context->ue_event,
                            p_rrm_glb_ctxt);

                        /* SPR 15441 end  */
                    /*********** UEM FSM *************************************/
                }
            }
            else
            {
               
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Invalid State[%d] or Invalid Event[%d]",
                          /* SPR 15441 start */
                          p_rrm_glb_ctxt->p_ue_context->ue_state,
                          p_rrm_glb_ctxt->p_ue_context->ue_event);
                         /* SPR 15441 end */
                         ret_val = RRM_FAILURE;
            }	   
            /* SPR 18195 Fix Start */
	   /*Code Deleted*/
          /* SPR 18195 Fix Stop */

        }   
    }
    /*SPR 19819 30JUN START*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"Processing completed for API [%d]",api_id);
    /*SPR 19819 30JUN END*/

    /* SPR 15441 start */
    if(p_rrm_ue_rrc_msg != RRM_PNULL)
    {
	/*SPR 17917 Start*/
        /* SPR: 15922 : Start */
        if(RRM_PNULL != p_rrm_ue_rrc_msg->p_msg_data)
        /* SPR: 15922 : End */
	/*SPR 17917 End*/
        {
           RRM_MEM_FREE(p_rrm_ue_rrc_msg->p_msg_data); 
        }
        RRM_MEM_FREE(p_rrm_ue_rrc_msg);
    }
    /* SPR 15441 end */
    /*SPR 17438 Fix Start*/
     p_rrm_glb_ctxt->p_ue_context = RRM_PNULL;
    /*SPR 17438 Fix End*/	

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*******************************************************************************
 *   FUNCTION NAME: rrm_ue_mgr_l2_msg_handler 
 *   DESCRIPTION: Handles the l2 messages.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_mgr_l2_msg_handler(
        rrm_void_t *p_api_buf,
        rrm_void_t *p_gl_ctx
        )
{
    rrm_return_et			ret_val = RRM_SUCCESS;
    rrm_ue_global_context_t  *p_rrm_glb_ctxt = RRM_PNULL;
    U16			   		 api_id = RRM_NULL;
    U16				       msg_size = RRM_NULL;
    rrm_cell_index_t		     cell_index = RRM_NULL;
    U16                                trans_id = RRM_ZERO;
    rrm_ue_mac_stats_report_t	     *p_ue_mac_stats = RRM_PNULL;
    /* Bug_869_Changes_Start */
    RrmMacUEReConfigCnf        *p_mac_ue_reconf_cnf = RRM_PNULL;    
    /* Bug_869_Changes_End */
    /* UE Positioning start */
    MacRrmEcidMeasurementResp  *p_mac_ecid_meas_report_resp = RRM_PNULL;
    /* UE Positioning end */
    RRM_UT_TRACE_ENTER();

    p_rrm_glb_ctxt = (rrm_ue_global_context_t *)p_gl_ctx;

    api_id   = rrm_get_word_from_header((U8*)(p_api_buf) + RRM_CSPL_API_ID_INDEX/*5*/);
    p_api_buf = (U8*)p_api_buf + RRM_API_HEADER_SIZE;
    msg_size = rrm_get_word_from_header((U8*)(p_api_buf) + RRM_INTF_MSG_ID_INDEX/*8*/);
    /* BUG_11907_FIX_START */
    trans_id   = rrm_get_word_from_header((U8*)(p_api_buf) + RRM_INTF_TRANS_ID_INDEX);
    /* BUG_11907_FIX_END */


/*BUG 585 FIX START*/
    cell_index = rrm_get_cell_id_from_header((U8*)(p_api_buf));
    SET_CELL_INDEX(cell_index);

    msg_size = msg_size - RRM_INTERFACE_API_HEADER_SIZE;
    p_api_buf = p_api_buf + RRM_INTERFACE_API_HEADER_SIZE;

    switch(api_id)
    {
        case RRM_MAC_PERIODIC_REPORT_IND:
	    if(RRM_FAILURE == rrm_mac_ue_periodic_stats_report(
                                   p_api_buf,
                        /*SPR 17777 +-*/
							      &p_ue_mac_stats))
	    {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "MAC->RRM:RRM_MAC_PERIODIC_REPORT_IND failed to parse");
		    ret_val = RRM_FAILURE;
	    }
	    else
	    {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "MAC->RRM:RRM_MAC_PERIODIC_REPORT_IND successfully parsed");

		    ret_val = RRM_SUCCESS; 
	    }
	    break;

        case RRM_MAC_UE_RECONFIG_CNF:
            if( RRM_FAILURE == rrm_parse_mac_ue_reconfig_cnf(p_api_buf,
                        /*SPR 17777 +-*/
                        &p_mac_ue_reconf_cnf))
            {
                ret_val = RRM_FAILURE;
             /*cov_fix_54376_start*/
                RRM_MEM_FREE(p_mac_ue_reconf_cnf);
             /*cov_fix_54376_end*/
            }
            else
            {
                ret_val = RRM_SUCCESS;
            }
             break;

/* UE Positioning start */
        case MAC_RRM_E_CID_MEAS_REPORT_RESP:
             if(RRM_FAILURE == rrm_parse_mac_ecid_meas_report_resp(p_api_buf, 
                        /*SPR 17777 +-*/
                                                                   &p_mac_ecid_meas_report_resp))
             {
                 ret_val = RRM_FAILURE;
             }
             else
             {
                 ret_val = RRM_SUCCESS;
             }
             break;
/* UE Positioning end */

        default:
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Invalid API ID : %d", 
                      api_id);
            ret_val = RRM_FAILURE;
    }
    if (RRM_SUCCESS == ret_val)
    {

        /* handle event on api basis */
        if( RRM_MAC_PERIODIC_REPORT_IND == api_id )
        {
            ret_val = rrm_handler_mac_periodic_report_event( cell_index,
                                                             p_ue_mac_stats,
                    p_rrm_glb_ctxt );
        }
        else if( RRM_MAC_UE_RECONFIG_CNF == api_id )
        {
            rrm_mac_ue_reconfig_cnf_event_handler( p_rrm_glb_ctxt,
                    p_mac_ue_reconf_cnf,
                    cell_index,
                    trans_id );
             /*cov_fix_54376_start*/
             RRM_MEM_FREE(p_mac_ue_reconf_cnf);
             /*cov_fix_54376_end*/
        }
        /* UE Positioning start */
        else if( MAC_RRM_E_CID_MEAS_REPORT_RESP == api_id)
        {
            ret_val = rrm_mac_process_ecid_meas_report_resp_event(cell_index, 
                    p_rrm_glb_ctxt, 
                                                        p_mac_ecid_meas_report_resp);
        }
        /* UE Positioning end */
    }
    /* SPR: 15922 Fix Start */
    if(p_mac_ue_reconf_cnf != RRM_PNULL)
    {
        RRM_MEM_FREE(p_mac_ue_reconf_cnf);
    }
    /* SPR: 15922 Fix End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*******************************************************************************
 *   FUNCTION NAME: rrm_handler_mac_periodic_report_event
 *   DESCRIPTION: Handles the l2 messages.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_handler_mac_periodic_report_event( rrm_cell_index_t   cell_index,
                                       rrm_ue_mac_stats_report_t
                                                          *p_ue_mac_stats,
                                       rrm_ue_global_context_t
                                                          *p_gl_ctx )
{
    rrm_return_et                    ret_val = RRM_SUCCESS;
    U16                              loop_index = RRM_ZERO;
    /* +- SPR 18268 */
    U16                               ue_count = RRM_ZERO;
    /* +- SPR 18268 */
    rrm_ue_index_t                   ue_index = RRM_ZERO;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    rrm_ue_context_t                 *p_ue_context = RRM_PNULL;
    rrm_ue_global_context_t          *p_rrm_glb_ctxt = RRM_PNULL;
    rrm_void_t                       *p_l2_data = RRM_PNULL;/*LTE_RRM_TM_SWITCH_END*/
    rrm_ue_context_t                 *uplink_mu_mimo_ue_context[MAX_NUM_OF_UE];
    /* Coverity Fix 99672 Start */
    U16                                mu_mimo_ue_context_index = RRM_ZERO;
    /* Coverity Fix 99672 End */
    U8                                uplink_sinr_threshold = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_rrm_glb_ctxt = (rrm_ue_global_context_t *)p_gl_ctx;

    uplink_sinr_threshold = rrm_get_uplink_sinr_threshold(cell_index);

    for( ue_count = p_ue_mac_stats->ue_count ; (ue_count != RRM_ZERO) &&
     			(loop_index < MAX_MAC_UE_STATS_IND) ; ue_count-- )
    {
        /* + SPR 20078 */
        ue_index = p_ue_mac_stats->ue_stats[loop_index].ueIndex;
        /* - SPR 20078 */
        p_l2_data = ((rrm_void_t*)(&(p_ue_mac_stats->ue_stats[loop_index])));
        loop_index++;
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(ue_index,
                cell_index );
        if(RRM_PNULL == p_ue_context)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                    "[UE:%d], unable to find ue context", ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                    "[UE:%d], ue context found", ue_index );

            /* SPR 20652 Fix End */
            p_rrm_glb_ctxt->p_ue_context = p_ue_context;

            ret_val = rrm_process_ue_l2_report( RRM_MAC_PERIODIC_REPORTS_IND_EVENT,
                    /* eICIC_PHASE_1_2_CHANGES_START */
                    p_rrm_glb_ctxt,
                    /* eICIC_PHASE_1_2_CHANGES_END */
                    p_l2_data );

            if((p_ue_context->ue_avg_stats.uplinkSINRValue < uplink_sinr_threshold) &&
               (p_ue_context->mu_mimo_bitmask & RRM_MU_MIMO_ENABLE_CNF) && 
               (mu_mimo_ue_context_index < MAX_NUM_OF_UE ))
            {
                uplink_mu_mimo_ue_context[mu_mimo_ue_context_index] = p_ue_context;
                mu_mimo_ue_context_index++;
            }
            
	    if( RRM_FAILURE == ret_val )
	    {
	        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
		"[UE:%d],Error in Processing UE's Mac stats report",ue_index);
		 continue;
            }

            p_ue_context->ue_event = RRM_MAC_PERIODIC_REPORTS_IND_EVENT;

	    ret_val = rrm_uem_process_fsm( p_ue_context->ue_state,
	                                   p_ue_context->ue_event,
	      			           p_rrm_glb_ctxt );/*process the ue fsm */

        }

    }

    if( mu_mimo_ue_context_index )
    {
        rrm_send_ue_mac_reconfig_req_for_disabling( uplink_mu_mimo_ue_context,cell_index ); 
    }
      
    if( RRM_PNULL != p_ue_mac_stats->ue_stats )
    {
        RRM_MEM_FREE(p_ue_mac_stats->ue_stats);
    }

    /* Coverity 19oct Start : 54986 */
    RRM_MEM_FREE(p_ue_mac_stats);
    /* Coverity 19oct End : 54986 */

        /*LTE_RRM_TM_SWITCH_END*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* eICIC_PHASE_1_2_CHANGES_START */
/*******************************************************************************
 *   FUNCTION NAME: rrm_uem_process_ue_reconfig_for_victim_ue 
 *   DESCRIPTION:   Handles the l2 messages.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_uem_process_ue_reconfig_for_victim_ue
(
 rrm_ue_global_context_t   *p_rrm_glb_ctxt,
 rrm_cell_index_t cell_index,
 RrmMacUEReConfigCnf *p_api
 )
{

    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    U32 response_code  = RRM_ZERO;
    YLIST   victim_ue_list;
    victim_ue_node_t    *p_victim_node = RRM_PNULL;
    /* SPR 14302 start */
    victim_ue_node_t    *p_temp_victim_node= RRM_PNULL;
    /* SPR 14302 end */
    RRM_UT_TRACE_ENTER();

    victim_ue_list = p_rrm_glb_ctxt->victim_ue_info.
        rrm_victim_ue_on_cell[cell_index].victim_ue_list;

    response_code = p_api->responseCode;

    switch(response_code)
    {

        case RRM_FAILURE:
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, \
                        "MAC CNF RESPONSE for a batch of victim UEs failed.");
                /* SPR 14302 start */
                p_victim_node = (victim_ue_node_t *)ylFirst(&victim_ue_list);       
                p_temp_victim_node = p_victim_node;
                while(p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.num_of_eligible_ue && p_temp_victim_node)
                {
                    /* SPR 20652 Fix Start */
                    p_ue_context = rrm_ue_find_context(p_victim_node->victim_ue_node_data.ue_index,
                            cell_index); 
                    /* SPR 20652 Fix End */

                    if(p_ue_context)
                    {
                        /* SPR_14046_START */
                        if((RRM_FALSE == rrm_is_set_fgi_bit(p_rrm_glb_ctxt->p_ue_context, RRM_HUNDRED_FIFTEEN)) || 
                                RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                eutra_radio_capability_info_def.access_stratum_release)
                            /* SPR_14046_END */
                        {
                            p_temp_victim_node = (victim_ue_node_t *)ylNext(&p_victim_node->node); 
                            ylDelete(&victim_ue_list, (YLNODE *)p_victim_node);
                            RRM_MEM_FREE(p_victim_node);
                            p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;      
                            /* SPR 20652 Fix End */
                            p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.num_of_eligible_ue--;
                            /* SPR 14302 start */
                            p_victim_node = p_temp_victim_node;
                            /* SPR 14302 end */
                        }
                        else
                        {
                            p_temp_victim_node = (victim_ue_node_t *)ylNext(&p_victim_node->node);
                            /* SPR 14302 start */
                            p_victim_node = p_temp_victim_node;
                            /* SPR 14302 end */
                        }
                    } 
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, 
                                "UE Context not found");
                    }

                }

                /* SPR 14302 end*/
                break;
            }

        case RRM_SUCCESS:
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, \
                        "MAC CNF RESPONSE for a batch of victim UEs succeeded.");

                p_victim_node = (victim_ue_node_t *)ylFirst(&victim_ue_list);       
                while(p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.num_of_eligible_ue && p_victim_node)
                {
                    /* SPR 20652 Fix Start */
                    p_ue_context = rrm_ue_find_context(p_victim_node->victim_ue_node_data.ue_index,
                            cell_index); 
                    /* SPR 20652 Fix End */

                    if(p_ue_context)
                    {
                        /* SPR_14046_START */
                        /* SPR 20652 Fix Start */
                        if((RRM_FALSE == rrm_is_set_fgi_bit(p_rrm_glb_ctxt->p_ue_context, RRM_HUNDRED_FIFTEEN)) || 
                                RRM_REL10 >= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                eutra_radio_capability_info_def.access_stratum_release)
                            /* SPR 20652 Fix End */
                            /* SPR_14046_END */
                        {
                            /* SPR 14285 start */
                            p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_VICTIM_STATE; 
                            /* SPR 14285 end*/
                            p_ue_context->rrm_ue_eicic_info.scheduled_on_abs = RRM_TRUE;      
                            p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.num_of_eligible_ue--;
                            /* SPR 14302 end */
                        }
                        p_victim_node = (victim_ue_node_t *)ylNext(&p_victim_node->node);
                    } 
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                "UE context not found");
                    }
                }
                /*SPR 15362 start*/
                p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_VICTIM_STATE; 
                /*SPR 15362 end*/
                break; 
            }
        default :
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                        "MAC CNF RESPONSE for a batch of victim UEs"
                        "failed with response code[%d]", 
                        response_code);
            }        
    }

    /* SPR 14610 start */
    p_rrm_glb_ctxt->victim_ue_info.
        rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;
    /* SPR 14610 end */
    /* SPR_14126_START */
    rrm_set_mac_ue_reconfig_mutex(cell_index,MAC_UE_RECONF_NOT_ONGOING);
    /* SPR_14126_END */
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/* eICIC_PHASE_1_2_CHANGES_END */
/*******************************************************************************
 *   FUNCTION NAME: rrm_handler_mac_ue_reconfig_cnf_event
 *   DESCRIPTION: Handles the l2 messages.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_handler_mac_ue_reconfig_cnf_event( rrm_cell_index_t           cell_index,
                                       RrmMacUEReConfigCnf  *p_mac_ue_reconf_cnf )
{
    
    RRM_UT_TRACE_ENTER();

    if( p_mac_ue_reconf_cnf )
    {
        
        rrm_update_or_rollback_bitmask_on_mac_ue_reconfig_cnf(cell_index,p_mac_ue_reconf_cnf);
        
    }
    
    /*SPR 7892 FIX START*/
    /*  set the mutex to indicate MAC_UE_RECONF_NOT_ONGOING*/
    rrm_set_mac_ue_reconfig_mutex(cell_index,MAC_UE_RECONF_NOT_ONGOING );
    /*SPR 7892 FIX END*/
   
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/*******************************************************************************
 *   FUNCTION NAME: rrm_process_mac_ue_reconfig_for_ca 
 *   DESCRIPTION: Handles the l2 messages for CA.
 *   RETURNS: NONE
 ******************************************************************************/
rrm_void_t
rrm_process_mac_ue_reconfig_for_ca(
    rrm_cell_index_t          cell_index,
    RrmMacUEReConfigCnf *p_mac_ue_reconf_cnf)
{
    U32 index = RRM_ZERO;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    RRM_UT_TRACE_ENTER();
    if (p_mac_ue_reconf_cnf->bitmask & UE_CA_CONFIG_ERROR_INFO_BITMASK)
    {
        for(index = RRM_ZERO; index < p_mac_ue_reconf_cnf->ueCarrierAggConfigErrorInfo.numOfUE; index++)
        {
            /* SPR 20652 Fix Start */
            p_ue_context = rrm_ue_find_context(p_mac_ue_reconf_cnf->ueCarrierAggConfigErrorInfo.ueCarrierAggConfigError[index].ueIndex,
                    cell_index );
            /*cov fix start 63895*/
            if (RRM_PNULL != p_ue_context)
            {

                /*Revert the scell state as failure received from MAC
                  and reset scell state backup count as zero*/
                rrm_revert_ue_scell_state_info(p_ue_context);
                p_ue_context->ue_scell_add_params.scell_bkp_count= RRM_ZERO;
                /* SPR 20652 Fix End */
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                        "[UE:%u] context not found",
                        p_mac_ue_reconf_cnf->ueCarrierAggConfigErrorInfo.ueCarrierAggConfigError[index].ueIndex);
            }
            /*cov fix end 63895*/
        }
    }
    rrm_set_mac_ue_reconfig_mutex(cell_index,MAC_UE_RECONF_NOT_ONGOING);
    RRM_UT_TRACE_EXIT();
}

 /*******************************************************************************
  *   FUNCTION NAME: rrm_process_mac_ue_reconfig_cnf_for_beamforming 
  *   DESCRIPTION: Handles the l2 messages for beamformig error .
  *   RETURNS:
  *       RRM_SUCCESS on Success
  *       RRM_FAILURE on Failure
  ******************************************************************************/
rrm_void_t
rrm_process_mac_ue_reconfig_cnf_for_beamforming( rrm_cell_index_t          cell_index,
                                                 RrmMacUEReConfigCnf *p_mac_ue_reconf_cnf )
{
    rrm_ue_context_t            *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    rrm_ue_index_t               ue_index = RRM_ZERO ;
    U8                           index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

     if( p_mac_ue_reconf_cnf->bitmask & UE_BEAM_FORMING_ALGO_ERROR_INFO_BITMASK)
     {
         RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                 "Mac ue reconfig cnf is handled with failure for beamforming algo");

         for( index = RRM_ZERO; ( index < p_mac_ue_reconf_cnf->ueBeamFormingAlgoErrorInfo.numOfUE );
                 index++)
         {
             ue_index = p_mac_ue_reconf_cnf->ueBeamFormingAlgoErrorInfo.ueBeamFormingAlgoError[index].ueIndex;
             /* SPR 20652 Fix Start */
             p_ue_context = rrm_ue_find_context( ue_index , cell_index );
             if(RRM_PNULL != p_ue_context )
             {
                 /* SPR 20652 Fix End */
                 RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                         "beamforming algo could not be configured for [UE:%d]"
                         " can not apply TM mode 7 for this UE",ue_index);
                 p_ue_context->beam_forming_algo_configd_for_TM7_8 = RRM_FALSE;
             }
             else
             {
                 RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                         "ue context not found for [UE:%d]",ue_index);
             }
         }
     }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "SUCCESS Received for p_mac_ue_reconf_cnf for beamforming info");
    }
    /*SPR 7892 FIX START*/
    rrm_set_mac_ue_reconfig_mutex(cell_index,MAC_UE_RECONF_NOT_ONGOING);
    /*SPR 7892 FIX END*/
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_handle_mac_ue_reconfig 
 *   DESCRIPTION:
 *        Send mac ue reconfig requset   
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_handle_mac_ue_reconfig (
        rrm_ue_global_context_t *p_rrm_glb_ctxt, 
        rrm_cell_index_t        cell_index)
{
    RrmMacUeReconfigReq   *p_mac_ue_reconfig_req = {RRM_ZERO};
    rrm_return_et ret_val = RRM_SUCCESS;    
    RRM_UT_TRACE_ENTER();
   
    p_mac_ue_reconfig_req = (RrmMacUeReconfigReq *)(p_rrm_glb_ctxt->p_proc_data);
    
    ret_val = rrm_send_mac_ue_reconfig_req( p_mac_ue_reconfig_req,
                RRM_MODULE_ID,
                RRM_ZERO,
                cell_index);
    if (ret_val == RRM_SUCCESS)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,RRM_DETAILED,
                "Successfully sent RRM_MAC_UE_RECONFIG_REQ to L2 for scell");
        rrm_set_mac_ue_reconfig_mutex(cell_index,W_FOR_MAC_UE_RECONF_CNF_FOR_CA);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* CSR00069389 Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_send_meas_config_req_for_report_cgi 
 *   DESCRIPTION:
 *          This function prepares and sends the meas config request to RRC 
 *          for CGI Reporting purpose
 *   RETURNS:
 *            rrm_error_et 
 ******************************************************************************/
static rrm_error_et
rrm_ue_send_meas_config_req_for_report_cgi(
     rrm_ue_context_t                *p_ue_context,
     rrm_ue_meas_config_cgi_queue_node_t report_cgi_req_info
     )
{
    rrm_return_et           ret_val                     = RRM_SUCCESS;
    /*Cov_fix_start_64265*/
    rrm_error_et                     error_code                  = RRM_NO_ERROR;    
    /*Cov_fix_start_64265*/
    U16                     transaction_id              = RRM_NULL;

    rrm_cell_context_t      *p_cell_context             = RRM_PNULL;
    meas_eutran_node_t      *p_meas_eutran_node         = RRM_PNULL;
    meas_utran_node_t       *p_meas_utran_node          = RRM_PNULL;
    /* TDD Support SON Start */
    meas_utran_tdd_node_t   *p_meas_utran_tdd_node      = RRM_PNULL;
    /* TDD Support SON End */
    meas_geran_node_t       *p_meas_geran_node          = RRM_PNULL;
    meas_cdma_node_t        *p_meas_cdma_node           = RRM_PNULL;
    rrm_ue_meas_config_t    *p_meas_config_info         = RRM_PNULL;
    /* SPR 15539 Start */ 
    meas_report_info_node_t* p_meas_report_info         = RRM_PNULL;
    /* SPR 15539 End */
    /*Cov_fix_start_64263*/
    rrm_son_geran_band_indicator_et     band_ind = RRM_SON_GERAN_DCS_1800;
    /*Cov_fix_start_64263*/
    /*Cov_fix_start_64264*/
    rrm_son_cdma_band_class_et   band_class = RRM_SON_BAND_CLASS_BC_0;
    /*Cov_fix_start_64264*/
    RRM_UT_TRACE_ENTER();

    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);

    switch((rrm_rat_type_et)report_cgi_req_info.rat_type)
    {
        case RRM_EUTRAN_CELL:
            p_meas_eutran_node = rrmcm_find_eutran_meas_context(report_cgi_req_info.arfcn, p_cell_context);
            break;
        case RRM_UTRAN_CELL:
            p_meas_utran_node = rrmcm_find_utran_meas_context(report_cgi_req_info.arfcn, p_cell_context);
            break;
        case RRM_UTRAN_TDD_CELL:
            p_meas_utran_tdd_node = rrmcm_find_utran_tdd_meas_context(report_cgi_req_info.arfcn, p_cell_context);
            break;
            /* Coverity 64263 fix start */
        case RRM_GERAN_CELL:
            /*Cov_fix_start_64263*/
            {
                switch(report_cgi_req_info.band_ind)
                {
                    case RRM_ZERO:
                        band_ind = RRM_SON_GERAN_DCS_1800;
                        break;
                    case RRM_ONE:
                        band_ind = RRM_SON_GERAN_PCS_1900;
                        break;
                    default :
                        band_ind = RRM_SON_GERAN_DCS_1800;
                        break; 

                }
                p_meas_geran_node = rrmcm_find_geran_meas_context(report_cgi_req_info.arfcn, band_ind, p_cell_context);
            }
            break;
            /*Cov_fix_start_64263*/
        case RRM_CDMA_CELL:
            /*Cov_fix_start_64264*/
            {
                switch(report_cgi_req_info.band_class)
                {
                    case RRM_ZERO:
                        band_class = RRM_SON_BAND_CLASS_BC_0 ;
                        break;
                    case RRM_ONE:
                        band_class = RRM_SON_BAND_CLASS_BC_1;
                        break;
                    case RRM_TWO :
                        band_class = RRM_SON_BAND_CLASS_BC_2;
                        break;
                    case RRM_THREE :
                        band_class = RRM_SON_BAND_CLASS_BC_3;
                        break;
                    case RRM_FOUR :
                        band_class = RRM_SON_BAND_CLASS_BC_4;
                        break;
                    case RRM_FIVE :
                        band_class = RRM_SON_BAND_CLASS_BC_5;
                        break;
                    case RRM_SIX :
                        band_class = RRM_SON_BAND_CLASS_BC_6;
                        break;
                    case RRM_SEVEN :
                        band_class = RRM_SON_BAND_CLASS_BC_7;
                        break ;
                    case RRM_EIGHT :
                        band_class = RRM_SON_BAND_CLASS_BC_8;
                        break ;
                    case RRM_NINE :
                        band_class = RRM_SON_BAND_CLASS_BC_9;
                        break ;
                    case RRM_TEN :
                        band_class = RRM_SON_BAND_CLASS_BC_10;
                        break ;
                    case RRM_ELEVEN :
                        band_class = RRM_SON_BAND_CLASS_BC_11;
                        break ;
                    case RRM_TWELVE :
                        band_class = RRM_SON_BAND_CLASS_BC_12;
                        break ;
                    case RRM_THIRTEEN :
                        band_class = RRM_SON_BAND_CLASS_BC_13;
                        break ;
                    case RRM_FOURTEEN :
                        band_class = RRM_SON_BAND_CLASS_BC_14;
                        break ;
                    case RRM_FIFTEEN :
                        band_class = RRM_SON_BAND_CLASS_BC_15;
                        break ;
                    case RRM_SIXTEEN :
                        band_class =  RRM_SON_BAND_CLASS_BC_16;
                        break ;
                    case RRM_SEVENTEEN :
                        band_class =  RRM_SON_BAND_CLASS_BC_17;
                        break ;
                    case RRM_EIGHTEEN :
                        band_class =  RRM_SON_BAND_CLASS_BC18_V9A0;
                        break ;
                    case RRM_NINETEEN :
                        band_class =  RRM_SON_BAND_CLASS_BC19_V9A0;
                        break ;
                    case RRM_TWENTY :
                        band_class =  RRM_SON_BAND_CLASS_BC20_V9A0;
                        break ;
                    case RRM_TWENTY_ONE :
                        band_class =  RRM_SON_BAND_CLASS_BC21_V9A0;
                        break ;
                }
                p_meas_cdma_node = rrmcm_find_cdma_meas_context(report_cgi_req_info.arfcn, band_class, p_cell_context);
                break;
            }
            /* Cov_fix_end_64264*/
        default:
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Invalid Rat type = %d", report_cgi_req_info.rat_type);
            break;
    }

    /* If meas obj is found in cell context list corresponding to the ARFCN provided in meas
       config request */
    if((p_meas_eutran_node) || (p_meas_utran_node) || (p_meas_utran_tdd_node) || 
            (p_meas_geran_node) || (p_meas_cdma_node))
    {
        p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type, 
                report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                p_ue_context->p_meas_config);

        if(RRM_PNULL != p_meas_config_info)
        {
            /* SPR 16219 fix start */
            if(RRM_ZERO != p_meas_config_info->meas_id)
                /* SPR 16219 fix end */
            {
                transaction_id = rrm_generate_txn_id();

                ret_val = rrm_build_and_send_meas_config_req_for_cgi_reporting(
                        p_meas_eutran_node, p_meas_utran_node, p_meas_utran_tdd_node, p_meas_geran_node,
                        /* Spr 18401 Changes Start */
                        p_meas_cdma_node, p_ue_context, &report_cgi_req_info, transaction_id,
                       /* Spr 18401 Changes End */

                        p_meas_config_info);

                if(RRM_SUCCESS == ret_val)
                {
                    /* SPR 15539 Start */ 
                    p_meas_report_info = (meas_report_info_node_t*) rrm_mem_get(sizeof(meas_report_info_node_t));
                    if (p_meas_report_info == RRM_PNULL)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Memory Allocation Failure");
                        RRM_UT_TRACE_EXIT();
                        /*Coverity 83464 Fix Start*/
                        error_code = RRM_ERR_SYS_MEM_ALLOC_FAILURE;
                        return error_code;
                        //return RRM_FAILURE;
                        /*Coverity 83464 Fix End*/
                    }

                    RRM_MEMSET(p_meas_report_info, RRM_ZERO, sizeof(meas_report_info_node_t));
                    p_meas_report_info->meas_object_id = p_meas_config_info->meas_obj_id;
                    p_meas_report_info->report_config_id = p_meas_config_info->report_id;
                    p_meas_report_info->meas_status = RRM_MEAS_CONFIG_REQ_SENT;
                    p_meas_report_info->meas_id = p_meas_config_info->meas_id;
                    p_meas_report_info->reporting_event = MEAS_REP_EVENT_FOR_CGI;

                    /* SPR 15860 Start */
                    /* SPR 15861 Start */
                    /* SPR 15862 Start */
                    p_meas_report_info->is_meas_report_pending = RRM_TRUE;
                    /* SPR 15860 End */
                    /* SPR 15861 End */
                    /* SPR 15862 End */

                    /* SPR 15598 Start */
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Meas Object found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    p_meas_report_info->carrier_earfcn = report_cgi_req_info.arfcn;  
                    /* SPR 15598 Start */



                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, "Inserted measId = %u, reporting_event = %u", 
                            p_meas_report_info->meas_id, p_meas_report_info->reporting_event);
                    ylPushTail(&(p_ue_context->meas_report_list),&(p_meas_report_info->sNode));

                    /* SPR 16053 start */
                    /* Code deleted */
                    /* SPR 16053 end */

                    /* SPR 15539 End */ 

                    /* CGI Resp Status will be updated to Failure if a failure resp is
                       received for any of the Report CGI Request corresponding to
                       the Carr freq for meas id specified*/

                    p_meas_config_info->cgi_resp_status = RRM_SUCCESS;

                    /* Reset meas_config_status of Strongest cell reporting case*/
                    p_meas_config_info->meas_config_status = RRM_MEAS_CONFIG_REQ_SENT;

                    /* Update the procedure state */
                    p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING;

#ifdef RRM_UT_FLAG
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.meas_config_req);
#endif
                }
                else
                {
                    error_code = RRM_ERR_INTERNAL_FAILURE;
#ifdef RRM_UT_FLAG
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F);
                    RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F_ue_internal);
#endif
                }
            }
            /* SPR 16219 fix start */
            else
            {
                RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                        "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                error_code = RRM_ERR_UE_NOT_CONFIGURED;
            }
            /* SPR 16219 fix end */
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
            error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Meas Object not found in Cell context for arfcn = %d", report_cgi_req_info.arfcn);
        error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
    }
    RRM_UT_TRACE_EXIT();
    return error_code;
}
/* CSR00069389 End */

/*******************************************************************************
 *   FUNCTION NAME: rrm_ue_handle_dequeued_msg 
 *   DESCRIPTION:
 *       Handles the message enqueued in queue, received from RRC.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_handle_dequeued_msg (
        /* CSR00069389 Start */
        rrm_ue_procedure_record_t  *p_rrm_ue_procedure_record,
        /* CSR00069389 End */
        rrm_ue_global_context_t *p_rrm_glb_ctxt,
        rrm_cell_index_t        cell_index
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    /* CSR00069389 Start */
    YLNODE *p_procedure_record_s_node = RRM_PNULL;

    /*BUG 13332:start*/
    p_rrm_glb_ctxt->trans_id = p_rrm_ue_procedure_record->proc_queue.trans_id ;
    /*BUG 13332:end*/
    /*SPR 18241 START*/
    RRM_UT_TRACE_ENTER();
   /* SPR 21598 start */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
        "API ID at the time of deque is[%d]",p_rrm_ue_procedure_record->proc_queue.api_id);
   /* SPR 21598 end */
    /*SPR 18241 END*/

    p_rrm_glb_ctxt->api_id = p_rrm_ue_procedure_record->proc_queue.api_id;
    switch(p_rrm_ue_procedure_record->proc_queue.api_id)
    /* CSR00069389 End */
    {
        case RRC_RRM_ERB_SETUP_REQ:
            p_rrm_glb_ctxt->p_ue_context->ue_event = 
                RRC_RRM_ERB_SETUP_REQUEST_EVENT;
            break; 
        case RRC_RRM_ERB_MODIFY_REQ:
            p_rrm_glb_ctxt->p_ue_context->ue_event = 
                RRC_RRM_ERB_MODIFY_REQUEST_EVENT; 
            break; 
        case RRC_RRM_ERB_RELEASE_REQ:
            p_rrm_glb_ctxt->p_ue_context->ue_event = 
                RRC_RRM_ERB_RELEASE_REQUEST_EVENT; 
            break;
        case RRC_RRM_HO_REQUIRED:
                p_rrm_glb_ctxt->p_ue_context->ue_event = 
                    RRC_RRM_LIPA_HO_REQUIRED_EVENT;
	    break; 
        case RRC_RRM_UE_RECONFIG_REQ:
            ret_val = rrm_handle_ue_reconfig_req
                    (p_rrm_glb_ctxt->p_ue_context);
            if( RRM_SUCCESS == ret_val )
            {
                if((RRM_SCELL_INDEX_BACKUP_PRESENT & p_rrm_glb_ctxt->p_ue_context->ue_scell_add_params.bitmask) ||
                   (RRM_SCELL_DELETE_SCENARIO & p_rrm_glb_ctxt->p_ue_context->ue_scell_add_params.bitmask)
                  )
                {
                    p_rrm_glb_ctxt->p_ue_context->current_procedure.state =
                    RRM_UE_SCELL_PROCEDURE_ONGOING; 
                }
                else
                {
                p_rrm_glb_ctxt->p_ue_context->current_procedure.state =
                RRM_UE_RECONFIG_ONGOING;
            }
            }
            return ret_val;
        /* CSR00069389 Start */
            break;
        case RRC_RRM_MEAS_CONFIG_REQ:
            /* Send Meas Config Req for reportCGI */
            if(RRM_NO_ERROR == rrm_ue_send_meas_config_req_for_report_cgi(p_rrm_glb_ctxt->p_ue_context,
            *(rrm_ue_meas_config_cgi_queue_node_t *)(p_rrm_ue_procedure_record->proc_queue.p_proc_data)))
            {
                ret_val = RRM_SUCCESS;
            }
            else
            {
                ret_val = RRM_FAILURE;
            }

            /* Free the memory of processed CGI node */
	    /*SPR 15441 +-*/
            /* Update the first meas config CGI node pointer to point to appropriate node.
            As all Meas Config CGI req nodes are enqueued near the tail part and the dequeued procedure is 
            Meas Config CGI req, the following node will be either NULL or again a Meas Config CGI req procedure */
            p_procedure_record_s_node = rrm_get_first_list_node(&p_rrm_glb_ctxt->p_ue_context->procedure_queue);
            p_rrm_glb_ctxt->p_ue_context->p_proc_queue_first_meas_node = 
                (rrm_ue_procedure_record_t *)YMEMBEROF(rrm_ue_procedure_record_t, s_node, p_procedure_record_s_node);

            return ret_val;
            break;
        case RRM_MAC_UE_RECONFIG_REQ:
        {
                ret_val = rrm_handle_mac_ue_reconfig(p_rrm_glb_ctxt,cell_index);
                RRM_UT_TRACE_EXIT();
                return ret_val;
        }
        case RRC_RRM_MEASURMENT_RESULTS_IND:
            p_rrm_glb_ctxt->p_ue_context->ue_event =
                    RRC_RRM_MEASURMENT_RESULTS_IND_EVENT;
        break;
        /* CSR00069389 End */
            /* SPR 12512 Fix Start */
        case RRC_RRM_UE_SYNC_STATUS:
            p_rrm_glb_ctxt->p_ue_context->ue_event =
                RRC_RRM_UE_SYNC_STATUS_IND_EVENT;
            break;
            /* SPR 12512 Fix End */
        /*SPR 11535:start*/
        case RRC_RRM_INACTIVE_UES_IND: 
            p_rrm_glb_ctxt->p_ue_context->ue_event =
                    RRC_RRM_UE_INACTIVE_EVENT;
        break;
        /*SPR 11535:start*/
        /*SPR 18241 START*/
        case RRC_RRM_INTRA_ENB_HO_IND:
        p_rrm_glb_ctxt->p_ue_context->ue_event =
            RRC_RRM_INTRA_ENB_HO_IND_EVENT;
        break;
        case RRC_RRM_UE_CONTEXT_MOD_REQ:
        p_rrm_glb_ctxt->p_ue_context->ue_event =
            RRC_RRM_UE_CONTEXT_MOD_REQ_EVENT;
        break;
        /*SPR 18241 END*/

    }
    /************ UEM FSM TRIGERRED **************************/
    /* SPR 15441 start */
    /* BUG_11943_FIX_START */
    ret_val = (rrm_uem_process_fsm(p_rrm_glb_ctxt->p_ue_context->ue_state,
            p_rrm_glb_ctxt->p_ue_context->ue_event,
            p_rrm_glb_ctxt));
    /* BUG_11943_FIX_END */
        /* SPR 15441 end  */
    /*********** UEM FSM *************************************/
    if(RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Error processing the message for Event[%d] in \
                State[%d]",
                p_rrm_glb_ctxt->p_ue_context->ue_event,
                p_rrm_glb_ctxt->p_ue_context->ue_state);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*******************************************************************************
 *   FUNCTION NAME: rrm_ue_handle_dequeued_esmlc_meas_req
 *   DESCRIPTION:
 *       Dequeues the ESMLC req messages coming from S1AP
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_ue_handle_dequeued_esmlc_meas_req(
        U16  api_id,
        rrm_ue_global_context_t *p_rrm_glb_ctxt
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    if(S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ == api_id)
    {
        p_rrm_glb_ctxt->p_ue_context->ue_event = 
            S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ_EVENT;
        
        UEM_FSM_SET_STATE ( p_rrm_glb_ctxt->p_ue_context, RRM_UE_STATE_ACTIVE);
    
        /************ UEM FSM TRIGERRED **************************/
        /* SPR 15441 start */
        ret_val = rrm_uem_process_fsm(p_rrm_glb_ctxt->p_ue_context->ue_state, 
                p_rrm_glb_ctxt->p_ue_context->ue_event,
                p_rrm_glb_ctxt);
            /*********** UEM FSM *************************************/
        /* SPR 15441 end  */

        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Error processing the message for Event[%d] in \
                    State[%d]",
                    p_rrm_glb_ctxt->p_ue_context->ue_event,
                    p_rrm_glb_ctxt->p_ue_context->ue_state);
        }
    }
    /* RACH_OPTIMIZATION_CHANGES_START */
    else if(RRC_RRM_UE_INFORMATION_RESP == api_id)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"API ID is for RACH so \
                sending meas_config_req while dequeuing");
        /*Send  meas_config_req and is_ue_report_requested flag would be
          set to FALSE when measurement result ind is received*/
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Sending meas_config_req periodically (once) to request \
                strongest cell information");
        ret_val = rrm_build_and_send_meas_config_req_for_ue_positioning
            (p_rrm_glb_ctxt->p_ue_context,
             RRM_MAX_ESMLC_MEAS_ID - RRM_ONE,
             RRM_LPPA_MS120/*report interval*/,
             RRM_LPPA_ONDEMAND/*report type*/,
             RRM_UE_POS_TRIGGER_QTY_RSRP/*quantity bitmask*/,
             RRM_TRUE /*defines if request is for rach or ue_positioning*/);

        /* SPR 15797 Start */

        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "Failure returned for UE meas config request for [UE:%d]",
                    p_rrm_glb_ctxt->p_ue_context->ue_index);
        }
        else
        {
            p_rrm_glb_ctxt->p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;
            p_rrm_glb_ctxt->p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING; 
        }
        /* SPR 15797 End */
    }

    /* RACH_OPTIMIZATION_CHANGES_END */
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
            "API id is not S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ for dequeueing the esmlc req queue");
        return RRM_FAILURE;
    }
    RRM_UT_TRACE_ENTER();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME:	rrm_ue_get_new_context 
 *   DESCRIPTION:
 *       			This function is used allocate the new UE context and
 *					allocate memory for a new UE context.
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
/* SPR 20652 Fix Start */
rrm_return_et
rrm_ue_get_new_context (
    rrm_ue_index_t ue_idx,
    rrm_cell_index_t cell_idx,
    rrm_ue_context_t **p_ue_context
    )
{
    rrm_return_et ret_val = RRM_SUCCESS; 
    rrm_ue_shelf_node_t *p_new_ue_node = RRM_PNULL ;
    rrm_ue_index_t      i = RRM_ZERO;
    rrm_cell_context_t *p_cell_ctxt = RRM_PNULL;
    U8                              index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_ue_context);

    /* Total number of ues is the max UE index that can be attached */
    rrm_ue_index_t  total_num_of_ues = RRM_INVALID_UE_INDEX;
    /* Retrieving maximum number of bits that will be used in UE index */
    total_num_of_ues = total_num_of_ues & BITMASK_FOR_UE_ID;
    p_cell_ctxt = rrm_cellm_get_cell_context(cell_idx);
    if (RRM_PNULL == p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "Cell context not found for cell index [%d] ",cell_idx);
        ret_val = RRM_FAILURE;
    }
    else
    {
        if(p_cell_ctxt->rrm_ue_db.p_ue_idx_list != RRM_NULL)
        {
            if (RRM_ZERO != ylCount(&(p_cell_ctxt->rrm_ue_db.p_ue_idx_list[ue_idx].rrm_ue_info_list)))
            {
                p_new_ue_node = (rrm_ue_shelf_node_t*)ylFirst(&(p_cell_ctxt->rrm_ue_db.p_ue_idx_list[ue_idx].rrm_ue_info_list));
                while(p_new_ue_node != RRM_PNULL)
                {
                    if(ue_idx == ((rrm_ue_context_t *)p_new_ue_node->p_ue_context)->ue_index)
                    {
                        RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR,"UEIdx [%d] already present on RRM", ue_idx);
                        ret_val = RRM_FAILURE;
                        break;
                    }
                    p_new_ue_node = (rrm_ue_shelf_node_t*)ylNext(&p_new_ue_node->node);	
                }
            }
        }
        else
        {
            p_cell_ctxt->rrm_ue_db.p_ue_idx_list = (rrm_ues_shelf_t *)rrm_mem_get((sizeof(rrm_ues_shelf_t)) * total_num_of_ues);
            if(p_cell_ctxt->rrm_ue_db.p_ue_idx_list == RRM_NULL)
            {
                RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR,"Failed to allocate memory to p_ue_idx_list");
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }
            for(i  = RRM_ZERO; i < total_num_of_ues; i++)
            {
                ylInit(&(p_cell_ctxt->rrm_ue_db.p_ue_idx_list[i].rrm_ue_info_list));
                p_cell_ctxt->rrm_ue_db.p_ue_idx_list[i].prev_idx = RRM_INVALID_UE_INDEX;
                p_cell_ctxt->rrm_ue_db.p_ue_idx_list[i].next_idx = RRM_INVALID_UE_INDEX;
            }
            p_cell_ctxt->rrm_ue_db.head_idx = p_cell_ctxt->rrm_ue_db.tail_idx = RRM_INVALID_UE_INDEX;
        }

        if (RRM_SUCCESS == ret_val)
        {
            p_new_ue_node = (rrm_ue_shelf_node_t *)rrm_mem_get(sizeof(rrm_ue_shelf_node_t));
            if (RRM_PNULL != p_new_ue_node)
            {
                p_new_ue_node->p_ue_context = *p_ue_context = (rrm_ue_context_t *)rrm_mem_get(sizeof (rrm_ue_context_t));
                if(RRM_PNULL != p_new_ue_node->p_ue_context)
                {
                  if (RRM_ZERO == ylCount(&p_cell_ctxt->rrm_ue_db.p_ue_idx_list[ue_idx].rrm_ue_info_list))
                  {
                    if((RRM_INVALID_UE_INDEX == p_cell_ctxt->rrm_ue_db.head_idx) && (RRM_INVALID_UE_INDEX == p_cell_ctxt->rrm_ue_db.tail_idx))
                    {
                      p_cell_ctxt->rrm_ue_db.head_idx = p_cell_ctxt->rrm_ue_db.tail_idx = ue_idx;
                    }
                    else
                    {
                      p_cell_ctxt->rrm_ue_db.p_ue_idx_list[ue_idx].prev_idx = p_cell_ctxt->rrm_ue_db.tail_idx;
                      p_cell_ctxt->rrm_ue_db.p_ue_idx_list[p_cell_ctxt->rrm_ue_db.tail_idx].next_idx = ue_idx;
                      p_cell_ctxt->rrm_ue_db.tail_idx = ue_idx;
                    }
                  }
                  /* SPR 21496 Fix Start */ 
                  RRM_MEMSET((*p_ue_context),RRM_ZERO,sizeof(rrm_ue_context_t));
                  (*p_ue_context)->ue_capability_params.rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.access_stratum_release = RRM_REL8; 
                  ylPushTail(&(p_cell_ctxt->rrm_ue_db.p_ue_idx_list[ue_idx].rrm_ue_info_list), &(p_new_ue_node->node));
                  ylInit(&((*p_ue_context)->best_cell_for_ue));
                  (*p_ue_context)->p_ue_mac_report = (rrm_ue_mac_report_t*)rrm_mem_get(sizeof(rrm_ue_mac_report_t));
                  (*p_ue_context)->p_ue_mac_report->report_index = RRM_ZERO;
                  (*p_ue_context)->p_ue_mac_report->report_count = RRM_ZERO;
                  (*p_ue_context)->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index = NO_DRX_PROFILE;
                  /* Assigning the maximum value at the start */
                  (*p_ue_context)->ul_sch_config.retx_bsr_timer_past = RRC_RETX_BSR_TIMER_SF_10240;
                  /*TM mode 7/8 start*/
                  (*p_ue_context)->beam_forming_algo_configd_for_TM7_8 = RRM_TRUE;
                  /*TM mode 7/8 end*/
                  (*p_ue_context)->pci_for_which_cgi_required = INVALID_PHYSICAL_CELL_ID;
                  (*p_ue_context)->ue_sps_data.sps_erab_id = RRM_OUT_OF_RANGE;   //0xFF;
                  (*p_ue_context)->rrm_ue_in_hold = RRM_FALSE;
                  for(index = RRM_ZERO; index < RRM_MAX_SCELL; index++)
                  {
                    (*p_ue_context)->ca_data.final_scell_list[index] = RRM_OUT_OF_RANGE;
                  }
                  (*p_ue_context)->ecn_supported = RRM_TRUE;
                  /* SPR 21496 Fix End */ 
                  /* SPR 22989 fix start */
                  (*p_ue_context)->ho_restriction_list.forbidden_ta_list.count = 0;
                  (*p_ue_context)->ho_restriction_list.forbidden_ta_list.p_forbidden_ta = RRM_PNULL;
                  /* SPR 22989 fix stop */
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                            "Failed to allocate memory for UE Context");
                    RRM_MEM_FREE(p_new_ue_node);
                    ret_val = RRM_FAILURE;
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to allocate memory for UE Context list node");
                ret_val = RRM_FAILURE;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 20652 Fix End */
/*SPR 21479 Fix start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_glb_dequeue_req
 *   DESCRIPTION:
 *       This function pop out the message pending in the procedure queue
 *   RETURNS:
 *		void
 ******************************************************************************/
rrm_ue_procedure_record_t * 
rrm_ue_glb_dequeue_req(
        rrm_ue_proc_queue_t * procedure_queue
        )
{
    return (rrm_ue_procedure_record_t*)ylPopHead(procedure_queue);
}
/*SPR 21479 Fix end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_glb_enqueue_req
 *   DESCRIPTION:
 *       Enqueue the ue reconfig request for MAC
 *   RETURNS:
 *		void
 ******************************************************************************/
    rrm_return_et
rrm_ue_glb_enqueue_req(
        rrm_void_t *p_api_buf,
        rrm_ue_global_context_t *p_gl_ctx
        )
{
    rrm_ue_procedure_record_t			*p_ue_procedure_record = RRM_PNULL;
    rrm_return_et                       ret_val = RRM_SUCCESS;    

    RRM_UT_TRACE_ENTER();

    /** Enqueue the ERAB setup request to enqueue Q */
    p_ue_procedure_record = (rrm_ue_procedure_record_t *) rrm_mem_get
        (sizeof(rrm_ue_procedure_record_t));
    if (RRM_PNULL == p_ue_procedure_record)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "Unable to alocate the memory for record\n");
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_MEMCPY((rrm_void_t *)&p_ue_procedure_record->proc_queue,
                p_api_buf,
                sizeof(rrm_ue_procedure_queue_t));
        /**Enqueue the erab setup req data */
        rrm_request_enqueue(&p_gl_ctx->procedure_queue,
                p_ue_procedure_record);
    }
    /*p_ue_procedure_record will be freed after dequeue function*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_mgr_enqueue_req
 *   DESCRIPTION:
 *       Enqueue the erab setup request,erab modify request,erab release request
 *   RETURNS:
 *		void
 ******************************************************************************/
rrm_return_et
rrm_ue_mgr_enqueue_req(
        /* CSR00069389 Start */
        rrm_ue_procedure_queue_t *p_api_buf,
        /* CSR00069389 End */
        rrm_ue_context_t *p_ue_context,
        /*SPR 18241 START*/
        rrm_bool_et rrm_push_head_flag
        /*SPR 18241 END*/

        )
{
    rrm_ue_procedure_record_t			*p_ue_procedure_record = RRM_PNULL;
    rrm_return_et                       ret_val = RRM_SUCCESS;    
    /* CSR00069389 Start */
    rrm_ue_procedure_record_t           *p_insert_before_node = RRM_PNULL;
    /* CSR00069389 End */

    RRM_UT_TRACE_ENTER();

    /*SPR 20840 Fix start*/
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING, 
            "in rrm_ue_mgr_enqueue_req function proc_queue %u, p_ue_context %u",p_api_buf,p_ue_context);
    /*SPR 20840 Fix stop*/

    /** Enqueue the ERAB setup request to enqueue Q */
    p_ue_procedure_record = (rrm_ue_procedure_record_t *) rrm_mem_get
        (sizeof(rrm_ue_procedure_record_t));
    if (RRM_PNULL == p_ue_procedure_record)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "Unable to alocate the memory for  \
                record\n");
        ret_val = RRM_FAILURE;
    }
    else
    {
        /* CSR00069389 Start */
        RRM_MEMSET(p_ue_procedure_record, RRM_ZERO, sizeof(rrm_ue_procedure_record_t));
        /* SPR 15441 start */
        /* Coverity 93940 Fix Start */
        if(RRM_PNULL == p_api_buf)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "Unable to alocate the memory for  \
                    record\n");
            ret_val = RRM_FAILURE;
            RRM_UT_TRACE_EXIT();
        }    
        else
            /* Coverity 93940 Fix End */
        {
            p_ue_procedure_record->proc_queue.api_id = p_api_buf->api_id;
            U32 msg_size = rrm_get_msg_size_through_api_id(p_api_buf->api_id);
            if(RRM_ZERO != msg_size)
            {
                p_ue_procedure_record->proc_queue.p_proc_data = rrm_mem_get(
                        msg_size);
                if(RRM_PNULL == p_ue_procedure_record->proc_queue.p_proc_data)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
                            RRM_ERROR, "Unable to alocate the memory for "
                            "proc_data\n");

                    /* SPR: 15922 : Start */
                    RRM_MEM_FREE(p_ue_procedure_record);
                    /* SPR: 15922 : End */

                    return RRM_FAILURE;
                }

                //valgrind fix Tc110
                RRM_MEMSET(p_ue_procedure_record->proc_queue.p_proc_data,RRM_ZERO,
                    msg_size);
                RRM_MEMCPY((rrm_void_t *)p_ue_procedure_record->proc_queue.p_proc_data,
                        ((rrm_void_t *)(p_api_buf->p_proc_data)),
                        msg_size);
            }
            /*BUG 13332:start*/
            p_ue_procedure_record->proc_queue.trans_id = p_api_buf->trans_id;
            /*BUG 13332:end*/
            /*SPR_18241_START*/
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
                    RRM_WARNING, "Enqueue API [%u] when current procedure state is [%u]",
                    p_ue_procedure_record->proc_queue.api_id, p_ue_context->current_procedure.state);
            /*SPR_18241_END*/

        }
        /* +- Coverity 93940 */

        if(RRC_RRM_MEAS_CONFIG_REQ == p_ue_procedure_record->proc_queue.api_id)
        {
            if(RRM_PNULL == p_ue_context->p_proc_queue_first_meas_node)
            {
                p_ue_context->p_proc_queue_first_meas_node = p_ue_procedure_record;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Enqueuing first node for Meas Config CGI request in procedure queue");
            }
            /* Insert at the end of the procedure queue */
            p_insert_before_node = RRM_PNULL;
        }
        else
        {
            /* Insert before the Meas Config CGI nodes in the procedure queue */
            p_insert_before_node = p_ue_context->p_proc_queue_first_meas_node;
        }
        if(RRM_PNULL != p_insert_before_node)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Inserting procedure before Meas Config node with cgi = %d",
                    ((rrm_ue_meas_config_cgi_queue_node_t*)(p_insert_before_node->proc_queue.p_proc_data))->cgi);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Inserting procedure at the end of the procedure queue");
        }
        /*SPR 18241 START*/
        /* Coverity 93940 Fix Start */
        if((rrm_push_head_flag == RRM_TRUE) && (RRM_PNULL != p_api_buf))
            /* Coverity 93940 Fix End */
        {
            ylPushHead(&p_ue_context->procedure_queue, &p_ue_procedure_record->s_node);
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Inserting procedure with API Id [%d] in the beginning of the procedure queue for [UE:%d]",
                    p_api_buf->api_id, p_ue_context->ue_index);
        }
        else
        {    
            rrm_request_enqueue_before(&p_ue_context->procedure_queue,
                    p_insert_before_node, p_ue_procedure_record);
        }
        /*SPR 18241 END*/
        /* CSR00069389 End */
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 15441 start */
/******************************************************************************
 *   FUNCTION NAME: rrm_get_msg_size_through_api_id 
 *   INPUT        : api_id 
 *   OUTPUT       : NONE
 *   RETURNS      : msg_size for given api
 *   DESCRIPTION  : return msg_size of api buffer as per given input api_id
 ******************************************************************************/
U32
    rrm_get_msg_size_through_api_id
(
 U16 api_id
 )
{ 
    U32 msg_size = RRM_ZERO; 
    RRM_UT_TRACE_ENTER();

    switch(api_id)
    {
        case RRC_RRM_ERB_SETUP_REQ:
            /*SPR 20840 Fix Start*/
            msg_size = sizeof(rrm_ue_proc_erab_setup_data_t);
            /*SPR 20840 Fix Stop*/
            break; 
        case RRC_RRM_ERB_MODIFY_REQ:
            msg_size = sizeof(rrc_rrm_erab_modify_req_t); 
            break; 
        case RRC_RRM_ERB_RELEASE_REQ:
            msg_size = sizeof(rrc_rrm_erb_release_req_t); 
            break;
        case RRC_RRM_HO_REQUIRED:
            msg_size = sizeof(rrc_rrm_ho_required_t); 
            break; 
        case RRC_RRM_UE_RECONFIG_REQ:
            msg_size = sizeof(rrc_rrm_ue_reconfig_req_t); 
            break;
        case RRC_RRM_MEAS_CONFIG_REQ:
            /* SPR_15719_Fix: Start */
            msg_size = sizeof(rrm_ue_meas_config_cgi_queue_node_t); 
            /* SPR_15719_Fix: End */
            break;
        case RRC_RRM_MEASURMENT_RESULTS_IND:
            msg_size = sizeof(rrc_rrm_measurment_results_ind_t); 
            break;
        case RRC_RRM_UE_SYNC_STATUS:
            msg_size = sizeof(rrc_rrm_ue_sync_status_t); 
            break;
        case RRC_RRM_UE_INFORMATION_RESP:
            msg_size = sizeof(rrm_ue_info_resp_t); 
            break;
        case S1AP_RRM_LPPA_ECID_MEAS_INIT_REQ:
            msg_size = sizeof(rrm_ue_lppa_ecid_meas_init_req_t); 
            break;
            /*SPR 18241 START*/
        case RRC_RRM_UE_CONTEXT_MOD_REQ:    
            msg_size = sizeof(rrm_ue_context_mod_req_t);
            break;
        case RRC_RRM_INTRA_ENB_HO_IND:
            msg_size = sizeof(rrm_intra_enodeb_ho_ind_t);
            break;
            /*SPR 18241 END*/
            /* SPR 21598 start */
         case RRC_RRM_INACTIVE_UES_IND:
            msg_size = sizeof(rrm_ue_inactive_t);
            break;
            /* SPR 21598 end */


        default :
            /* SPR 21598 start */
            RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_INFO,
                    "Invalid API[%d] received in enque msg handler", api_id);
            /* SPR 21598 end */
    }

    RRM_UT_TRACE_EXIT();
    return msg_size;
}
/* SPR 15441 end */ 

/* SPR 16456 Fix Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_mgr_enqueue_back_req
 *   DESCRIPTION:
 *       Enqueue the dequeued erab setup request,erab modify request,
 *       erab release request to its original enqueued position.
 *   RETURNS:
 *      void
 ******************************************************************************/
    rrm_return_et
rrm_ue_mgr_enqueue_back_req(
        rrm_ue_procedure_queue_t *p_api_buf,
        rrm_ue_context_t *p_ue_context
        )
{
    rrm_ue_procedure_record_t           *p_ue_procedure_record = RRM_PNULL;
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    /** Enqueue the received message to the procedural queue */
    p_ue_procedure_record = (rrm_ue_procedure_record_t *) rrm_mem_get
        (sizeof(rrm_ue_procedure_record_t));
    if (RRM_PNULL == p_ue_procedure_record)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "Unable to allocate the memory for record.\n");
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "API Id=%d with Transaction Id=%d is dropped.\n",
                p_api_buf->api_id, p_api_buf->trans_id);
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_MEMSET(p_ue_procedure_record, RRM_ZERO, sizeof(rrm_ue_procedure_record_t));

        if(RRM_PNULL != p_api_buf)
        {
            p_ue_procedure_record->proc_queue.api_id = p_api_buf->api_id;
            U32 msg_size = rrm_get_msg_size_through_api_id(p_api_buf->api_id);
            if(RRM_ZERO != msg_size)
            {
                p_ue_procedure_record->proc_queue.p_proc_data = rrm_mem_get(
                        msg_size);
                if(RRM_PNULL == p_ue_procedure_record->proc_queue.p_proc_data)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                            RRM_ERROR, "Unable to alocate the memory for "
                            "proc_data\n");

                    RRM_MEM_FREE(p_ue_procedure_record);

                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }

                RRM_MEMCPY((rrm_void_t *)p_ue_procedure_record->proc_queue.p_proc_data,
                        ((rrm_void_t *)(p_api_buf->p_proc_data)),
                        msg_size);
            }
            p_ue_procedure_record->proc_queue.trans_id = p_api_buf->trans_id;
            /*Cov 88242 +-*/
            if(RRC_RRM_MEAS_CONFIG_REQ == p_ue_procedure_record->proc_queue.api_id)
            {
                /* Insert in the beginning of the Meas Config CGI nodes in the procedure queue */
                rrm_request_enqueue_before(&p_ue_context->procedure_queue,
                        p_ue_context->p_proc_queue_first_meas_node, p_ue_procedure_record);

                p_ue_context->p_proc_queue_first_meas_node = p_ue_procedure_record;

                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Enqueuing node for Meas Config request with API Id [%d] in procedure queue", p_api_buf->api_id);
            }
            else
            {
                ylPushHead(&p_ue_context->procedure_queue, &p_ue_procedure_record->s_node);
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "Inserting procedure with API Id [%d] in the beginning of the procedure queue", p_api_buf->api_id);
            }
            /*Cov 88242 + */     
        }
        /*Cov 88242 - */
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 16456 Fix Stop */

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_mgr_enqueue_esmlc_meas_req
 *   DESCRIPTION  : Enqueues the ESMLC meas request coming from S1AP
 *   OUTPUT       : void
 ******************************************************************************/
rrm_return_et
rrm_ue_mgr_enqueue_esmlc_meas_req(
        /*SPR  20076 Fix Start */
        rrm_ue_procedure_queue_t  *p_api_buf,
        /*SPR  20076 Fix End */
        rrm_ue_context_t   *p_ue_context
        )
{
    rrm_ue_procedure_record_t			*p_ue_procedure_record = RRM_PNULL;
    rrm_return_et                        ret_val = RRM_SUCCESS;    

    RRM_UT_TRACE_ENTER();

    /** Enqueue the ESMLC meas request coming from S1AP */
    p_ue_procedure_record = (rrm_ue_procedure_record_t *) rrm_mem_get
        (sizeof(rrm_ue_procedure_record_t));
    if (RRM_PNULL == p_ue_procedure_record)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                "Unable to allocate the memory for record\n");
        ret_val = RRM_FAILURE;
    }
    else
    {
        /* SPR 15441 start */
        p_ue_procedure_record->proc_queue.api_id = p_api_buf->api_id;
        p_ue_procedure_record->proc_queue.trans_id = p_api_buf->trans_id;

        U32 msg_size = rrm_get_msg_size_through_api_id((p_api_buf)->api_id);
        /*SPR  20076 Fix Start */
        if(RRM_ZERO == msg_size)
        {
            RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                    "Invalid API[%d] received in enque msg handler", p_api_buf->api_id);
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;

        }
        /*SPR  20076 Fix End */
        if(RRM_ZERO != msg_size)
        {
            p_ue_procedure_record->proc_queue.p_proc_data = rrm_mem_get(
                    msg_size);
            if(RRM_PNULL == p_ue_procedure_record->proc_queue.p_proc_data)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, 
                        RRM_ERROR, "Unable to alocate the memory for "
                        "proc_data");
                /* SPR: 15922  : Start */
                RRM_MEM_FREE(p_ue_procedure_record);
                /* SPR: 15922  : End */ 
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }

            RRM_MEMCPY(p_ue_procedure_record->proc_queue.p_proc_data,
                    ((p_api_buf)->p_proc_data), msg_size);
        }
        /* SPR 15441 end */
        /* Enqueue the esmlc meas request data */
        rrm_request_enqueue(&p_ue_context->esmlc_meas_req_queue,
                p_ue_procedure_record);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_set_ue_proc_state 
 *   DESCRIPTION:
 *           function to change the Current Procedure State
 *   RETURNS:
 *		void
 ******************************************************************************/
     rrm_void_t 
rrm_set_ue_proc_state(
        rrm_ue_procedure_t          *p_current_procedure,
        rrm_ue_erb_states_et    	state
        )
{
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
             "### Procedure state changed %s->%s",\
             rrm_get_ue_fsm_procedure_state_string(p_current_procedure->state), \
             rrm_get_ue_fsm_procedure_state_string(state));
    p_current_procedure->state = state;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_set_state
 *   DESCRIPTION:
 *           function to change the ue state
 *   RETURNS:
 *		void
 ******************************************************************************/
     rrm_void_t 
rrm_ue_set_state(
        rrm_ue_context_t *p_ue_context,
        rrm_ue_states_et ue_state
        )
{
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
            "### UEFSM: State Change: %s->%s ###",\
            UE_FSM_STATE[p_ue_context->ue_state], \
            UE_FSM_STATE[ue_state]);
    p_ue_context->ue_state = ue_state;
}

/******************************************************************************
 *   FUNCTION NAME: find_ngbr_non_preemptable_erb_present 
 *   DESCRIPTION:
 *          This function finds any non preemptable nbgr erb 
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE)
 ******************************************************************************/

    rrm_return_et 
find_ngbr_non_preemptable_erb_present(
        rrm_ue_context_t *p_ue_context
        )
{
    U8 erb_index = RRM_NULL;
    U8 preemption_vulnerability = RRM_FALSE;
    U8 qci = RRM_NULL;
    rrm_return_et return_value = RRM_FAILURE;
    U8 erab_count = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    if (RRM_PNULL != p_ue_context)
    {		
        erab_count = p_ue_context->drb_configured.num_of_list;
        for(;erb_index < erab_count ; erb_index++)
        {
            qci = p_ue_context->drb_configured.erab_item[erb_index].erab_level_qos_params.qci;
            if(qci > RRM_GBR_QCI_4 && qci < RRM_MAX_QCI_LIMIT ) /* NGBR erb*/
            {
                preemption_vulnerability = p_ue_context->drb_configured.erab_item[erb_index].
                    erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability;	
                if(RRM_FALSE == preemption_vulnerability)
                {
                    return_value = RRM_SUCCESS;
                    break;
                }
            }
        }
    }	

    RRM_UT_TRACE_EXIT();
    return(return_value);
}

/******************************************************************************
 *   FUNCTION NAME:rrm_ue_get_ue_priority 
 *   DESCRIPTION:
 *          This function finds the highest priority from all erabs for a UE 
 *   RETURNS:
 *             U8 index of erb_highest_priority
 ******************************************************************************/
S8
rrm_ue_get_ue_priority(        
        rrm_ue_context_t *p_ue_context
        )
{
    if(!p_ue_context)
    {
        return(RRM_INDEX_ERR);
    }
    else
    {
        return(p_ue_context->ue_priority);
    }
}


/******************************************************************************
 *   FUNCTION NAME: rrm_ue_find_erb_index
 *   DESCRIPTION:
 *          This function finds the index of erab_id in the drb_configured list 
 *   RETURNS:
 *             U8 index of erab_id
 ******************************************************************************/

    U8
rrm_ue_find_erb_index(
        rrm_ue_erb_t *p_ue_erb
        )
{
    U8 erb_index = RRM_NULL;
    U8 erab_id = RRM_NULL;
    U8 erab_count = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    erab_count = p_ue_erb->p_rrm_ue_context->drb_configured.num_of_list;
    /*SPR 19819 30JUN START*/
    /* Code deleted */
    /*SPR 19819 30JUN END*/
    for(erb_index = RRM_ZERO; erb_index < erab_count ; erb_index++)
    {
        erab_id = p_ue_erb->p_rrm_ue_context->drb_configured.erab_item[erb_index].erab_id;
        /*SPR 19819 30JUN START*/
        /* Code deleted */
        /*SPR 19819 30JUN END*/
        if(erab_id == p_ue_erb->erab_id) 	
        {
            /* SPR-18301 START */
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "Erab_id [%d] matched with UE Rab Id[%d]", erab_id, p_ue_erb->erab_id);
            /* SPR-18301 END */

            break;
        }
    }
    /*SPR 19819 30JUN START*/
    /* Code deleted */
    /*SPR 19819 30JUN END*/
    /*LTE_RRM_KLOCWORK_WARN_25_JUL_START*/
    if ((erb_index < RRM_MAX_NUM_DRB_PER_UE )&& (erab_count != RRM_ZERO))
    {
        /*SPR 19819 30JUN START*/
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Erab_id [%d] found", p_ue_erb->erab_id);
        /*SPR 19819 30JUN END*/
        RRM_UT_TRACE_EXIT();
        return(erb_index);
    }
    else
    {
        /*SPR 19819 30JUN START*/
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Erab_id [%d] not found", p_ue_erb->erab_id);
        /*SPR 19819 30JUN END*/
        erb_index =RRM_INVALID_RETURN;
        RRM_UT_TRACE_EXIT();
        return erb_index;	
    }
    /*LTE_RRM_KLOCWORK_WARN_25_JUL_END*/
}



/******************************************************************************
 *   FUNCTION NAME: rrm_ue_insert_erb_entity
 *   DESCRIPTION:
 *          This function insers the UE RAB information to the global list
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE) 
 ******************************************************************************/
    rrm_return_et 
rrm_ue_insert_erb_entity (
        rrm_ue_erb_t *p_ue_erab
        )
{

    U8 list_index = RRM_NULL;	
    rrm_return_et return_value = RRM_SUCCESS;
    rrm_ue_erb_list_t *p_new_list_element = RRM_NULL;
    U8 erab_priority = RRM_NULL;
    U8 preemption_vulnerability = RRM_NULL;
    U8 erb_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if(!p_ue_erab)
    {
        return_value = RRM_FAILURE;	
    }
    else if ((erb_index = rrm_ue_find_erb_index(p_ue_erab)) != RRM_INVALID_RETURN)
    {
        erab_priority = p_ue_erab->p_rrm_ue_context->drb_configured.
            erab_item[erb_index].
            erab_level_qos_params.alloc_and_reten_prior.priority_level;
        preemption_vulnerability =  p_ue_erab->p_rrm_ue_context->drb_configured.
            erab_item[erb_index].
            erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Erab Priority[%d], Preempt_Vulnerability[%d]", 
                erab_priority, preemption_vulnerability);

        if(RRM_UE_ERB_NO_ARP == erab_priority)
        {
            return_value = RRM_FAILURE;	
        }
        else 
        {
            if(RRM_TRUE == preemption_vulnerability)
            {
                list_index = RRM_UE_ERB_LOWEST_ARP - erab_priority;
            }
            else
            {
                list_index = (RRM_TWO*RRM_UE_ERB_LOWEST_ARP+RRM_ONE) - erab_priority;
            }
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "list_index[%d]",  list_index);

            p_new_list_element = (rrm_ue_erb_list_t *) rrm_mem_get(sizeof(rrm_ue_erb_list_t));

            if ( p_new_list_element == RRM_PNULL)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "Memory allocation to p_new_list_element failed" );
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }
            else
            {
                p_new_list_element->ue_erb.p_rrm_ue_context = p_ue_erab->p_rrm_ue_context; 
                p_new_list_element->ue_erb.erab_id = p_ue_erab->erab_id;
                /*Bug_721_changes_start*/
                p_new_list_element->ue_erb.is_erb_selected_for_rel = RRM_FALSE;
                /*Bug_721_changes_end*/
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "ListIndex[%d], ErabId[%d]", 
                        list_index, p_new_list_element->ue_erb.erab_id);	
            }
        }
    }
    else
    {
        return_value = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                "ERAB id [%d] does not exist in the drb configurd List", p_ue_erab->erab_id);

    }
    if(return_value)
    {
        ylPushTail(&(ue_erab_priority_list[list_index]), (YLNODE *)p_new_list_element);	
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Erab added to priority list successfully at index[%d]", list_index);	
    }

    RRM_UT_TRACE_EXIT();

    return(return_value);	
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_update_erb_priority_list
 *   DESCRIPTION:
 *          This function delete the UE RAB information to the global list
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE)
 ******************************************************************************/

    rrm_return_et
rrm_ue_update_erb_priority_list(
        rrm_ue_context_t *p_ue_context
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 drb_index = RRM_NULL;
    rrm_ue_erb_t ue_erab = {RRM_NULL};
    U8 erb_count = RRM_NULL;
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_ue_context)
    {
        ue_erab.p_rrm_ue_context = p_ue_context;
        erb_count = p_ue_context->drb_configured.num_of_list;
        for(; drb_index <= erb_count; drb_index++)
        {
            ue_erab.erab_id = p_ue_context->drb_configured.erab_item[drb_index].erab_id;
            if(RRM_SUCCESS == rrm_ue_delete_erb_entity(&ue_erab))
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "Erab id [%d] deleted successfully from priority List from index [%d]", ue_erab.erab_id, drb_index);
            }
        }
    }
    else
    {
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return(ret_val);
}

/****************************************************************************
 * Function Name  : rrm_ue_delete_erb_entity_per_rab_index
 * Inputs         : rrm_ue_erb_t  ue_erb, erab_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Delete Rab priority from global list
 ****************************************************************************/
    rrm_return_et
rrm_ue_delete_erb_entity_per_rab_index(rrm_ue_erb_t *p_ue_erab, U8 erb_index)
{
    U8 list_index = RRM_NULL;
    /* Coverity_ID : 16399 */
    rrm_return_et    return_value = RRM_SUCCESS;
    rrm_ue_erb_list_t *p_node_to_be_deleted = RRM_NULL;
    U8 erab_priority = RRM_NULL;
    U8 preemption_vulnerability = RRM_NULL;
    RRM_UT_TRACE_ENTER();

    if(!p_ue_erab)
    {
        return_value = RRM_FAILURE;
    }
    else if(erb_index < RRM_MAX_NUM_DRB_PER_UE)
    {
        erab_priority = p_ue_erab->p_rrm_ue_context->drb_configured.
            erab_item[erb_index].
            erab_level_qos_params.alloc_and_reten_prior.priority_level;
        preemption_vulnerability =  p_ue_erab->p_rrm_ue_context->drb_configured.
            erab_item[erb_index].
            erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability;
        if(RRM_UE_ERB_NO_ARP  == erab_priority)
        {
            return_value = RRM_FAILURE;
        }
        else
        {
            if(RRM_TRUE == preemption_vulnerability)
            {
                list_index = RRM_UE_ERB_LOWEST_ARP - erab_priority;
            }
            else
            {
                list_index = (2*RRM_UE_ERB_LOWEST_ARP+1) - erab_priority;
            }
        }
    }
    else
    {
        return_value = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "ERAB id [%d] does not exist in the drb configurd List", p_ue_erab->erab_id);
    }
    if(return_value)
    {
        p_node_to_be_deleted = (rrm_ue_erb_list_t *) ylFind(&ue_erab_priority_list[list_index],
                p_ue_erab, rrm_ue_del_req_object_id_keyof ,
                rrm_ue_erb_list_data_compare );
        if(!p_node_to_be_deleted)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,
                    RRM_DETAILED,
                    "Erab not found for deletion from erab priority list ");
            return_value = RRM_FAILURE;
        }
        else
        {
            ylDelete(&ue_erab_priority_list[list_index],
                    (YLNODE*)p_node_to_be_deleted);
            RRM_TRACE(g_cellm_log_on_off,
                    p_rrm_cellm_facility_name,
                    RRM_DETAILED,
                    "Deletion successful from erab priority list from index [%d]",
                    list_index);
            RRM_MEM_FREE(p_node_to_be_deleted);
        }
    }
    RRM_UT_TRACE_EXIT();
    return(return_value);
}


/******************************************************************************
 *   FUNCTION NAME: rrm_ue_delete_erb_entity
 *   DESCRIPTION:
 *          This function delete the UE RAB information to the global list
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE)
 ******************************************************************************/

    rrm_return_et 
rrm_ue_delete_erb_entity(
        rrm_ue_erb_t *p_ue_erab
        )
{
    U8 list_index = RRM_NULL;
    /* coverity : CID 16399*/
    rrm_return_et return_value = RRM_SUCCESS;
    rrm_ue_erb_list_t *p_node_to_be_deleted = RRM_NULL;
    U8 erab_priority = RRM_NULL;
    U8 preemption_vulnerability = RRM_NULL;
    U8 erb_index = RRM_NULL;
    RRM_UT_TRACE_ENTER();

    if(!p_ue_erab)
    {
        return_value = RRM_FAILURE;
    }
    else if((erb_index = rrm_ue_find_erb_index(p_ue_erab)) != RRM_INVALID_RETURN)
    {
        erab_priority = p_ue_erab->p_rrm_ue_context->drb_configured.
            erab_item[erb_index].
            erab_level_qos_params.alloc_and_reten_prior.priority_level;
        preemption_vulnerability =  p_ue_erab->p_rrm_ue_context->drb_configured.
            erab_item[erb_index].
            erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability;
        if(RRM_UE_ERB_NO_ARP  == erab_priority) 
        {
            return_value = RRM_FAILURE;
        }
        else
        {
            if(RRM_TRUE == preemption_vulnerability)
            {
                list_index = RRM_UE_ERB_LOWEST_ARP - erab_priority;
            }
            else
            {
                list_index = (RRM_TWO*RRM_UE_ERB_LOWEST_ARP+RRM_ONE) - erab_priority;
            }
        }
    }
    else
    {
        return_value = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "ERAB id [%d] does not exist in the drb configurd List", p_ue_erab->erab_id);
    }
    if(return_value)
    {
        p_node_to_be_deleted = (rrm_ue_erb_list_t *) ylFind(&ue_erab_priority_list[list_index], 
                p_ue_erab, rrm_ue_del_req_object_id_keyof , 
                rrm_ue_erb_list_data_compare );
        if(!p_node_to_be_deleted)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Erab not found for deletion from erab priority list ");
            return_value = RRM_FAILURE;
        }
        else
        {
            ylDelete(&ue_erab_priority_list[list_index], (YLNODE *)p_node_to_be_deleted);
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Deletion  successful from erab priority list from index [%d]", list_index);
            RRM_MEM_FREE(p_node_to_be_deleted);
        }
    }
    RRM_UT_TRACE_EXIT();
    return(return_value);
}

/*****************************************************************************
 * Function Name  : rrm_ue_delete_req_from_ue_priority_list_key
 * Inputs         : p_ylnode - Pointer to scan data.
 * Outputs        : None
 * Returns        :
 * Description    : This function is the keyof function for the nmmctl_scan_record_t
 *                  linked list.
 ****************************************************************************/
static const rrm_void_t * rrm_ue_delete_req_from_ue_priority_list_key(const YLNODE *p_ylnode)
{
    return  (((rrm_ue_priority_node_t *) p_ylnode)->p_rrm_ue_context);
}


/*****************************************************************************
 * Function Name  : rrm_ue_del_req_object_id_keyof
 * Inputs         : p_ylnode - Pointer to scan data.
 * Outputs        : None
 * Returns        : 
 * Description    : This function is the keyof function for the nmmctl_scan_record_t
 *                  linked list.
 ****************************************************************************/
static const rrm_void_t * rrm_ue_del_req_object_id_keyof(const YLNODE *p_ylnode)
{
    return  &(((rrm_ue_erb_list_t *) p_ylnode)->ue_erb);
}

/*****************************************************************************
 * Function Name  : rrm_ue_erb_list_data_compare
 * Inputs         : p_key1 - Pointer to the data1 to be compaired
 *                  p_key2 - Pointer to the data2 to be compaired
 * Outputs        : None
 * Returns        : 0 if data1 is same as data2
 *                  1 if data1 is not same as data2
 * Description    : This function compares the key passed to retrieve correct
 *                  node from linked list.
 ****************************************************************************/
    static int rrm_ue_erb_list_data_compare
(
 const rrm_void_t *p_key1,
 const rrm_void_t *p_key2
 )
{
    /*SPR 4774 START*/
    if ((((rrm_ue_erb_t *)p_key1)->p_rrm_ue_context == ((rrm_ue_erb_t *)p_key2)->p_rrm_ue_context) && 
            (((rrm_ue_erb_t *)p_key1)->erab_id == ((rrm_ue_erb_t *)p_key2)->erab_id))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Comparision completed \n");
        return (RRM_FAILURE);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Comparision not completed \n");
        return (RRM_SUCCESS);
    }
    /*SPR 4774 END*/
}

/*****************************************************************************
 * Function Name  : rrm_ue_priority_list_data_compare
 * Inputs         : p_key1 - Pointer to the data1 to be compaired
 *                  p_key2 - Pointer to the data2 to be compaired
 * Outputs        : None
 * Returns        : 0 if data1 is same as data2
 *                  1 if data1 is not same as data2
 * Description    : This function compares the key passed to retrieve correct
 *                  node from linked list.
 ****************************************************************************/
    static int rrm_ue_priority_list_data_compare
(
 const rrm_void_t *p_key1,
 const rrm_void_t *p_key2
 )
{
    /* SPR 17564 Fix Start */
    /*SPR 16504 Fix Start*/
    /*spr_22159_changes_start*/
    if((rrm_ue_context_t *)p_key1 == (rrm_ue_context_t *)p_key2)
        /*spr_22159_changes_end*/
        /*SPR 16504 Fix Stop*/
        /* SPR 17564 Fix End */
    {
        return (RRM_FAILURE);
    }
    else
    {
        return (RRM_SUCCESS);
    }
}
/*Bug_721_changes_start*/
/*****************************************************************************
 *  Function Name  : rrm_ue_update_erb_priority_list_flag
 *  Inputs         : erb_release_list - Pointer to the release list
 *  Outputs        : None
 *  Returns        : None
 *  Description    : This function resets the is_erb_selected_for_rel flag
 *****************************************************************************/
void
    rrm_ue_update_erb_priority_list_flag
(
 rrm_ue_erb_list_t * erb_release_list
 )
{
    U8          list_index = RRM_NULL;
    U8          check_point = (2*RRM_UE_ERB_LOWEST_ARP + 1);
    rrm_ue_erb_list_t       *p_temp = RRM_PNULL;
    rrm_bool_et  is_valid_node_found  = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    for(list_index = 0; list_index < check_point; list_index++)
    {
        p_temp = (rrm_ue_erb_list_t *) ue_erab_priority_list[list_index].node.next;
        while(p_temp)
        {
            if(RRM_ZERO == RRM_MEMCMP(&erb_release_list->ue_erb, &p_temp->ue_erb, sizeof(rrm_ue_erb_list_t *)))
            {
                p_temp->ue_erb.is_erb_selected_for_rel = RRM_FALSE;
                is_valid_node_found = RRM_TRUE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "ERB %d for [UE:%d] found in priority list, resetting the value of "
                        "is_erb_selected_for_rel to FALSE as this RAB is not released "
                        "though was selected for preemption",
                        erb_release_list->ue_erb.erab_id, erb_release_list->ue_erb.p_rrm_ue_context->ue_index);
                break;
            }
            p_temp = (rrm_ue_erb_list_t *)p_temp->pNode.next;
        }
        if(RRM_TRUE == is_valid_node_found)
        {
            break;
        }
    }
    if(RRM_FALSE == is_valid_node_found)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,"No erb present in erb_priority "
                "list, shall not be hit, some error");
    }
    RRM_UT_TRACE_EXIT();

}
/*Bug_721_changes_end*/

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_get_low_priority_gbr_erb 
 *   DESCRIPTION:
 *          This function provide the GBR rab with lowest priority
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE)
 ******************************************************************************/

rrm_return_et 
rrm_ue_get_low_priority_gbr_erb(
        rrm_ue_erb_t *p_ue_erb,
        rrm_ue_context_t *p_ue_context,
        rrm_ue_erab_setup_item_t *p_erab_to_be_setup,
        /*spr 17437 fix start*/
        U8            type
        /*spr 17437 fix stop*/

        )
{
    U8 			list_index = RRM_NULL;
    U8 			check_point = (RRM_TWO*RRM_UE_ERB_LOWEST_ARP + RRM_ONE);
    rrm_ue_erb_list_t       *p_temp = RRM_PNULL;
    /* SPR-18301 START */
    /* code deleted */
    /* SPR-18301 END */
    rrm_return_et 			return_value = RRM_SUCCESS;
    U8			valid_erb_found = RRM_FALSE;	
    /*spr 17437 fix start*/
    /* code deleted */
    /*spr 17437 fix end*/
    U8 			qci = RRM_NULL;
    U8 			erb_index = RRM_NULL;
    U8 			erab_priority = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    /*CID 96495 Start*/
    /*SPR 22036 Fix Start*/
    if((p_ue_context != RRM_PNULL) && (p_erab_to_be_setup != RRM_PNULL) && (p_ue_erb != RRM_PNULL)) 
    {
        /*CID 96495 End*/
        /* CID 97202 Start */
            erab_priority = p_erab_to_be_setup->erab_level_qos_params.alloc_and_reten_prior.priority_level;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    "erab_priority[%d]", erab_priority);
            if(RRM_UE_ERB_NO_ARP != erab_priority)
            {
                check_point = RRM_UE_ERB_LOWEST_ARP - erab_priority;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "check_point[%d]", check_point);
            }
            else
            {
                return_value = RRM_FAILURE;
            }
        /* To identify that rab for which we are trying to preempt resources, is itself not already selected for preemption */
        for(list_index = RRM_ZERO; list_index < check_point; list_index++)
        {
            p_temp = (rrm_ue_erb_list_t *) ue_erab_priority_list[list_index].node.next;
            while(p_temp)
            {
                if((p_temp->ue_erb.erab_id == p_erab_to_be_setup->erab_id ) &&
                        (p_temp->ue_erb.is_erb_selected_for_rel == RRM_TRUE))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "list_index[%d], [UE:%d] erb_id = [%d] is already selected for preemption",
                            list_index,  p_temp->ue_erb.p_rrm_ue_context->ue_index,
                            p_temp->ue_erb.erab_id);
                    return_value = RRM_FAILURE;
                    break;
                }
                p_temp = (rrm_ue_erb_list_t *)p_temp->pNode.next;
            }
        }


        if(return_value)
        {
            /*SPR 22036 Fix Stop*/
            /*Bug_721_changes_start*/
            for(list_index = RRM_ZERO; list_index < check_point; list_index++)
                /*Bug_721_changes_end*/
            {
                /* SPR-18301 START */
                p_temp = (rrm_ue_erb_list_t *) ue_erab_priority_list[list_index].node.next;
                /* SPR-18301 END */
                while(p_temp)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "list_index[%d], [UE:%d] erb_id = [%d]", 
                            list_index,  p_temp->ue_erb.p_rrm_ue_context->ue_index,
                            p_temp->ue_erb.erab_id);

                    if ((erb_index = rrm_ue_find_erb_index(&p_temp->ue_erb)) != RRM_INVALID_RETURN)
                    {
                        qci = p_temp->ue_erb.p_rrm_ue_context->drb_configured.
                            erab_item[erb_index].erab_level_qos_params.qci;
                        /*spr 17437 fix start*/
                       if (((qci > RRM_GBR_QCI_4 && qci < RRM_MAX_QCI_LIMIT)||
                                   /* SPR 20916 Fix Start*/
                                   (p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_ue_context->cell_index]->
                                    epc_info.epc_params.emergency_erab_arp ==
                                    p_temp->ue_erb.p_rrm_ue_context->drb_configured.erab_item[erb_index].
                                    erab_level_qos_params.alloc_and_reten_prior.priority_level)) ||
				    /* SPR 19968 +- */
                               /* SPR 20916 Fix Stop */
                               (p_temp->ue_erb.is_erb_selected_for_rel == RRM_TRUE) ||
                               (RRM_ZERO  == p_temp->ue_erb.p_rrm_ue_context->drb_configured.erab_item[erb_index].
                                erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability)||
                               (RRM_UE_STATE_ACTIVE != p_temp->ue_erb.p_rrm_ue_context->ue_state) ||
                               /* SPR-17978 START */
                               /* code deleted */
                               /* SPR-17978 END */
                                /*SPR 22036 Fix Start*/
                                ((p_ue_context->ue_index == p_temp->ue_erb.p_rrm_ue_context->ue_index) &&
                                 p_temp->ue_erb.erab_id == p_erab_to_be_setup->erab_id ))
                            /*SPR 22036 Fix Stop*/
                           /*spr 17437 fix start*/

					   {
						   p_temp = (rrm_ue_erb_list_t *)p_temp->pNode.next;
						   continue;
					   }
					   p_ue_erb->p_rrm_ue_context = p_temp->ue_erb.p_rrm_ue_context;
					   p_ue_erb->erab_id = p_temp->ue_erb.erab_id;
					   /*Bug_721_changes_start*/
					   p_ue_erb->is_erb_selected_for_rel = p_temp->ue_erb.is_erb_selected_for_rel = RRM_TRUE;
					   /*Bug_721_changes_end*/
					   valid_erb_found = RRM_TRUE;
					   RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
							   "erb to be released found : [UE:%d] erb_id = [%d]", 
							   p_ue_erb->p_rrm_ue_context->ue_index, p_ue_erb->erab_id);
                       /* SPR-18301 START */
                       /* code deleted */
                       /* SPR-18301 END */
                       break;

				   }
				   else
				   {
					   erb_index = RRM_INVALID_RETURN;
					   RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING, 
                            "ERAB id [%d] does not exist in the drb configurd List", p_temp->ue_erb.erab_id);
					   /* Coverity ID 78451 Fix Start*/
					   p_temp = (rrm_ue_erb_list_t *)p_temp->pNode.next;
					   /* Coverity ID 78451 Fix End*/

				   }
			   }
			   /* Coverity ID 78451 Fix Start*/
			   if(valid_erb_found)
				   /* Coverity ID 78451 Fix End*/
			   {
				   break;
			   }
		   }
	   }
   /*CID 96495 Start*/
   }
   /*CID 96495 End*/
    /*SPR 22036 Fix Start*/
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING, 
                "p_ue_context || p_erab_to_be_setup || p_ue_erb is NULL");
    }
    /*SPR 22036 Fix Stop*/
   if(RRM_FALSE == valid_erb_found )
   {
	   return_value = RRM_FAILURE;
   }
   RRM_UT_TRACE_EXIT();
   return (return_value);
   /* CID 97202 End */
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_get_low_priority_erb
 *   DESCRIPTION:
 *          This function provide the gbr rab with lowest priority
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE)
 ******************************************************************************/

rrm_return_et 
rrm_ue_get_low_priority_erb( 
        rrm_ue_erb_t *p_ue_erb, 
        rrm_ue_context_t *p_ue_context, 
        rrm_ue_erab_setup_item_t *p_erab_to_be_setup
        )
{
    static U8 			s_list_index = RRM_NULL;
    static rrm_ue_erb_list_t 	*p_s_temp = RRM_PNULL;
    static U8 			s_erab_id = RRM_NULL;
    static rrm_ue_context_t 	*p_s_ue_context = RRM_PNULL;

    /* SPR 17564 Fix Start */
    /* Code Removed */
    /* SPR 17564 Fix End */
    rrm_return_et 			return_value = RRM_SUCCESS;
    U8 				check_point = RRM_NULL;
    U8 				is_non_preemptable_erb_present = RRM_FALSE;
    U8 				erab_priority = RRM_NULL;
    U8                      	qci = RRM_NULL;
    rrm_bool_et			valid_erab_found = RRM_FALSE;
    U8				erb_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(p_ue_erb && p_ue_context && p_erab_to_be_setup)
    {
        if( p_s_ue_context != p_ue_context || s_erab_id != p_erab_to_be_setup->erab_id)
        {
            s_list_index = RRM_NULL;
            s_erab_id = RRM_NULL;
            p_s_ue_context = RRM_PNULL;
            p_s_temp = (rrm_ue_erb_list_t *) ue_erab_priority_list[s_list_index].node.next; 
        }
        else
        {
            s_erab_id = p_erab_to_be_setup->erab_id;
            p_s_ue_context = p_ue_context;
        }
        erab_priority = p_erab_to_be_setup->erab_level_qos_params.alloc_and_reten_prior.priority_level;
        /* SPR 17564 Fix Start */
        /* Code Removed */
        /* SPR 17564 Fix End */
        check_point = (RRM_UE_ERB_LOWEST_ARP - erab_priority);

        if(erab_priority == RRM_UE_ERB_NO_ARP)
            return_value = RRM_FAILURE;
    }
    else
    {
        /* Resetting the params*/
        s_list_index = RRM_NULL;
        s_erab_id = RRM_NULL;
        p_s_ue_context = RRM_PNULL;
        p_s_temp = (rrm_ue_erb_list_t *) ue_erab_priority_list[s_list_index].node.next;
        return_value = RRM_FAILURE;
    }
    if (return_value)
    {	
        for(; s_list_index < check_point; s_list_index++)
        {
            while(p_s_temp)
            {
                if ((erb_index = rrm_ue_find_erb_index(&p_s_temp->ue_erb)) != RRM_INVALID_RETURN)
                {
                    qci = p_s_temp->ue_erb.p_rrm_ue_context->drb_configured.
                        erab_item[erb_index].erab_level_qos_params.qci;
                    if (qci > RRM_GBR_QCI_4 && qci < RRM_MAX_QCI_LIMIT)
                    {		
                        is_non_preemptable_erb_present = find_ngbr_non_preemptable_erb_present
                            (p_s_temp->ue_erb.p_rrm_ue_context);
                    }
                    if (is_non_preemptable_erb_present)
                    {
                        p_s_temp = (rrm_ue_erb_list_t *)p_s_temp->pNode.next;
                        continue;
                    }
                    p_ue_erb->p_rrm_ue_context = p_s_temp->ue_erb.p_rrm_ue_context;
                    p_ue_erb->erab_id = p_s_temp->ue_erb.erab_id;

                    valid_erab_found = RRM_TRUE;
                    if(!p_s_temp->pNode.next)
                    {
                        s_list_index++;
                        p_s_temp = (rrm_ue_erb_list_t *) ue_erab_priority_list[s_list_index].node.next;
                    }
                    else
                    {
                        p_s_temp = (rrm_ue_erb_list_t *)p_s_temp->pNode.next;
                    }
                    break;
                }
                else
                {
                    erb_index = RRM_INVALID_RETURN;
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,"ERAB id [%u] does not exist in the drb configurd List", p_s_temp->ue_erb.erab_id);				
                    break;
                }
            }
            if(erb_index == RRM_INVALID_RETURN)
            {
                return_value = RRM_FAILURE;
                break;
            }
            else if(valid_erab_found)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "erb to be released found : [UE:%d] erb_id = [%d]", p_ue_erb->p_rrm_ue_context->ue_index, p_ue_erb->erab_id);
                break;
            }
            /* SPR 17564 Fix Start */
            else if((s_list_index == check_point-RRM_ONE) && (RRM_TRUE == rrm_is_ue_special_previledge(p_ue_context)))
                /* SPR 17564 Fix End */
            {
                check_point = (RRM_TWO*RRM_UE_ERB_LOWEST_ARP + RRM_ONE) ;
            }
            else if(!(check_point  == (RRM_TWO*RRM_UE_ERB_LOWEST_ARP + RRM_ONE)) )
            {
                p_s_temp = (rrm_ue_erb_list_t *) ue_erab_priority_list[s_list_index+1].node.next;
            }
        }
    }
    if(!valid_erab_found)
    {
        return_value = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return(return_value);
}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_insert_ue_to_priority_list 
 *   DESCRIPTION:
 *          This function  will insert the ue to the ue priority list.
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE)
 ******************************************************************************/

    rrm_return_et
rrm_ue_insert_ue_to_priority_list(
        rrm_ue_context_t *p_ue_context /* The Incoming UE to be inserted */
        )
{
    rrm_return_et 		return_value = RRM_SUCCESS;
    U8 			list_index = RRM_NULL;
    rrm_ue_priority_node_t	*p_ue_priority_node = RRM_PNULL;
    S8 ue_priority = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    /* Check for incoming ue_context = RRM_PNULL*/
    if(!p_ue_context)
    {
        return_value = RRM_FAILURE;
    }
    else
    {
        ue_priority = rrm_ue_get_ue_priority(p_ue_context);
        /*LTE_RRM_KLOCWORK_WARN_25_JUL_START*/
        if(ue_priority == RRM_INDEX_ERR || RRM_UE_NO_PRIORITY <= ue_priority)
            /*LTE_RRM_KLOCWORK_WARN_25_JUL_END*/
        {
            return_value = RRM_FAILURE;
        }
        else
        {
            list_index = ue_priority;
        }

        /* Checking for NO PRIORITY*/
        if( RRM_SUCCESS == return_value )
        {
            /* Creating the node to be inserted in the ue priority list*/
            p_ue_priority_node = (rrm_ue_priority_node_t *)rrm_mem_get(sizeof(rrm_ue_priority_node_t));
            if ( p_ue_priority_node == RRM_PNULL)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "Memory allocation to p_ue_priority_node failed" );
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }
            else
            {
                p_ue_priority_node->p_rrm_ue_context = p_ue_context;
                /* Inserting the UE in the priority list*/
                ylPushTail(&(ue_priority_list[list_index]), (YLNODE *)p_ue_priority_node);
                /* SPR 17564 Fix Start */
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        /* SPR 17564 Fix End */
                        "[UE:%d] inserted to priority list successfully at index [%d]", p_ue_context->ue_index, list_index);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return(return_value);

}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_delete_ue_from_priority_list 
 *   DESCRIPTION:
 *          This funtion will delete the ue from the ue priority list.
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE)
 ******************************************************************************/
    rrm_return_et
rrm_ue_delete_ue_from_priority_list(
        rrm_ue_context_t *p_ue_context /* The Incoming UE to be Deleted */
        )
{

    U8 list_index = RRM_NULL;
    rrm_return_et return_value = RRM_SUCCESS;

    rrm_ue_priority_node_t *p_node_to_be_deleted = RRM_PNULL;
    S8 ue_priority = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    if (RRM_PNULL == p_ue_context)
    {
        return_value = RRM_FAILURE;
    }
    else
    {
        ue_priority     = rrm_ue_get_ue_priority(p_ue_context);
        /*LTE_RRM_KLOCWORK_WARN_25_JUL_START*/
        if(ue_priority == RRM_INDEX_ERR || RRM_UE_NO_PRIORITY <= ue_priority)
            /*LTE_RRM_KLOCWORK_WARN_25_JUL_END*/
        {
            return_value = RRM_FAILURE;
        }
        else
        {
            list_index = ue_priority;
        }
        if(RRM_SUCCESS == return_value)
        {
            p_node_to_be_deleted = (rrm_ue_priority_node_t *) ylFind(&ue_priority_list[list_index], 
                    p_ue_context , rrm_ue_delete_req_from_ue_priority_list_key , 
                    rrm_ue_priority_list_data_compare );
            if (RRM_PNULL == p_node_to_be_deleted)
            {
                return_value = RRM_FAILURE;
            }
            else
            {
                /* SPR 17564 Fix Start */
                p_ue_context->ue_priority = RRM_UE_NO_PRIORITY;
                /* SPR 17564 Fix End */

                ylDelete(&ue_priority_list[list_index], (YLNODE *)p_node_to_be_deleted);
                RRM_MEM_FREE(p_node_to_be_deleted);
                /* SPR 17564 Fix Start */
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        /* SPR 17564 Fix End */
                        "[UE:%d] deleted successfully  priority list sucessfully from index [%d]", p_ue_context->ue_index, list_index);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return(return_value);

}

/******************************************************************************
 *   FUNCTION NAME: rrm_ue_get_low_priority_ue
 *   DESCRIPTION:
 *         	will provide the lowest priority ue to be released 
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE)
 ******************************************************************************/
rrm_return_et
rrm_ue_get_low_priority_ue(
/*spr_22158_changes_start*/
	rrm_cell_index_t  cell_index,
/*spr_22158_changes_end*/
        /*Bug_721_changes_start*/
        rrm_ue_index_t *p_ue_index, /* Outgoing UE context*/
        rrm_ue_index_t  ue_index,
        U8              current_ue_priority,
        rrm_bool_et is_ue_check_reqd
        /*Bug_721_changes_end*/
        )
{
    rrm_return_et 		return_value = RRM_SUCCESS;
    U8 			list_index = RRM_NULL;
    U8 			check_list = RRM_MAX_UE_PRIORITY;    /* 2*RRM_UE_ERB_NO_ARP; */ /* =30 (Max capacity of priority List) */
    /*Bug_721_changes_start*/
    if((RRM_TRUE == is_ue_check_reqd) && (RRM_ZERO != current_ue_priority))
    {
        check_list = RRM_UE_ERB_LOWEST_ARP - current_ue_priority;
    }
    rrm_bool_et         low_priority_ue_found = RRM_FALSE;
    /*Bug_721_changes_end*/
    rrm_ue_priority_node_t 	*p_temp = RRM_PNULL;
    /* coverity : CID 16401*/
    rrm_bool_et         first_low_priority_ue_csg_mem = RRM_FALSE;
    rrm_ue_index_t      csg_ue_index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /*SPR 16060 Fix Start*/
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "Value of checklist is[%d]", check_list);
    /*SPR 16060 Fix End*/

    if(RRM_PNULL == p_ue_index)
    {
        return_value = RRM_FAILURE;
    }
    else
    {
        /*Bug_851_changes_start*/
        for(list_index = RRM_ZERO; list_index < check_list ; list_index++)
            /*Bug_851_changes_end*/
        {
            p_temp = (rrm_ue_priority_node_t *)ue_priority_list[list_index].node.next;
            while (p_temp)
            {
                *p_ue_index = p_temp->p_rrm_ue_context->ue_index;
                /*Bug_851_changes_start*/
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                        "Processing [UE:%d], Action Bit[%d], CSG Status[%d]", 
                        *p_ue_index, p_temp->p_rrm_ue_context->action_triggered,
                        p_temp->p_rrm_ue_context->rrm_csg_membership.rrm_csg_membership_status);
                /*Bug_851_changes_end*/
                /* SPR 19968 Start */
                /* SPR 21995 Start */
                if (RRM_NO_ACTN_ON_UE == p_temp->p_rrm_ue_context->action_triggered) 
                    /* SPR 21995 End */
                    /* SPR 19968 End */
                {
                    /* SPR 21995 Start */
                    /*spr_22158_changes_start*/
                    if((cell_index == p_temp->p_rrm_ue_context->cell_index) && (RRM_FALSE == p_temp->p_rrm_ue_context->adm_ctrl_rec.is_ue_already_selected) &&
                            (((RRM_TRUE == is_ue_check_reqd) &&
                              (ue_index != *p_ue_index)) || ((RRM_FALSE == is_ue_check_reqd))))
                    /*spr_22158_changes_end*/
		    {
			    /* SPR 21995 End */
			    if ( (RRM_NOT_MEMBER ==  p_temp->p_rrm_ue_context->rrm_csg_membership.rrm_csg_membership_status) ||
					    (RRM_INVALID ==  p_temp->p_rrm_ue_context->rrm_csg_membership.rrm_csg_membership_status))
			    {
				    /*Bug_721_changes_start*/
				    /*spr 17437 fix start*/
				    /* SPR 19968 Start */
				    /* SPR 21995 +- */
				    /* SPR 19968 End */
				    /*spr 17437 fix stop*/
				    /* SPR 17564 Fix Start */
				    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
						    /* SPR 17564 Fix End */
						    "UE to be released found :[UE:%d] CSG status[%d]", p_temp->p_rrm_ue_context->ue_index,
						    p_temp->p_rrm_ue_context->rrm_csg_membership.rrm_csg_membership_status);

				    low_priority_ue_found = RRM_TRUE;
				    first_low_priority_ue_csg_mem = RRM_FALSE; 
				    break;
			    }
			    /*Bug_721_changes_end*/
			    else
			    {
				    if (RRM_FALSE == first_low_priority_ue_csg_mem)
				    {
					    csg_ue_index = 
						    p_temp->p_rrm_ue_context->ue_index;
					    first_low_priority_ue_csg_mem = RRM_TRUE; 
					    /*Bug_851_changes_start*/
					    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
							    "Low Priority CSG UE found : [UE:%d]", p_temp->p_rrm_ue_context->ue_index);
					    /*Bug_851_changes_end*/
				    }
			    }
		    }
		}
                p_temp = (rrm_ue_priority_node_t *)p_temp->pNode.next;
            }
            if(low_priority_ue_found == RRM_TRUE)
            {
                break;
            }
        }
    }
    /*Bug_721_changes_start*/
    /* SPR_15696_Fix: Start */
    if((!low_priority_ue_found) && (RRM_FALSE == first_low_priority_ue_csg_mem))
        /* SPR_15696_Fix: End */
        /*Bug_721_changes_end*/
    {
        return_value = RRM_FAILURE;
    }
    if (RRM_TRUE == first_low_priority_ue_csg_mem)
    {
        *p_ue_index = csg_ue_index;
    }

    /*SPR 16060 Fix Start*/
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "Value of list_index is[%d]", list_index);
    /*SPR 16060 Fix End*/

    RRM_UT_TRACE_EXIT();
    return(return_value);
}
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_update_ue_priority_list
 *   DESCRIPTION:
 *              will update the ue priority list
 *   RETURNS:
 *             rrm_return_et(SUCCESS / FAILURE)
 ******************************************************************************/
    rrm_return_et
rrm_ue_update_ue_priority_list(
        rrm_ue_context_t *p_ue_context /* Incoming UE context*/
        )
{
    U8              erb_index = RRM_NULL;
    U8		current_erab_priority = RRM_UE_ERB_LOWEST_ARP;
    U8 		erab_arp_vulnurability = RRM_FALSE;
    U8		new_ue_priority = RRM_UE_NO_PRIORITY + RRM_ONE;
    rrm_return_et	return_value = RRM_SUCCESS;
    U8              erab_count = RRM_NULL;
    U8		old_ue_priority = RRM_NULL;
    U8		ue_erab_priority_index = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Stored UE Priority(%d)", 
            p_ue_context->ue_priority);
    if((!p_ue_context) || 
            (p_ue_context->ue_priority == RRM_UE_NO_PRIORITY))
    {
        return_value = RRM_FAILURE;
    }
    else
    {
        erab_count = p_ue_context->drb_configured.num_of_list;
        old_ue_priority = p_ue_context->ue_priority;
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Erab Count(%d), Old UE Priority(%d)", 
                erab_count, old_ue_priority);
        if(RRM_NULL == erab_count)
        {
            new_ue_priority = RRM_ZERO;
        } 
        else
        {	
            for(erb_index = RRM_ZERO; erb_index < erab_count ; erb_index++)
            {
                current_erab_priority = p_ue_context->drb_configured.erab_item[erb_index].
                    erab_level_qos_params.alloc_and_reten_prior.priority_level;
                erab_arp_vulnurability = p_ue_context->drb_configured.erab_item[erb_index].
                    erab_level_qos_params.alloc_and_reten_prior.preemption_vulnerability;
                if(RRM_UE_ERB_NO_ARP  == current_erab_priority)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                            " UE have ERB with NO ARP ");
                    new_ue_priority = RRM_UE_NO_PRIORITY;
                    if ( RRM_FAILURE == rrm_ue_delete_ue_from_priority_list(p_ue_context) )
                    {
                        return_value = RRM_FAILURE;
                    }
                    p_ue_context->ue_priority = RRM_UE_NO_PRIORITY;
                    break;
                }
                if(RRM_FALSE == erab_arp_vulnurability)
                {
                    ue_erab_priority_index = RRM_TWO*(RRM_UE_ERB_LOWEST_ARP)+RRM_ONE - current_erab_priority;
                }
                else
                {
                    ue_erab_priority_index = RRM_UE_ERB_LOWEST_ARP - current_erab_priority;
                }
                if( (new_ue_priority == RRM_UE_NO_PRIORITY + RRM_ONE) || new_ue_priority < ue_erab_priority_index ) /* Current erab is of Higher Priority*/
                {
                    new_ue_priority = ue_erab_priority_index;
                }
            }
        }
        if(RRM_UE_ERB_NO_ARP  != current_erab_priority)
        {  
            /* Comparing OLD and NEW ue Priority*/
            if((new_ue_priority != old_ue_priority) && (new_ue_priority != RRM_UE_NO_PRIORITY + RRM_ONE))	
            {
                /* Delete the old entry of the ue from the priority list*/
                if ( RRM_FAILURE == rrm_ue_delete_ue_from_priority_list (p_ue_context) )
                {	
                    return_value = RRM_FAILURE;
                }
                else
                {
                    p_ue_context->ue_priority = new_ue_priority;
                }
                /* Insert the new ue entry to the priority list*/
                if (RRM_SUCCESS == return_value && RRM_FAILURE == rrm_ue_insert_ue_to_priority_list (p_ue_context) )
                {
                    return_value = RRM_FAILURE;
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return(return_value);
}



/* UE MEAS CHANGES : STARTS */

/* CSR00069389 Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_enqueue_meas_config_cgi_node 
 *   DESCRIPTION:
 *          This function enqueues a node in procedure queue for the meas config  
 *          request to RRC for CGI Reporting purpose
 *   RETURNS:
 *             rrm_return_et
 ******************************************************************************/
    rrm_return_et
rrm_ue_enqueue_meas_config_cgi_node(
        rrm_ue_context_t             *p_ue_context,
        rrm_rat_type_et              rat_type,
        U16                          arfcn,
        U8                           band_ind,
        U8                           band_class,
        U16                          cgi
        )
{
    rrm_return_et                       ret_val                         = RRM_SUCCESS;
    rrm_ue_procedure_queue_t            proc_queue                      = {RRM_ZERO};
    rrm_ue_meas_config_cgi_queue_node_t *p_meas_config_cgi_queue_node   = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_meas_config_cgi_queue_node = (rrm_ue_meas_config_cgi_queue_node_t *)
        rrm_mem_get(sizeof(rrm_ue_meas_config_cgi_queue_node_t));

    if(RRM_PNULL == p_meas_config_cgi_queue_node)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        ret_val = RRM_FAILURE;
    }
    else
    {
        p_meas_config_cgi_queue_node->rat_type = rat_type;
        p_meas_config_cgi_queue_node->arfcn = arfcn;

        p_meas_config_cgi_queue_node->band_ind = band_ind;
        p_meas_config_cgi_queue_node->band_class = band_class;
        p_meas_config_cgi_queue_node->cgi = cgi;

        proc_queue.api_id = RRC_RRM_MEAS_CONFIG_REQ;
        proc_queue.p_proc_data = p_meas_config_cgi_queue_node;
        /*SPR 16642 START*/
        /*BUG 13332:start*/
        //proc_queue.trans_id = p_ue_context->p_proc_queue_first_meas_node->proc_queue.trans_id;
        /*BUG 13332:end*/
        /*SPR 16642 END*/

        /* Enqueue details for Requesting CGI later */
        /*SPR 18241 START*/
        rrm_ue_mgr_enqueue_req( &proc_queue, p_ue_context,RRM_FALSE);
        /*SPR 18241 END*/
        /* SPR 15441 start */
        RRM_MEM_FREE(p_meas_config_cgi_queue_node); 
        /* SPR 15441 end */
        ret_val = RRM_SUCCESS;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* CSR00069389 End */

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_send_meas_config_req_for_cgi_reporting 
 *   DESCRIPTION:
 *          This function is prepares and sends the meas config request to RRC 
 *          for CGI Reporting purpose
 *   RETURNS:
 *             rrm_void_et
 ******************************************************************************/
    rrm_return_et
rrm_uem_send_meas_config_req_for_cgi_reporting(
        rrm_cell_context_t              *p_cell_context,
        rrm_son_meas_config_req_t       *p_meas_config_req
        )
{
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context           = RRM_PNULL;
    /* SPR 20652 Fix End */
    /* CSR00069389 Start */
    rrm_return_et       ret_val                 = RRM_SUCCESS; 
    U16                 error_code              = RRM_NO_ERROR;
    U16			        req_list_index		    = RRM_NULL;
    U16                 geran_cgi               = RRM_NULL;
    U16			        index			        = RRM_NULL;
    /* Coverity 64266 fix start */
    rrm_ue_meas_config_cgi_queue_node_t report_cgi_req_info ;
    /* Coverity 64266 fix end */
    rrm_ue_meas_config_t *p_meas_config_info    = RRM_PNULL;
    /* CSR00069389 End */
    /*SPR_15325 start*/
    rrm_bool_et         configure_autonomous_gap = RRM_FALSE;
    /*SPR_15325 end*/

    RRM_UT_TRACE_ENTER();
    /* SPR 16406 8SEP start */
    /* Code removed */
    /* SPR 16406 8SEP end */

    /* Find the UE context */
    /* SPR 20652 Fix Start */
    /* Code Removed */
    p_ue_context = rrm_ue_find_context(p_meas_config_req->ue_index, 
            p_cell_context->cell_index);
    if(RRM_PNULL == p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "UE Context not found corresponding to [UE:%d]",
                p_meas_config_req->ue_index); 	
        /*Coverity 82381 Fix Start*/
        /*error_code = RRM_ERR_UE_NOT_CONFIGURED;*/
        /*Coverity 82381 Fix Start*/
#ifdef RRM_UT_FLAG
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F);
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.meas_config_resp_F_ue_not_configured);
#endif                
    }    
    /* CSR00069389 Start */
    /* SPR 16406 8SEP start */
    else 
    {
        /*SPR_18491_START*/
        if ((RRM_FALSE  ==  p_ue_context->interfreq_interrat_meas_configured) &&
                (p_ue_context->current_procedure.state == RRM_UE_ERB_NULL))
            /*SPR_18491_END*/
        {
            /* SPR_16061_Fix: Start*/
            /* Code moved below */
            /* SPR_16061_Fix: End */
            /* SPR 16406 8SEP start */
            /* Code removed */
            /* SPR 16406 8SEP end */
            /* Arfcn list size = 1 for Report CGI req */
            if(RRM_ZERO < p_meas_config_req->eutran_config_list_size)
            {
                report_cgi_req_info.rat_type = RRM_EUTRAN_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->eutran_config_list[req_list_index].earfcn;
                report_cgi_req_info.band_ind = RRM_INVALID_RETURN;
                report_cgi_req_info.band_class = RRM_INVALID_RETURN;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);

                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    /*SPR 16219 fix start */
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /*SPR 16219 fix end */
                        /* SPR_16061_Fix: Start*/
                        /*SPR 15314 START*/
                        if(p_ue_context->cdrx_status == RRM_UE_CDRX_DISABLED)
                        {
                            /*SPR_15325 start*/
                            if ((RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT & p_ue_context->ue_capability_params.bitmask) &&
                                    (RRM_REL9 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                                     eutra_radio_capability_info_def.access_stratum_release))
                            {
                                configure_autonomous_gap =
                                    rrm_uem_check_configure_auto_gap_or_cdrx_for_eutra(p_cell_context, p_ue_context);
                            }
                            /* If Autonomous gap is not supported by the UE, C-DRX will need to be configured
                               at the time of CGI reporting */
                            if(RRM_FALSE == configure_autonomous_gap)
                            {
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                        "CDRX will be applied to the UE at the time of CGI reporting");
                                if((RRM_UE_ERB_NULL == p_ue_context->current_procedure.state) &&
                                        (p_ue_context->procedure_awaited_state == RRM_UE_ERB_NULL))

                                    /*SPR 15314 END*/
                                {
                                    p_ue_context->cdrx_status = RRM_UE_CDRX_TO_BE_APPLIED;
                                    if (RRM_FAILURE == rrm_build_and_send_ue_reconfig_req(p_ue_context))
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                                "Failed to send UE reconfig request, [UE:%d]",
                                                p_ue_context->ue_index);
                                        p_ue_context->cdrx_status = RRM_UE_CDRX_DISABLED;
                                    }
                                    else
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                                "UE reconfig request sent to [UE:%d] for rat type [%d]"
                                                " to apply CDRX for CGI reporting",
                                                p_ue_context->ue_index, p_ue_context->rat_configured);

                                        /* SPR 15539 Start */
                                        p_ue_context->is_cgi_process_in_progress = RRM_TRUE;
                                        /* SPR 15539 End */
                                    }
                                }
                            }
                            /*SPR_15325 end*/
                        }
                        /* SPR_16061_Fix: End */
                        /*SPR 15314 START*/
                        if((RRM_UE_ERB_NULL == p_ue_context->current_procedure.state) &&
                                (RRM_PNULL == p_ue_context->p_proc_queue_first_meas_node) &&
                                (p_ue_context->procedure_awaited_state == RRM_UE_ERB_NULL) &&
                                /* SPR 15860 Start */
                                (RRM_FALSE == rrm_ue_is_cgi_report_pending(p_ue_context)))
                            /* SPR 15860 End */

                            /*SPR 15314 END*/

                        {
                            /* SPR 12793 Start */
                            /* If CDRX is to be applied, send CDRX configuration for the UE and queue all the CGIs
                               to be processed later upon receipt of UE Reconfig Resp */
                            /* SPR 12793 End */
                            for(index = RRM_ZERO; 
                                    index < p_meas_config_req->eutran_config_list[req_list_index].cells_for_which_to_report_cgi_size; 
                                    index++)
                            {
                                report_cgi_req_info.cgi = p_meas_config_req->eutran_config_list[req_list_index].
                                    cells_for_which_to_report_cgi[index];
                                error_code = rrm_ue_send_meas_config_req_for_report_cgi(p_ue_context, report_cgi_req_info); 
                                if(RRM_NO_ERROR == error_code) 
                                {
                                    index++;
                                    p_meas_config_info->cgi_req_cnt++;
                                    break;
                                }
                            }
                        }

                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        for(; index < p_meas_config_req->
                                eutran_config_list[req_list_index].
                                cells_for_which_to_report_cgi_size; index++)
                        {
                            /* SPR 12793 End */
                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_EUTRAN_CELL,
                                        p_meas_config_req->eutran_config_list[req_list_index].earfcn, 
                                        RRM_INVALID_RETURN, RRM_INVALID_RETURN,
                                        p_meas_config_req->eutran_config_list[req_list_index].
                                        cells_for_which_to_report_cgi[index]))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }

                        }
                    }
                    /* SPR 16219 fix start */
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    }
                    /* SPR 16219 fix  end*/
                }
            }
            else if (RRM_ZERO < p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_fdd_list_size)
            {
                report_cgi_req_info.rat_type = RRM_UTRAN_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_fdd_list[req_list_index].uarfcn;
                report_cgi_req_info.band_ind = RRM_INVALID_RETURN;
                report_cgi_req_info.band_class = RRM_INVALID_RETURN;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);
                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    /*SPR 16219 fix start */
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /*SPR 16219 fix end */
                        if((RRM_UE_MEAS_CONFIG_REQ_ONGOING != p_ue_context->current_procedure.state) &&
                                (RRM_PNULL == p_ue_context->p_proc_queue_first_meas_node))
                        {
                            /* Send one CGI req */
                            for(index = RRM_ZERO; 
                                    index < p_meas_config_req->inter_rat_meas_config.utran_config_list.
                                    utran_fdd_list[req_list_index].cells_for_which_to_report_cgi_size; 
                                    index++)
                            {

                                report_cgi_req_info.cgi = p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_fdd_list[req_list_index].
                                    cells_for_which_to_report_cgi[index];
                                error_code = rrm_ue_send_meas_config_req_for_report_cgi(p_ue_context, report_cgi_req_info); 
                                if(RRM_NO_ERROR == error_code)
                                {
                                    index++;
                                    p_meas_config_info->cgi_req_cnt++;
                                    break;
                                }
                            }
                        }
                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        /* Spr 18615 Changes Start */
                        for(; index < p_meas_config_req->inter_rat_meas_config.geran_config_list.geran_freq_info_list_size;
                                index++)
                        {
                            RRM_MEMCPY(&geran_cgi, (U16 *) &p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                    geran_freq_info_list[index].cells_for_which_to_report_cgi[RRM_NULL],
                                    sizeof(rrm_son_geran_physical_cell_id_t));
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                    "Enqueuing report cgi for Geran arfcn = %d, cgi =%d",
                                    p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                    geran_freq_info_list[index].geran_car_freqs.starting_arfcn,geran_cgi);

                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_GERAN_CELL,
                                        p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                        geran_freq_info_list[index].geran_car_freqs.starting_arfcn, 
                                        p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                        geran_freq_info_list[index].geran_car_freqs.band_ind, RRM_INVALID_RETURN, geran_cgi))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }
                        }
                        /* Spr 18615 Changes End */    

                    }
                    /* SPR 16219 fix start */
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    }
                    /* SPR 16219 fix  end*/
                }	
            }
            else if (RRM_ZERO < p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_tdd_list_size)
            {
                report_cgi_req_info.rat_type = RRM_UTRAN_TDD_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_tdd_list[req_list_index].uarfcn;
                report_cgi_req_info.band_ind = RRM_INVALID_RETURN;
                report_cgi_req_info.band_class = RRM_INVALID_RETURN;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);
                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    /*SPR 16219 fix start */
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /*SPR 16219 fix end */
                        if((RRM_UE_MEAS_CONFIG_REQ_ONGOING != p_ue_context->current_procedure.state) &&
                                (RRM_PNULL == p_ue_context->p_proc_queue_first_meas_node))
                        {
                            for(index = RRM_ZERO; 
                                    index < p_meas_config_req->inter_rat_meas_config.utran_config_list.
                                    utran_tdd_list[req_list_index].cells_for_which_to_report_cgi_size; 
                                    index++)
                            {
                                report_cgi_req_info.cgi = p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_tdd_list[req_list_index].
                                    cells_for_which_to_report_cgi[index];
                                error_code = rrm_ue_send_meas_config_req_for_report_cgi(p_ue_context, report_cgi_req_info); 
                                if(RRM_NO_ERROR == error_code)
                                {
                                    index++;
                                    p_meas_config_info->cgi_req_cnt++;
                                    break;
                                }
                            }
                        }
                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        for(;index < p_meas_config_req->inter_rat_meas_config.
                                utran_config_list.utran_tdd_list[req_list_index].
                                cells_for_which_to_report_cgi_size; index++)
                        {
                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_UTRAN_TDD_CELL,
                                        p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_tdd_list[req_list_index].uarfcn,
                                        RRM_INVALID_RETURN, RRM_INVALID_RETURN,
                                        p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_tdd_list[req_list_index].
                                        cells_for_which_to_report_cgi[index]))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }

                        }
                    }
                    /* SPR 16219 fix start */
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    }
                    /* SPR 16219 fix  end*/
                }	
            }
            else if (RRM_ZERO < p_meas_config_req->inter_rat_meas_config.geran_config_list.geran_freq_info_list_size)
            {
                report_cgi_req_info.rat_type = RRM_GERAN_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->inter_rat_meas_config.geran_config_list.
                    geran_freq_info_list[req_list_index].geran_car_freqs.starting_arfcn;
                report_cgi_req_info.band_ind = p_meas_config_req->inter_rat_meas_config.geran_config_list.
                    geran_freq_info_list[req_list_index].geran_car_freqs.band_ind;
                report_cgi_req_info.band_class = RRM_INVALID_RETURN;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);
                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    /*SPR 16219 fix start */
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /*SPR 16219 fix end */
                        if((RRM_UE_MEAS_CONFIG_REQ_ONGOING != p_ue_context->current_procedure.state) &&
                                (RRM_PNULL == p_ue_context->p_proc_queue_first_meas_node))
                        {
                            for(index = RRM_ZERO; 
                                    index < p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                    geran_freq_info_list[req_list_index].cells_for_which_to_report_cgi_size;
                                    index++)
                            {
                                RRM_MEMCPY(&geran_cgi, (U16 *) &p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                        geran_freq_info_list[req_list_index].cells_for_which_to_report_cgi[index],
                                        sizeof(rrm_son_geran_physical_cell_id_t));
                                report_cgi_req_info.cgi = geran_cgi;
                                error_code = rrm_ue_send_meas_config_req_for_report_cgi(p_ue_context, report_cgi_req_info); 
                                if(RRM_NO_ERROR == error_code)
                                {
                                    index++;
                                    p_meas_config_info->cgi_req_cnt++;
                                    break;
                                }
                            }
                        }
                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        for(; index < p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                geran_freq_info_list[req_list_index].
                                cells_for_which_to_report_cgi_size; index++)
                        {
                            RRM_MEMCPY(&geran_cgi, (U16 *) &p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                    geran_freq_info_list[req_list_index].cells_for_which_to_report_cgi[index],
                                    sizeof(rrm_son_geran_physical_cell_id_t));

                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_GERAN_CELL,
                                        p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                        geran_freq_info_list[req_list_index].geran_car_freqs.starting_arfcn, 
                                        p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                        geran_freq_info_list[req_list_index].geran_car_freqs.band_ind, RRM_INVALID_RETURN, geran_cgi))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }
                        }
                    }
                    /* SPR 16219 fix start */
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    }
                    /* SPR 16219 fix end */
                }	
            }
            else if (RRM_ZERO < p_meas_config_req->inter_rat_meas_config.cdma_config_list.cdma_freq_info_list_size)
            {
                report_cgi_req_info.rat_type = RRM_CDMA_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                    cdma_freq_info_list[req_list_index].arfcn;
                report_cgi_req_info.band_ind = RRM_INVALID_RETURN;
                report_cgi_req_info.band_class = p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                    cdma_freq_info_list[req_list_index].band_class;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);
                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    /*SPR 16219 fix start */
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /*SPR 16219 fix end */
                        if((RRM_UE_MEAS_CONFIG_REQ_ONGOING != p_ue_context->current_procedure.state) &&
                                (RRM_PNULL == p_ue_context->p_proc_queue_first_meas_node))
                        {
                            for(index = RRM_ZERO; 
                                    index < p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                    cdma_freq_info_list[req_list_index].cells_for_which_to_report_cgi_size;
                                    index++)
                            {
                                report_cgi_req_info.cgi = p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                    cdma_freq_info_list[req_list_index].cells_for_which_to_report_cgi[index];
                                error_code = rrm_ue_send_meas_config_req_for_report_cgi(p_ue_context, report_cgi_req_info); 
                                if(RRM_NO_ERROR == error_code)
                                {
                                    index++;
                                    p_meas_config_info->cgi_req_cnt++;
                                    break;
                                }
                            }
                        }
                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        for(; index < p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                cdma_freq_info_list[req_list_index].
                                cells_for_which_to_report_cgi_size; index++)
                        {
                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_CDMA_CELL,
                                        p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                        cdma_freq_info_list[req_list_index].arfcn, RRM_INVALID_RETURN, 
                                        p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                        cdma_freq_info_list[req_list_index].band_class,
                                        p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                        cdma_freq_info_list[req_list_index].cells_for_which_to_report_cgi[index]))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }
                        }
                    }
                    /* SPR 16219 fix start */
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    }
                    /* SPR 16219 fix end */
                }	
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "NO PCI received in Meas Config request for reportCGI request");
                error_code = RRM_ERR_INVALID_PARAMS;
            }
        }
        else
        {

            /*SPR_18491_START*/
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,"Queuing the cgi requests from SON for [UE:%d]",p_ue_context->ue_index);

            if(RRM_ZERO < p_meas_config_req->eutran_config_list_size)
            {
                report_cgi_req_info.rat_type = RRM_EUTRAN_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->eutran_config_list[req_list_index].earfcn;
                report_cgi_req_info.band_ind = RRM_INVALID_RETURN;
                report_cgi_req_info.band_class = RRM_INVALID_RETURN;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);

                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        for(index = RRM_ZERO; index < p_meas_config_req->
                                eutran_config_list[req_list_index].
                                cells_for_which_to_report_cgi_size; index++)
                        {
                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_EUTRAN_CELL,
                                        p_meas_config_req->eutran_config_list[req_list_index].earfcn, 
                                        RRM_INVALID_RETURN, RRM_INVALID_RETURN,
                                        p_meas_config_req->eutran_config_list[req_list_index].
                                        cells_for_which_to_report_cgi[index]))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }

                        }
                    } 
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    } 
                }
            }
            else if (RRM_ZERO < p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_fdd_list_size)
            {
                report_cgi_req_info.rat_type = RRM_UTRAN_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_fdd_list[req_list_index].uarfcn;
                report_cgi_req_info.band_ind = RRM_INVALID_RETURN;
                report_cgi_req_info.band_class = RRM_INVALID_RETURN;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);
                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        for(index = RRM_ZERO; index < p_meas_config_req->inter_rat_meas_config.
                                utran_config_list.utran_fdd_list[req_list_index].
                                cells_for_which_to_report_cgi_size; index++)
                        {
                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_UTRAN_CELL,
                                        p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_fdd_list[req_list_index].uarfcn, 
                                        RRM_INVALID_RETURN, RRM_INVALID_RETURN,
                                        p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_fdd_list[req_list_index].
                                        cells_for_which_to_report_cgi[index]))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }
                        }
                    }	
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    } 
                }
            }
            else if (RRM_ZERO < p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_tdd_list_size)
            {
                report_cgi_req_info.rat_type = RRM_UTRAN_TDD_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_tdd_list[req_list_index].uarfcn;
                report_cgi_req_info.band_ind = RRM_INVALID_RETURN;
                report_cgi_req_info.band_class = RRM_INVALID_RETURN;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);
                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        for(index = RRM_ZERO;index < p_meas_config_req->inter_rat_meas_config.
                                utran_config_list.utran_tdd_list[req_list_index].
                                cells_for_which_to_report_cgi_size; index++)
                        {
                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_UTRAN_TDD_CELL,
                                        p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_tdd_list[req_list_index].uarfcn,
                                        RRM_INVALID_RETURN, RRM_INVALID_RETURN,
                                        p_meas_config_req->inter_rat_meas_config.utran_config_list.utran_tdd_list[req_list_index].
                                        cells_for_which_to_report_cgi[index]))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }

                        }
                    }	
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    } 
                }
            }
            else if (RRM_ZERO < p_meas_config_req->inter_rat_meas_config.geran_config_list.geran_freq_info_list_size)
            {
                report_cgi_req_info.rat_type = RRM_GERAN_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->inter_rat_meas_config.geran_config_list.
                    geran_freq_info_list[req_list_index].geran_car_freqs.starting_arfcn;
                report_cgi_req_info.band_ind = p_meas_config_req->inter_rat_meas_config.geran_config_list.
                    geran_freq_info_list[req_list_index].geran_car_freqs.band_ind;
                report_cgi_req_info.band_class = RRM_INVALID_RETURN;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);
                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        for(index= RRM_ZERO; index < p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                geran_freq_info_list[req_list_index].
                                cells_for_which_to_report_cgi_size; index++)
                        {
                            RRM_MEMCPY(&geran_cgi, (U16 *) &p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                    geran_freq_info_list[req_list_index].cells_for_which_to_report_cgi[index],
                                    sizeof(rrm_son_geran_physical_cell_id_t));

                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_GERAN_CELL,
                                        p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                        geran_freq_info_list[req_list_index].geran_car_freqs.starting_arfcn, 
                                        p_meas_config_req->inter_rat_meas_config.geran_config_list.
                                        geran_freq_info_list[req_list_index].geran_car_freqs.band_ind, RRM_INVALID_RETURN, geran_cgi))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }
                        }
                    }	
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    } 
                }
            }
            else if (RRM_ZERO < p_meas_config_req->inter_rat_meas_config.cdma_config_list.cdma_freq_info_list_size)
            {
                report_cgi_req_info.rat_type = RRM_CDMA_CELL;
                report_cgi_req_info.arfcn = p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                    cdma_freq_info_list[req_list_index].arfcn;
                report_cgi_req_info.band_ind = RRM_INVALID_RETURN;
                report_cgi_req_info.band_class = p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                    cdma_freq_info_list[req_list_index].band_class;

                p_meas_config_info = rrm_find_obj_in_ue_meas_config(report_cgi_req_info.rat_type,
                        report_cgi_req_info.arfcn, report_cgi_req_info.band_ind, report_cgi_req_info.band_class,
                        p_ue_context->p_meas_config);
                if(RRM_PNULL == p_meas_config_info)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Meas Object not found in UE context for arfcn = %d", report_cgi_req_info.arfcn);
                    error_code = RRM_ERR_MEAS_OBJ_NOT_FOUND;
                }
                else
                {
                    if(RRM_ZERO != p_meas_config_info->meas_id)
                    {
                        /* Enqueue the rest of the PCIs in the procedure queue to request CGI later */
                        for(index = RRM_ZERO; index < p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                cdma_freq_info_list[req_list_index].
                                cells_for_which_to_report_cgi_size; index++)
                        {
                            if(RRM_SUCCESS == rrm_ue_enqueue_meas_config_cgi_node(p_ue_context, RRM_CDMA_CELL,
                                        p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                        cdma_freq_info_list[req_list_index].arfcn, RRM_INVALID_RETURN, 
                                        p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                        cdma_freq_info_list[req_list_index].band_class, 
                                        p_meas_config_req->inter_rat_meas_config.cdma_config_list.
                                        cdma_freq_info_list[req_list_index].cells_for_which_to_report_cgi[index]))
                            {
                                p_meas_config_info->cgi_req_cnt++;
                            }
                        }
                    }	
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name, RRM_ERROR,
                                "Meas id [%d] is received which is not valid", p_meas_config_info->meas_id);
                        error_code = RRM_ERR_UE_NOT_CONFIGURED;
                    }
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "NO PCI received in Meas Config request for reportCGI request");
                error_code = RRM_ERR_INVALID_PARAMS;
            }

            /*SPR_18491_END*/
        }

        if(RRM_NO_ERROR != error_code)
        {
            /* SPR 16406 8SEP start */
            p_ue_context->cgi_req_trans_id = p_cell_context->ongoing_trans_id;
            /* SPR 16406 8SEP end */

            rrm_uem_send_meas_config_resp(p_ue_context, RRM_FAILURE, error_code);
        }
    }
    /* SPR 20652 Fix End */
    /* CSR00069389 End */
    /* SPR 16406 8SEP start */
    /* Code removed */
    /* SPR 16406 8SEP end */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}



/******************************************************************************
 *   FUNCTION NAME: rrm_uem_reset_meas_config_struct
 *   DESCRIPTION:
 *          This function resets the status parameters for meas config request 
 *   RETURNS:
 *             rrm_void_et
 ******************************************************************************/
    rrm_void_t
rrm_uem_reset_meas_config_struct(
        rrm_ue_meas_config_t *p_meas_config
        )
{
    RRM_UT_TRACE_ENTER();

    /* CSR00069389 Start */
    /* SPR 16053 start */
    /* SPR 21251 +- */
    /*RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Reset status for MeasID:- %d", p_meas_config->meas_id);*/
    /* CSR00069389 End */
    /* SPR 16053 end */
    /* CSR00069389 End */            
    /* Start: Enh 317 */
    p_meas_config->meas_id = RRM_NULL;

    p_meas_config->meas_obj_id = RRM_NULL;

    p_meas_config->report_id = RRM_NULL;

    p_meas_config->rat_type = RRM_CELL_UNDEFINED;

    p_meas_config->carr_freq = RRM_NULL;

    p_meas_config->meas_config_status = RRM_MEAS_CONFIG_NULL;

    p_meas_config->cgi_req_cnt = RRM_NULL;

    p_meas_config->cgi_success_cnt = RRM_NULL;

    p_meas_config->cgi_resp_status = RRM_FAILURE;

    p_meas_config->obj_created_at_ue = RRM_FALSE;

    /*SPR 15314 Changes Start*/
    p_meas_config->report_counter = RRM_NULL;
    /*SPR 15314 Changes End*/
    /* CSR00069389 Start */
    /* CSR00069389 End */
    /* SPR 21251 +- */
    //rrm_ue_print_meas_config_struct(*p_meas_config);

    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_init_meas_config_struct
 *   DESCRIPTION:
 *          This function initialises the status parameters for meas config request 
 *   RETURNS:
 *             rrm_void_et
 ******************************************************************************/
    rrm_void_t
rrm_uem_init_meas_config_struct(
        rrm_ue_context_t *p_ue_context 
        )
{
    U8	meas_id			= RRM_NULL;
    RRM_UT_TRACE_ENTER();
    p_ue_context->p_meas_config = (rrm_ue_meas_config_t*)rrm_mem_get(RRM_ANR_MAX_MEAS_OBJ * sizeof(rrm_ue_meas_config_t));
    for(meas_id = 0; meas_id < RRM_ANR_MAX_MEAS_OBJ; meas_id++)
    {
        /* Initialize the status for Meas Config */
        rrm_uem_reset_meas_config_struct(&p_ue_context->p_meas_config[meas_id]);
    }
    p_ue_context->config_id = RRM_ZERO;
    p_ue_context->meas_config_sent_bitmask = RRM_ZERO;

    RRM_UT_TRACE_EXIT();

}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_check_and_reset_meas_config_struct
 *   DESCRIPTION:
 *          This function checks which meas config index need to be reset and 
 *          calls the handler to reset the status parameters for meas config request 
 *          if required. Only thosa index are reset which contain info of those 
 *          meas objects which have been successfully created at UE in earlier
 *          Meas Config Requests
 *   RETURNS:
 *             rrm_void_et
 ******************************************************************************/
    rrm_void_t
rrm_uem_check_and_reset_meas_config_struct(
        rrm_ue_context_t *p_ue_context
        )
{
    U8	meas_id			= RRM_NULL;
    RRM_UT_TRACE_ENTER();

    for(meas_id = 0; meas_id < RRM_ANR_MAX_MEAS_OBJ; meas_id++)
    {
        /* Reset the status for those for which objects are not created at UE earlier */
        if(RRM_FALSE == p_ue_context->p_meas_config[meas_id].obj_created_at_ue)
        {
            if(RRM_EUTRAN_CELL == p_ue_context->p_meas_config[meas_id].rat_type)
            {
                p_ue_context->meas_config_sent_bitmask ^= QUANTITY_CONFIG_EUTRA_SENT;
                p_ue_context->meas_config_sent_bitmask ^= REPORT_CONFIG_EUTRA_SENT;
            }
            else if((RRM_UTRAN_CELL == p_ue_context->p_meas_config[meas_id].rat_type) || 
                    (RRM_UTRAN_TDD_CELL == p_ue_context->p_meas_config[meas_id].rat_type))
            {
                p_ue_context->meas_config_sent_bitmask ^= QUANTITY_CONFIG_UTRA_SENT;
                p_ue_context->meas_config_sent_bitmask ^= REPORT_CONFIG_INTERRAT_SENT;
            }
            else if(RRM_GERAN_CELL == p_ue_context->p_meas_config[meas_id].rat_type)
            {
                p_ue_context->meas_config_sent_bitmask ^= QUANTITY_CONFIG_GERAN_SENT;
                p_ue_context->meas_config_sent_bitmask ^= REPORT_CONFIG_INTERRAT_SENT;
            }
            else if(RRM_CDMA_CELL == p_ue_context->p_meas_config[meas_id].rat_type)
            {
                p_ue_context->meas_config_sent_bitmask ^= QUANTITY_CONFIG_CDMA2000_SENT;
                p_ue_context->meas_config_sent_bitmask ^= REPORT_CONFIG_INTERRAT_SENT;
            }
            rrm_uem_reset_meas_config_struct(&p_ue_context->p_meas_config[meas_id]);
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* End: Enh 317 */


static rrm_bool_et
rrm_is_ue_attached(
        rrm_ue_context_t *p_ue_context
        )
{
    rrm_bool_et     ret_val     = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if(RRM_ZERO < p_ue_context->drb_configured.num_of_list)
    {
        ret_val = RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "UE is attached");
    }
    else
    {
        ret_val = RRM_FALSE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "UE is NOT attached");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* Fix for CSR: 00059124 */
/* SPR-13322-fix start */
/******************************************************************************
 *   FUNCTION NAME: rrm_is_ue_supporting_autonomous_gap 
 *   DESCRIPTION:   Function checks if the ue supports autonomous gap or not. 
 *   RETURNS:       RRM_TRUE, if UE supports autonomous gap
 *                  otherwise, returns RRM_FALSE.
 ******************************************************************************/
rrm_bool_et
    rrm_is_ue_supporting_autonomous_gap
(
 rrm_ue_context_t *p_ue_context
 )
{
    rrm_bool_et ue_supports_autonomous_gap = RRM_FALSE;
    /* Coverity 73597 Fix Start */
    /* Code Deleted */
    /* Coverity 73597 Fix End */

    RRM_UT_TRACE_ENTER();

    if (RRM_PNULL != p_ue_context)
    { 
        if ((RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT & p_ue_context->ue_capability_params.bitmask) &&
                (RRM_REL9 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                 eutra_radio_capability_info_def.access_stratum_release))
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
                    "[UE:%d] supports autonomous gap",
                    p_ue_context->ue_index);
            ue_supports_autonomous_gap = RRM_TRUE;
        }

        if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
                (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask &
                 RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)) 
        {
            if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.bitmask &
                        RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT) &&
                    (RRC_UE_EUTRA_CAPABILITY_V9a0_IES_PRESENT & p_ue_context->ue_capability_params.
                     rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.bitmask))
            {
                if(RRM_UE_EUTRA_CAPABILITY_ADDFDD_MODE_R9_PRESENT & p_ue_context->ue_capability_params.
                        rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v9a0_ies.bitmask)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "FDD Add SI Acq Params Present");
                }
                if(RRM_UE_EUTRA_CAPABILITY_ADDTDD_MODE_R9_PRESENT & p_ue_context->ue_capability_params.
                        rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v9a0_ies.bitmask)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "TDD Add SI Acq Params Present");
                }
            }
        }
        /* Coverity 73597 Fix Start */
        /* Code Deleted */
        /* Coverity 73597 Fix End */


    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "UE context is found NULL");
    }

    RRM_UT_TRACE_EXIT();
    return ue_supports_autonomous_gap;
}
/* SPR-13322-fix end */
/* SPR_15259_fix: start */
/******************************************************************************
 *   FUNCTION NAME: rrm_is_ue_supporting_autonomous_gap_for_ho 
 *   DESCRIPTION:   Function checks if the ue supports autonomous gap or not. 
 *   RETURNS:       RRM_TRUE, if UE supports autonomous gap
 *                  otherwise, returns RRM_FALSE.
 ******************************************************************************/
rrm_bool_et
    rrm_is_ue_supporting_autonomous_gap_for_ho
(
 rrm_ue_context_t *p_ue_context,
 rrm_ue_rat_et    rrm_cell_rat_type
 )
{
    U32                          carrier_earfcn = RRM_NULL;
    /* SPR 15854 Fix Start */
    /* Code Deleted */
    /* SPR 15854 Fix End */
    rrm_si_acqusition_et         si_acquisition_type = RRM_ACQUSITION_NONE;
    rrm_cell_context_t           *p_cell_context     = RRM_PNULL;
    U8                           freq_band           = RRM_ZERO;
    rrm_bool_et                  configure_auto_gap  = RRM_FALSE;
    rrm_neigh_cell_si_acquisition_parameters_r9_t
        *p_fdd_add_si_acquisition_params_r9 = RRM_PNULL;
    rrm_neigh_cell_si_acquisition_parameters_r9_t
        *p_tdd_add_si_acquisition_params_r9 = RRM_PNULL;
    U8                           intra_freq_fdd_tdd_bitmask = RRM_ZERO;
    U8                           inter_freq_fdd_tdd_bitmask = RRM_ZERO;
    rrm_bool_et                  rrm_is_ue_capa_v920_nsi_intra_present = RRM_FALSE;
    rrm_bool_et                  rrm_is_ue_capa_v920_nsi_inter_present = RRM_FALSE;
    rrm_bool_et                  rrm_is_ue_capa_v920_nsi_utran_present = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if (RRM_PNULL != p_ue_context)
    {
        if ((RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT & p_ue_context->ue_capability_params.bitmask) &&
                (RRM_REL9 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                 eutra_radio_capability_info_def.access_stratum_release))
        {
            carrier_earfcn = p_ue_context->carrier_earfcn;
            /* SPR 15854 Fix Start */
            /* Code Deleted */
            /* SPR 15854 Fix End */
            /* SPR 16406 8SEP start */
            /* Code removed */
            /* SPR 16406 8SEP end */
            switch(rrm_cell_rat_type)
            {
                case UTRAN_FDD_RAT:
                case UTRAN_TDD_RAT:
                    {
                        if( RRM_INVALID_RETURN != (freq_band = rrm_ue_get_utra_freq_band (carrier_earfcn)))
                        {
                            si_acquisition_type = RRM_ACQUSITION_UTRA_FDD;
                        }
                        else if(RRM_INVALID_RETURN != (freq_band = rrm_ue_get_utra_tdd128_freq_band(carrier_earfcn)) ||
                                RRM_INVALID_RETURN != (freq_band = rrm_ue_get_utra_tdd384_freq_band(carrier_earfcn)) ||
                                RRM_INVALID_RETURN != (freq_band = rrm_ue_get_utra_tdd768_freq_band(carrier_earfcn)))
                        {
                            si_acquisition_type = RRM_ACQUSITION_UTRA_TDD;
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "UTRA Carrier Freq does not lie in the supported bands for [UE:%d]",
                                    p_ue_context->ue_index);
                        }

                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "SI ACQUSITION for Utran should be checked for [UE:%d] & Type [%d]",
                                p_ue_context->ue_index,
                                si_acquisition_type);
                    }
                    break;
                case GERAN_RAT:
                    /* GERAN SI Acqusition param not yet supported in UE Capability [as per 36.331] */
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "GERAN RAT type received for [UE:%d] for which SI Acqusition not supported",
                            p_ue_context->ue_index);
                    break;
                    /* SPR 15854 Fix Start */
                case EUTRAN_RAT:
                    {    
                        p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);

                        freq_band = rrm_ue_is_ue_supported_eutra_frequency(carrier_earfcn,
                                p_ue_context);

                        if(RRM_PNULL != p_cell_context)
                        {
                            /* Coverity 108806 Fix Start */
                            if(carrier_earfcn == p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
                            {
                                if(RRM_ZERO != freq_band)
                                {
                                    rrm_uem_is_eutra_freq_fdd_or_tdd(&intra_freq_fdd_tdd_bitmask, freq_band,
                                            carrier_earfcn);
                                }

                                si_acquisition_type = RRM_ACQUSITION_INTRA_FREQ;
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "SI ACQUSITION for Intra Freq. should be checked for [UE:%d]!", p_ue_context->ue_index);
                            }
                            else
                            {
                                if(RRM_ZERO != freq_band)
                                {
                                    rrm_uem_is_eutra_freq_fdd_or_tdd(&inter_freq_fdd_tdd_bitmask, freq_band,
                                            carrier_earfcn);
                                }

                                si_acquisition_type = RRM_ACQUSITION_INTER_FREQ;
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "SI ACQUSITION for Inter Freq. should be checked for [UE:%d]!", p_ue_context->ue_index);
                            }
                            /* Coverity 108806 Fix End */
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                    "Cell Context is NULL for [UE:%d]!", p_ue_context->ue_index);
                        }
                    }
                    break;
                    /* SPR 15854 Fix End */
                default:
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                            "Invalid RAT type received for [UE:%d]",
                            p_ue_context->ue_index);
            }
            /* SPR 15854 Fix Start */
            /* Code Deleted */
            /* SPR 15854 Fix End */
            /* SPR 16406 8SEP start */
            /* Code removed */
            /* SPR 16406 8SEP end */

            if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
                    (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask &
                     RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)) 
            {
                /* Coverity 81725 Fix End */
                rrm_is_ue_capa_v920_nsi_intra_present = (rrm_bool_et)p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.neigh_cell_si_acquisition_parameters_r9.
                    intra_freq_si_acquisition_for_ho_supported_r9;
                /*Coverity 81732 Fix Start*/                                             
                rrm_is_ue_capa_v920_nsi_inter_present = (rrm_bool_et)p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.neigh_cell_si_acquisition_parameters_r9.
                    inter_freq_si_acquisition_for_ho_supported_r9;
                /*Coverity 81732 Fix End*/                                             
                /*Coverity 81736 Fix Start*/                                             
                rrm_is_ue_capa_v920_nsi_utran_present = (rrm_bool_et)p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.neigh_cell_si_acquisition_parameters_r9.
                    utran_si_acquisition_for_ho_supported_r9;
                /*Coverity 81736 Fix End*/                                             
                /* Coverity 81725 Fix End */

                if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.bitmask &
                            RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT) &&
                        (RRC_UE_EUTRA_CAPABILITY_V9a0_IES_PRESENT & p_ue_context->ue_capability_params.
                         rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask))
                {
                    if(RRM_UE_EUTRA_CAPABILITY_ADDFDD_MODE_R9_PRESENT & p_ue_context->ue_capability_params.
                            rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v9a0_ies.bitmask)
                    {
                        p_fdd_add_si_acquisition_params_r9 = &(p_ue_context->ue_capability_params.
                                rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v9a0_ies.fdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9);
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "FDD Add SI Acq Params Present");
                    }
                    if(RRM_UE_EUTRA_CAPABILITY_ADDTDD_MODE_R9_PRESENT & p_ue_context->ue_capability_params.
                            rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                            ue_eutra_capability_v9a0_ies.bitmask)
                    {
                        p_tdd_add_si_acquisition_params_r9 = &(p_ue_context->ue_capability_params.
                                rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v9a0_ies.tdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9);
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "TDD Add SI Acq Params Present");
                    }
                }
            }

            if(RRM_ACQUSITION_INTRA_FREQ == si_acquisition_type) 
            {
                if(RRM_EUTRA_FDD_PRESENT & intra_freq_fdd_tdd_bitmask)
                {
                    if(RRM_PNULL != p_fdd_add_si_acquisition_params_r9)
                    {
                        if(RRM_TRUE == p_fdd_add_si_acquisition_params_r9->intra_freq_si_acquisition_for_ho_supported_r9)
                        {
                            /* SPR 15854 Fix Start */
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "UE support FDD Add SI Acq for INTRA-FREQ");
                            /* SPR 15854 Fix  End */
                            configure_auto_gap = RRM_TRUE;
                        }
                    }
                    else if(RRM_TRUE == rrm_is_ue_capa_v920_nsi_intra_present) 
                    {
                        /* SPR 15854 Fix Start */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "UE support FDD SI Acq for INTRA-FREQ");
                        /* SPR 15854 Fix End */
                        configure_auto_gap = RRM_TRUE;
                    }
                }
                else if(RRM_EUTRA_TDD_PRESENT & intra_freq_fdd_tdd_bitmask)
                {
                    if(RRM_PNULL != p_tdd_add_si_acquisition_params_r9)
                    {
                        if(RRM_TRUE == p_tdd_add_si_acquisition_params_r9->intra_freq_si_acquisition_for_ho_supported_r9)
                        {
                            /* SPR 15854 Fix Start */
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "UE support TDD Add SI Acq for INTRA-FREQ");
                            /* SPR 15854 Fix End */
                            configure_auto_gap = RRM_TRUE;
                        }
                    }
                    else if(RRM_TRUE == rrm_is_ue_capa_v920_nsi_intra_present)
                    {
                        /* SPR 15854 Fix Start */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "UE support TDD SI Acq for INTRA-FREQ");
                        /* SPR 15854 Fix End */
                        configure_auto_gap = RRM_TRUE;
                    }
                }
            }
            else if(RRM_ACQUSITION_INTER_FREQ == si_acquisition_type)
            {
                if(RRM_EUTRA_FDD_PRESENT & inter_freq_fdd_tdd_bitmask)
                {
                    if(RRM_PNULL != p_fdd_add_si_acquisition_params_r9)
                    {
                        if(RRM_TRUE == p_fdd_add_si_acquisition_params_r9->
                                inter_freq_si_acquisition_for_ho_supported_r9)
                        {
                            /* SPR 15854 Fix Start */
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "UE support FDD Add SI Acq for INTER-FREQ");
                            /* SPR 15854 Fix End */
                            configure_auto_gap = RRM_TRUE;
                        }
                    }
                    else if(RRM_TRUE == rrm_is_ue_capa_v920_nsi_inter_present)
                    {
                        /* SPR 15854 Fix Start */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "UE support FDD SI Acq for INTER-FREQ");
                        /* SPR 15854 Fix End */
                        configure_auto_gap = RRM_TRUE;
                    }
                }
                if(RRM_EUTRA_TDD_PRESENT & inter_freq_fdd_tdd_bitmask)
                {
                    if(RRM_PNULL != p_tdd_add_si_acquisition_params_r9)
                    {
                        if(RRM_TRUE == p_tdd_add_si_acquisition_params_r9->
                                inter_freq_si_acquisition_for_ho_supported_r9)
                        {
                            /* SPR 15854 Fix Start */
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "UE support TDD Add SI Acq for INTER-FREQ");
                            /* SPR 15854 Fix End */
                            configure_auto_gap = RRM_TRUE;
                        }
                    }
                    else if(RRM_TRUE == rrm_is_ue_capa_v920_nsi_inter_present)
                    {
                        /* SPR 15854 Fix Start */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "UE support TDD SI Acq for INTER-FREQ");
                        /* SPR 15854 Fix End */
                        configure_auto_gap = RRM_TRUE;
                    }
                }
            }
            else if(RRM_ACQUSITION_UTRA_FDD == si_acquisition_type)
            {
                if(RRM_PNULL != p_fdd_add_si_acquisition_params_r9)
                {
                    if(RRM_TRUE == p_fdd_add_si_acquisition_params_r9->
                            utran_si_acquisition_for_ho_supported_r9)
                    {
                        /* SPR 15854 Fix Start */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "UE support FDD Add SI Acq for UTRA");
                        /* SPR 15854 Fix End */
                        configure_auto_gap = RRM_TRUE;
                    }
                }
                else if(RRM_TRUE == rrm_is_ue_capa_v920_nsi_utran_present)
                {
                    /* SPR 15854 Fix Start */ 
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "UE support FDD SI Acq for UTRA");
                    /* SPR 15854 Fix End */
                    configure_auto_gap = RRM_TRUE;
                }
            }
            else if(RRM_ACQUSITION_UTRA_TDD == si_acquisition_type)
            {
                if(RRM_PNULL != p_tdd_add_si_acquisition_params_r9)
                {
                    if(RRM_TRUE == p_tdd_add_si_acquisition_params_r9->
                            utran_si_acquisition_for_ho_supported_r9)
                    {
                        /* SPR 15854 Fix Start */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "UE support TDD Add SI Acq for UTRA");
                        /* SPR 15854 Fix End */
                        configure_auto_gap = RRM_TRUE;
                    }
                }
                else if(RRM_TRUE == rrm_is_ue_capa_v920_nsi_utran_present)
                {
                    /* SPR 15854 Fix Start */
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "UE Does NOT support TDD SI Acq for UTRA");
                    /* SPR 15854 Fix End */
                    configure_auto_gap = RRM_TRUE;
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "RRM_ACQUSITION_NONE");
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "UE context is found NULL");
    }

    RRM_UT_TRACE_EXIT();
    return configure_auto_gap;
}
/* SPR_15259_fix: end */
/* Fix for CSR: 00059124 */
/******************************************************************************
 *   FUNCTION NAME: is_ue_supported_fgi_for_cdrx 
 *   DESCRIPTION:   Function checks if the ue supports fgi bit five for cdrx or not.
 *   RETURNS:       RRM_TRUE, if UE supports cdrx
 *                  otherwise, returns RRM_FALSE.
 ******************************************************************************/
rrm_bool_et
    is_ue_supported_fgi_for_cdrx
(
 rrm_ue_context_t *p_ue_context
 )
{
    rrm_bool_et                        ue_supports_fgi_bit_five = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
    if (RRM_PNULL != p_ue_context)
    {
        if(RRM_TRUE ==  rrm_is_set_fgi_bit(p_ue_context, RRM_FIVE)) 
        {
            ue_supports_fgi_bit_five = RRM_TRUE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "FGI bit five is not set for [UE:%d]",p_ue_context->ue_index );

        } 
    }

    RRM_UT_TRACE_EXIT();
    return ue_supports_fgi_bit_five;
}
/* Fix for CSR: 00059124 */

/******************************************************************************
 *   FUNCTION NAME: rrm_checks_ue_supported_rats
 *   DESCRIPTION:   This function check that UE support which rat and set bit 
 *                  regarding supported rat
 *   RETURNS:       None
 ******************************************************************************/
void rrm_checks_ue_supported_rats (rrm_ue_context_t *p_ue_context)
{
    U32                                mask_for_bit22 = RRM_ONE;
    U32                                mask_for_bit23 = RRM_ONE;
    U32                                mask_for_bit24 = RRM_ONE;
    U32                                mask_for_bit25 = RRM_ONE;
    U32                                mask_for_bit26 = RRM_ONE;
    RRM_UT_TRACE_ENTER();
    mask_for_bit22 = mask_for_bit22<<(RRM_THIRTY_TWO-RRM_TWENTY_TWO);
    mask_for_bit23 = mask_for_bit23<<(RRM_THIRTY_TWO-RRM_TWENTY_THREE);
    mask_for_bit24 = mask_for_bit24<<(RRM_THIRTY_TWO-RRM_TWENTY_FOUR);
    mask_for_bit25 = mask_for_bit25<<(RRM_THIRTY_TWO-RRM_TWENTY_FIVE);
    mask_for_bit26 = mask_for_bit26<<(RRM_THIRTY_TWO-RRM_TWENTY_SIX);
    p_ue_context->supported_rats = RRM_ZERO;


    if(FGI_BIT_5 & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            eutra_radio_capability_info_def.feature_group_indicators)
    {
        if(FGI_BIT_17 & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.feature_group_indicators) 
        {
            p_ue_context->supported_rats |= UE_SUPPORT_INTRAFREQ_RAT;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "UE supports measurements for EUTRAN Intra-freq");
        }

        if((FGI_BIT_18 & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                    eutra_radio_capability_info_def.feature_group_indicators) &&
                (mask_for_bit25 & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                 eutra_radio_capability_info_def.feature_group_indicators))    
        {
            p_ue_context->supported_rats |= UE_SUPPORT_INTERFREQ_RAT;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "UE supports measurements for EUTRAN Inter-freq");
        }

        if(FGI_BIT_19 & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                eutra_radio_capability_info_def.feature_group_indicators)
        {
            if(mask_for_bit22 & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                    eutra_radio_capability_info_def.feature_group_indicators)
            {
                p_ue_context->supported_rats |= UE_SUPPORT_UTRAN_RAT;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE supports measurements for UTRAN");
            }

            if(mask_for_bit23 & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                    eutra_radio_capability_info_def.feature_group_indicators)     
            {
                p_ue_context->supported_rats |= UE_SUPPORT_GERAN_RAT;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE supports measurements for GERAN");
            }


            if(mask_for_bit26 & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                    eutra_radio_capability_info_def.feature_group_indicators)
            {
                p_ue_context->supported_rats |= UE_SUPPORT_HRPD_RAT;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE supports measurements for CDMA HRPD");
            }


            if(mask_for_bit24 & p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                    eutra_radio_capability_info_def.feature_group_indicators)

            {
                p_ue_context->supported_rats |= UE_SUPPORT_1XRTT;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE supports measurements for CDMA 1XRTT");
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Bit 19 is not set");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "FGI bit 5 is NOT set");
    }

    RRM_UT_TRACE_EXIT();
}

/* SPR 12897 Start */
    rrm_void_t
rrm_uem_is_eutra_freq_fdd_or_tdd(
        U8                              *p_eutran_fdd_tdd_bitmask,
        U8                              freq_band,
        U32                             earfcn
        )
{
    if(RRM_TDD_BAND_START > freq_band)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "EARFCN = %d is a FDD freq", earfcn);

        *p_eutran_fdd_tdd_bitmask |= RRM_EUTRA_FDD_PRESENT;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "EARFCN = %d is a TDD freq", earfcn);

        *p_eutran_fdd_tdd_bitmask |= RRM_EUTRA_TDD_PRESENT;
    }
}


    rrm_bool_et
rrm_uem_check_configure_auto_gap_or_cdrx_for_eutra(
        rrm_cell_context_t      *p_cell_context,
        rrm_ue_context_t        *p_ue_context
        )
{
    rrm_bool_et configure_auto_gap = RRM_TRUE;
    meas_eutran_context_list_t       *p_meas_eutran_list = RRM_PNULL;    
    meas_eutran_node_t               *p_meas_eutran_node = PNULL;
    YLNODE                          *p_node             = RRM_PNULL;
    U8                              index               = RRM_NULL;
    U8                              freq_band           = RRM_ZERO;
    U8                              intra_freq_fdd_tdd_bitmask = RRM_ZERO;
    U8                              inter_freq_fdd_tdd_bitmask = RRM_ZERO;
    rrm_neigh_cell_si_acquisition_parameters_r9_t 
        *p_fdd_add_si_acquisition_params_r9 = RRM_PNULL;
    rrm_neigh_cell_si_acquisition_parameters_r9_t                                    
        *p_tdd_add_si_acquisition_params_r9 = RRM_PNULL;
    rrm_bool_et rrm_is_ue_capa_v920_nsi_intra_present = RRM_FALSE;
    rrm_bool_et rrm_is_ue_capa_v920_nsi_inter_present = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    p_meas_eutran_list = &(p_cell_context->meas_eutran_list);

    p_node = rrm_get_first_list_node(p_meas_eutran_list);

    p_meas_eutran_node =  YMEMBEROF(meas_eutran_node_t, sNode, p_node);
    /*CID 66793:start*/
    if (RRM_PNULL == p_meas_eutran_node)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_meas_eutran_node is NULL");
        RRM_UT_TRACE_EXIT();
        return  RRM_FALSE;
    }
    /*CID 66793:end*/
    freq_band = rrm_ue_is_ue_supported_eutra_frequency(p_meas_eutran_node->eutran_config.earfcn,
            p_ue_context);

    if(RRM_ZERO != freq_band) 
    {
        rrm_uem_is_eutra_freq_fdd_or_tdd(&intra_freq_fdd_tdd_bitmask, freq_band, 
                p_meas_eutran_node->eutran_config.earfcn);
    }
    p_node = rrm_get_next_list_node(p_node);

    for(index = RRM_ZERO; RRM_PNULL != p_node; index++)
    {
        p_meas_eutran_node =  YMEMBEROF(meas_eutran_node_t, sNode, p_node);
        freq_band = rrm_ue_is_ue_supported_eutra_frequency(p_meas_eutran_node->eutran_config.earfcn,
                p_ue_context);

        if(RRM_ZERO != freq_band) 
        {
            rrm_uem_is_eutra_freq_fdd_or_tdd(&inter_freq_fdd_tdd_bitmask, freq_band, 
                    p_meas_eutran_node->eutran_config.earfcn);

            if((RRM_EUTRA_FDD_PRESENT & inter_freq_fdd_tdd_bitmask) &&
                    (RRM_EUTRA_TDD_PRESENT & inter_freq_fdd_tdd_bitmask))
            {
                break;
            }
        }
        p_node = rrm_get_next_list_node(p_node);
    }

    if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
            (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask &
             RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)) 
    {
        /* SPR_15259_fix: start */
        /* Coverity 81726  Fix Start */
        rrm_is_ue_capa_v920_nsi_intra_present = (rrm_bool_et)p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            ue_eutra_capability_v920_ies.neigh_cell_si_acquisition_parameters_r9.
            intra_freq_si_acquisition_for_ho_supported_r9;
        /* Coverity 81726 Fix End */
        /*Coverity 81735 Fix Start*/                                             
        rrm_is_ue_capa_v920_nsi_inter_present = (rrm_bool_et)p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
            ue_eutra_capability_v920_ies.neigh_cell_si_acquisition_parameters_r9.
            inter_freq_si_acquisition_for_ho_supported_r9;
        /*Coverity 81735 Fix End*/                                             

        if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.bitmask &
                    RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT) &&
                (RRC_UE_EUTRA_CAPABILITY_V9a0_IES_PRESENT & p_ue_context->ue_capability_params.
                 rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask))
            /* SPR_15259_fix: end */
        {  
            if(RRM_UE_EUTRA_CAPABILITY_ADDFDD_MODE_R9_PRESENT & p_ue_context->ue_capability_params.
                    rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v9a0_ies.bitmask)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "FDD Add SI Acq Params Present");
                p_fdd_add_si_acquisition_params_r9 = &(p_ue_context->ue_capability_params.
                        rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v9a0_ies.fdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9);
            }
            if(RRM_UE_EUTRA_CAPABILITY_ADDTDD_MODE_R9_PRESENT & p_ue_context->ue_capability_params.
                    rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v9a0_ies.bitmask)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "TDD Add SI Acq Params Present");
                p_tdd_add_si_acquisition_params_r9 = &(p_ue_context->ue_capability_params.
                        rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v9a0_ies.tdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9);
            }
        }
    }

    if(RRM_EUTRA_FDD_PRESENT & intra_freq_fdd_tdd_bitmask)
    {
        if(RRM_PNULL != p_fdd_add_si_acquisition_params_r9)
        {
            if(RRM_FALSE == p_fdd_add_si_acquisition_params_r9->intra_freq_si_acquisition_for_ho_supported_r9)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE Does NOT support FDD Add SI Acq for INTRA-FREQ");
                configure_auto_gap = RRM_FALSE;
            }
        }
        /* SPR_15259_fix: start */
        else if(RRM_FALSE == rrm_is_ue_capa_v920_nsi_intra_present)
            /* SPR_15259_fix: end */
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "UE Does NOT support FDD SI Acq for INTRA-FREQ");
            configure_auto_gap = RRM_FALSE; 
        }
    }
    else if(RRM_EUTRA_TDD_PRESENT & intra_freq_fdd_tdd_bitmask)
    {
        if(RRM_PNULL != p_tdd_add_si_acquisition_params_r9)
        {
            if(RRM_FALSE == p_tdd_add_si_acquisition_params_r9->intra_freq_si_acquisition_for_ho_supported_r9)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE Does NOT support TDD Add SI Acq for INTRA-FREQ");
                configure_auto_gap = RRM_FALSE;
            }
        }
        /* SPR_15259_fix: start */
        else if(RRM_FALSE == rrm_is_ue_capa_v920_nsi_intra_present)
            /* SPR_15259_fix: end */
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "UE Does NOT support TDD SI Acq for INTRA-FREQ");
            configure_auto_gap = RRM_FALSE; 
        }
    }


    if((RRM_TRUE == configure_auto_gap) && (RRM_EUTRA_FDD_PRESENT & inter_freq_fdd_tdd_bitmask))
    {
        if(RRM_PNULL != p_fdd_add_si_acquisition_params_r9)
        {
            if(RRM_FALSE == p_fdd_add_si_acquisition_params_r9->
                    inter_freq_si_acquisition_for_ho_supported_r9)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE Does NOT support FDD Add SI Acq for INTER-FREQ");
                configure_auto_gap = RRM_FALSE;
            }
        }
        /* SPR_15259_fix: start */
        else if(RRM_FALSE == rrm_is_ue_capa_v920_nsi_inter_present)
            /* SPR_15259_fix: end */
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "UE Does NOT support FDD SI Acq for INTER-FREQ");
            configure_auto_gap = RRM_FALSE;
        }
    }
    if((RRM_TRUE == configure_auto_gap) && (RRM_EUTRA_TDD_PRESENT & inter_freq_fdd_tdd_bitmask))
    {
        if(RRM_PNULL != p_tdd_add_si_acquisition_params_r9)
        {
            if(RRM_FALSE == p_tdd_add_si_acquisition_params_r9->
                    inter_freq_si_acquisition_for_ho_supported_r9)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE Does NOT support TDD Add SI Acq for INTER-FREQ");
                configure_auto_gap = RRM_FALSE;
            }
        }
        /* SPR_15259_fix: start */
        else if(RRM_FALSE == rrm_is_ue_capa_v920_nsi_inter_present)
            /* SPR_15259_fix: end */
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "UE Does NOT support TDD SI Acq for INTER-FREQ");
            configure_auto_gap = RRM_FALSE;
        }

    }
    RRM_UT_TRACE_EXIT();
    return configure_auto_gap;
}


rrm_bool_et
rrm_uem_check_configure_auto_gap_or_cdrx_for_utra(
        /*SPR 17777 +-*/
        rrm_ue_context_t        *p_ue_context,
        rrm_ue_rat_et           rat_type
        )
{
    rrm_bool_et configure_auto_gap = RRM_TRUE;
    rrm_neigh_cell_si_acquisition_parameters_r9_t 
        *p_fdd_add_si_acquisition_params_r9 = RRM_PNULL;
    rrm_neigh_cell_si_acquisition_parameters_r9_t                                    
        *p_tdd_add_si_acquisition_params_r9 = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
            (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask &
             RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)) 
    {
        if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.bitmask &
                    RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT) &&
                (RRC_UE_EUTRA_CAPABILITY_V9a0_IES_PRESENT & p_ue_context->ue_capability_params.
                 rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.bitmask))
        {
            if(RRM_UE_EUTRA_CAPABILITY_ADDFDD_MODE_R9_PRESENT & p_ue_context->ue_capability_params.
                    rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v9a0_ies.bitmask)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "FDD Add SI Acq Params Present");
                p_fdd_add_si_acquisition_params_r9 = &(p_ue_context->ue_capability_params.
                        rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v9a0_ies.fdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9);
            }
            if(RRM_UE_EUTRA_CAPABILITY_ADDTDD_MODE_R9_PRESENT & p_ue_context->ue_capability_params.
                    rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                    ue_eutra_capability_v9a0_ies.bitmask)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "TDD Add SI Acq Params Present");
                p_tdd_add_si_acquisition_params_r9 = &(p_ue_context->ue_capability_params.
                        rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                        ue_eutra_capability_v9a0_ies.tdd_add_ue_eutra_capabilities_r9.neigh_cellsi_acquisition_parameters_r9);
            }
        }

        if(UTRAN_FDD_RAT == rat_type)
        {
            if(RRM_PNULL != p_fdd_add_si_acquisition_params_r9)
            {
                if(RRM_FALSE == p_fdd_add_si_acquisition_params_r9->utran_si_acquisition_for_ho_supported_r9)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "UE Does NOT support FDD Add SI Acq for UTRAN");
                    configure_auto_gap = RRM_FALSE;
                }
            }
            else if(RRM_FALSE == p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.neigh_cell_si_acquisition_parameters_r9.
                    utran_si_acquisition_for_ho_supported_r9)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE Does NOT support FDD SI Acq for UTRAN");
                configure_auto_gap = RRM_FALSE;
            }
        }
        else
        {
            if(RRM_PNULL != p_tdd_add_si_acquisition_params_r9)
            {
                if(RRM_FALSE == p_tdd_add_si_acquisition_params_r9->utran_si_acquisition_for_ho_supported_r9)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "UE Does NOT support TDD Add SI Acq for UTRAN");
                    configure_auto_gap = RRM_FALSE;
                }
            }
            else if(RRM_FALSE == p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.neigh_cell_si_acquisition_parameters_r9.
                    utran_si_acquisition_for_ho_supported_r9)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UE Does NOT support TDD SI Acq for UTRAN");
                configure_auto_gap = RRM_FALSE;
            }
        }
    }

    RRM_UT_TRACE_EXIT();
    return configure_auto_gap;
}
/* SPR 12897 End */

/*SPR_14854_changes_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_set_last_configured_rat
 *   DESCRIPTION: This function set last configured rat 
 *                  
 *   RETURNS:       
 ******************************************************************************/
    void rrm_set_last_configured_rat
(
 rrm_cell_context_t *p_cell_context,
 U8 *last_configured_rat
 )
{
    RRM_UT_TRACE_ENTER();
    if(EUTRAN_RAT == *last_configured_rat)
    {
        if(RRM_ZERO < p_cell_context->meas_utran_list.count)
            *last_configured_rat = UTRAN_FDD_RAT;
        else if(RRM_ZERO < p_cell_context->meas_utran_tdd_list.count)
            *last_configured_rat = UTRAN_TDD_RAT;
        else if(RRM_ZERO < p_cell_context->meas_geran_list.count)
            *last_configured_rat = GERAN_RAT;
        else if(RRM_ZERO < p_cell_context->meas_cdma_list.count)
            *last_configured_rat = CDMA_RAT;
    }
    else if(UTRAN_FDD_RAT == *last_configured_rat)
    {
        if(RRM_ZERO < p_cell_context->meas_utran_tdd_list.count)
            *last_configured_rat = UTRAN_TDD_RAT;
        else if(RRM_ZERO < p_cell_context->meas_geran_list.count)
            *last_configured_rat = GERAN_RAT;
        else if(RRM_ZERO < p_cell_context->meas_cdma_list.count)
            *last_configured_rat = CDMA_RAT;
        else if(RRM_ZERO < p_cell_context->meas_eutran_list.count)
            *last_configured_rat = EUTRAN_RAT;
    }
    else if(UTRAN_TDD_RAT == *last_configured_rat)
    {
        if(RRM_ZERO < p_cell_context->meas_geran_list.count)
            *last_configured_rat = GERAN_RAT;
        else if(RRM_ZERO < p_cell_context->meas_cdma_list.count)
            *last_configured_rat = CDMA_RAT;
        else if(RRM_ZERO < p_cell_context->meas_eutran_list.count)
            *last_configured_rat = EUTRAN_RAT;
        else if(RRM_ZERO < p_cell_context->meas_utran_list.count)
            *last_configured_rat = UTRAN_FDD_RAT;
    }
    else if(GERAN_RAT == *last_configured_rat)
    {
        if(RRM_ZERO < p_cell_context->meas_cdma_list.count)
            *last_configured_rat = CDMA_RAT;
        else if(RRM_ZERO < p_cell_context->meas_eutran_list.count)
            *last_configured_rat = EUTRAN_RAT;
        else if(RRM_ZERO < p_cell_context->meas_utran_list.count)
            *last_configured_rat = UTRAN_FDD_RAT;
        /* SPR 22490 Fix Start */
        else if(RRM_ZERO < p_cell_context->meas_utran_tdd_list.count)
        /* SPR 22490 Fix End */
            *last_configured_rat = UTRAN_TDD_RAT;

    }
    else if(CDMA_RAT == *last_configured_rat)
    {
        if(RRM_ZERO < p_cell_context->meas_eutran_list.count)
            *last_configured_rat = EUTRAN_RAT;
        else if(RRM_ZERO < p_cell_context->meas_utran_list.count)
            *last_configured_rat = UTRAN_FDD_RAT;
        else if(RRM_ZERO < p_cell_context->meas_utran_tdd_list.count)
            *last_configured_rat = UTRAN_TDD_RAT;
        else if(RRM_ZERO < p_cell_context->meas_geran_list.count)
            *last_configured_rat = GERAN_RAT;
    }
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "Last Configured RAT = %d", *last_configured_rat);
    RRM_UT_TRACE_EXIT();
}
/*SPR_14854_changes_end*/
/* Fix for CSR: 00059124 */

/*spr 17848 fix start*/
/****************************************************************************
 * Function Name  : rrm_get_next_available_rat 
 * Inputs         : unconf_rat_bitmap,num_rats_configured 
 * Outputs        : None
 * Returns        : rrm_ue_rat_et
 * Description    : It provides the next available rat that can be configured
 *                  on the UE from available set of unconfigured UEs.
 ****************************************************************************/
    static rrm_ue_rat_et
rrm_get_next_available_rat(U8 unconf_rat_bitmap,U8 num_rats_configured)
{
    rrm_ue_rat_et    retval 	    = NO_RAT_CONFIGURED;
    rrm_ue_rat_et    start_rat      = NO_RAT_CONFIGURED; 
    U8               loop_count     = RRM_ONE;   

    RRM_UT_TRACE_ENTER();
    /*Get the rat type to start the search for next available rat .
     *If the current rat type is an invalid value or it is last RAT then 
     *starting rat becomes EUTRAN,else the starting rat is next from the current*/
    if((NO_RAT_CONFIGURED == num_rats_configured) ||((RRM_MAX_RAT - RRM_ONE) <=  num_rats_configured))
    {
        start_rat = EUTRAN_RAT; 
    }
    else
    {
        /*CID 96916 Start*/
        start_rat = (rrm_ue_rat_et)(num_rats_configured + RRM_ONE);
        /*CID 96916 End*/
    }

    /*Search the available rat type i.e. rat type for which a Ue can be configured from existing 
     *collection of UEs.The search is done in the circular fashion.
     *The loop shall be traversing to the 5 times as total number of Rats available in rrm_ue_rat_et */
    while(loop_count < RRM_MAX_RAT)
    {
        if(RRM_ZERO == (unconf_rat_bitmap & (RRM_ONE << start_rat)))
        {
            retval = start_rat;
            break;
        }

        if((NO_RAT_CONFIGURED >= start_rat) ||((RRM_MAX_RAT - RRM_ONE) <=  start_rat))
        {
            start_rat = EUTRAN_RAT; 
        }
        else
        {
            start_rat = (rrm_ue_rat_et)(start_rat + RRM_ONE);
        }
        loop_count++;
    }

    RRM_UT_TRACE_EXIT();
    return retval;
}
/*spr 17848 fix stop*/
/******************************************************************************
 *   FUNCTION NAME: rrm_send_meas_config_request_to_selected_ues
 *   DESCRIPTION:   This function sends meas config request to ANR selected 
 *                  UEs.
 *   RETURNS:       No of UE's to which the meas config request has been sent
 ******************************************************************************/
U8
    rrm_send_meas_config_request_to_selected_ues
(
 rrm_cell_context_t *p_cell_context
 )
{
    /* Coverity Fix 99674 Start */
    U16                                 index           = RRM_ZERO;
    /* Coverity Fix 99674 End */
    rrm_anr_meas_config_ue_category_et anr_ue_category = RRM_CELL_EDGE_UES_SUPPORTING_AUTONOMOUS_GAP;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    rrm_ue_context_t                  *p_ue_context    = RRM_PNULL;
    U8                                 no_of_meas_config_req_sent = RRM_ZERO;
    U8                                 num_rats_configured = EUTRAN_RAT;
    /*spr 17848 fix start*/
    /*code deleted*/
    /*spr 17848 fix stop*/
    rrm_bool_et                        rat_updated = RRM_FALSE;
    U8                                 total_no_ues_categorized = RRM_ZERO; 
    /* SPR 12897, 12973 Start */
    /*SPR_15325 start*/
    /*Code   Deleted*/
    /*SPR_15325 end*/
    U8                                 last_configured_rat = NO_RAT_CONFIGURED;
    /* SPR 12897, 12973 End */
    /* SPR 12971 Start */
    /*spr 17848 fix start*/
    /*code deleted*/
    U8                                 unconf_rat_bitmap = RRM_ZERO;
    U8                                 exhausted_rat_bitmap = RRM_ZERO; 
    /*spr 17848 fix stop*/
    /* SPR 12971 End */

    RRM_UT_TRACE_ENTER();

    /* SPR 12971 Start */
    num_rats_configured = p_cell_context->starting_rat_type_for_anr;
    /* SPR 12971 End */

    /* Start fix for SPR 14987 */
    p_cell_context->num_anr_strong_cell_req_sent = RRM_ZERO;
    /* End fix for SPR 14987 */
    for (index = RRM_ZERO; index < RRM_MAX_ANR_MEAS_CONFIG_UE_CATEGORY; index++)
    {
        total_no_ues_categorized +=
            p_cell_context->anr_meas_config_ue_category_list[index].count;
    }
    /*spr 17848 fix start*/
    if((total_no_ues_categorized) && (p_cell_context->ue_meas_cnt))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "Number of total_no_ues_categorized is:[%u],p_cell_context->ue_meas_cnt:[%u] ",
                total_no_ues_categorized,p_cell_context->ue_meas_cnt);

        exhausted_rat_bitmap = (RRM_ONE << EUTRAN_RAT)|(RRM_ONE << UTRAN_FDD_RAT)|
            (RRM_ONE << UTRAN_TDD_RAT)|(RRM_ONE << GERAN_RAT)|(RRM_ONE << CDMA_RAT);

        if(RRM_ZERO ==  p_cell_context->meas_eutran_list.count)
        {
            unconf_rat_bitmap |= (RRM_ONE << EUTRAN_RAT); 
        }
        if(RRM_ZERO ==  p_cell_context->meas_utran_list.count)
        {
            unconf_rat_bitmap |= (RRM_ONE << UTRAN_FDD_RAT);
        }   

        if(RRM_ZERO ==  p_cell_context->meas_utran_tdd_list.count)
        {
            unconf_rat_bitmap |= (RRM_ONE << UTRAN_TDD_RAT);
        }

        if(RRM_ZERO  ==  p_cell_context->meas_geran_list.count)
        {
            unconf_rat_bitmap |= (RRM_ONE << GERAN_RAT);
        }

        if(RRM_ZERO ==  p_cell_context->meas_cdma_list.count)
        {
            unconf_rat_bitmap |= (RRM_ONE << CDMA_RAT);
        }

        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "unconf_rat_bitmap:[%u],EUTRAN_RAT_BIT:[%u],UTRAN_FDD_RAT_BIT:[%u],"
                "UTRAN_TDD_RAT:[%u],GERAN_RAT_BIT:[%u],CDMA_RAT_BIT:[%u] ,"
                "exhausted_rat_bitmap:[%u] ",unconf_rat_bitmap,
                ((unconf_rat_bitmap & (RRM_ONE << EUTRAN_RAT)) >> EUTRAN_RAT),
                ((unconf_rat_bitmap & (RRM_ONE << UTRAN_FDD_RAT)) >> UTRAN_FDD_RAT),
                ((unconf_rat_bitmap & (RRM_ONE << UTRAN_TDD_RAT)) >> UTRAN_TDD_RAT),
                ((unconf_rat_bitmap & (RRM_ONE << GERAN_RAT)) >> GERAN_RAT),
                ((unconf_rat_bitmap & (RRM_ONE << CDMA_RAT)) >> CDMA_RAT),
                exhausted_rat_bitmap);

        if(unconf_rat_bitmap != exhausted_rat_bitmap)
        {
            /*This is a fail safe check,in case the starting rat value available is out of expected range*/
            if((NO_RAT_CONFIGURED == num_rats_configured ) || (RRM_MAX_RAT <= num_rats_configured))
            {  
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        "Unexpected Rat Type.The num_rats_configured value is[%u]",num_rats_configured);
                num_rats_configured = rrm_get_next_available_rat(unconf_rat_bitmap,num_rats_configured); 
            }
            /*In case the starting rat value is within the expected range, check if it is marked*/
            else if(RRM_ZERO != (unconf_rat_bitmap & (RRM_ONE << num_rats_configured)))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        " num_rats_configured[%u] is marked as un-configurable(i.e.non zero):[%u] ",num_rats_configured,
                        ((unconf_rat_bitmap & (RRM_ONE << num_rats_configured)) >> num_rats_configured));
                num_rats_configured = rrm_get_next_available_rat(unconf_rat_bitmap,num_rats_configured); 
            }
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    " start with the rat type[%u]",num_rats_configured);

            if(NO_RAT_CONFIGURED != num_rats_configured)
            {
                /*spr 17848 fix stop*/
                for (;(no_of_meas_config_req_sent < p_cell_context->ue_meas_cnt) && 
                        /* Bug 1022 Fix Start */
                        (no_of_meas_config_req_sent < total_no_ues_categorized);)
                    /* Bug 1022 Fix End */
                {
                    /*spr 17848 fix start*/
                    if(RRM_MAX_ANR_MEAS_CONFIG_UE_CATEGORY ==  anr_ue_category)
                    {
                        if((NO_RAT_CONFIGURED < num_rats_configured) && (RRM_MAX_RAT > num_rats_configured))
                        {
                            unconf_rat_bitmap |= (RRM_ONE << num_rats_configured);    
                        }
                        num_rats_configured = rrm_get_next_available_rat(unconf_rat_bitmap,num_rats_configured);
                        if(NO_RAT_CONFIGURED ==  num_rats_configured)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "No RAT shall be configured further ");
                            break;
                        } 
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                " New Rat selected is:[%u]",num_rats_configured);

                        anr_ue_category = RRM_CELL_EDGE_UES_SUPPORTING_AUTONOMOUS_GAP;
                    }
                    /*spr 17848 fix stop*/

                    /*spr 17848 fix start*/
                    /*code deleted*/
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "UE count %d  ue_cat %d", p_cell_context->anr_meas_config_ue_category_list[anr_ue_category].count , anr_ue_category);
                    /*spr 17848 fix stop*/

                    index = RRM_ZERO;
                    /*spr 17848 fix start*/
                    /*Check that for a given ANR UE Category,any UE is configured for the given RAT.
                     *If any UE gets configured, break from the loop*/
                    while (index < p_cell_context->anr_meas_config_ue_category_list[anr_ue_category].count)
                        /*spr 17848 fix stop*/
                    {
                        /* SPR 20652 Fix Start */
                        p_ue_context = rrm_ue_find_context(p_cell_context->anr_meas_config_ue_category_list[anr_ue_category].ue_index_list[index],
                                p_cell_context->cell_index);
                        index++;
                        if (RRM_PNULL != p_ue_context)
                        {
                            /* SPR 20652 Fix End */
                            /* SPR 17661 Fix Start */
                            if ((RRM_PNULL != p_ue_context) && (NO_RAT_CONFIGURED == p_ue_context->rat_configured) &&
                                    (p_ue_context->current_procedure.state == RRM_UE_ERB_NULL)) /* SPR 17661 Fix Stop */
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                        "[UE:%d] ANR UE category is %d & Rat type = %d",
                                        p_ue_context->ue_index, anr_ue_category, num_rats_configured);

                                switch (num_rats_configured)
                                {
                                    case EUTRAN_RAT:
                                        /*SPR_14854_changes_start*/
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/
                                        /*SPR_14854_changes_end*/
                                        if( (UE_SUPPORT_INTRAFREQ_RAT & p_ue_context->supported_rats) ||
                                                (UE_SUPPORT_INTERFREQ_RAT & p_ue_context->supported_rats )) 
                                        {  
                                            /*SPR_15325 start*/
                                            /*Code   Deleted*/
                                            /*SPR_15325 end*/
                                            p_ue_context->rat_configured = EUTRAN_RAT;
                                            rat_updated = RRM_TRUE;	
                                        }
                                        break;			
                                        /*SPR_14854_changes_start*/
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/
                                        /*SPR_14854_changes_end*/
                                    case UTRAN_FDD_RAT:
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/
                                        if(UE_SUPPORT_UTRAN_RAT & p_ue_context->supported_rats) 
                                        {  
                                            /*SPR_15325 start*/
                                            /*Code   Deleted*/
                                            /*SPR_15325 end*/

                                            p_ue_context->rat_configured = UTRAN_FDD_RAT;
                                            rat_updated = RRM_TRUE;	
                                        }
                                        break;			
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/

                                    case UTRAN_TDD_RAT:
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/
                                        if(UE_SUPPORT_UTRAN_RAT & p_ue_context->supported_rats) 
                                        {  
                                            /*SPR_15325 start*/
                                            /*Code   Deleted*/
                                            /*SPR_15325 end*/

                                            p_ue_context->rat_configured = UTRAN_TDD_RAT;
                                            rat_updated = RRM_TRUE;	
                                        }
                                        break;			
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/

                                    case GERAN_RAT:
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/
                                        if(UE_SUPPORT_GERAN_RAT & p_ue_context->supported_rats) 
                                        {  
                                            p_ue_context->rat_configured = GERAN_RAT;
                                            rat_updated = RRM_TRUE;	
                                        }
                                        break;			
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/

                                    case CDMA_RAT:
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/
                                        if((UE_SUPPORT_HRPD_RAT & p_ue_context->supported_rats) || 
                                                (UE_SUPPORT_1XRTT & p_ue_context->supported_rats))
                                        {  
                                            p_ue_context->rat_configured = CDMA_RAT;
                                            rat_updated = RRM_TRUE;	
                                        }
                                        /*spr 17848 fix start*/
                                        /*code deleted*/
                                        /*spr 17848 fix stop*/
                                        break;			

                                    default :
                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                                "[UE:%d] ANR UE category %d has no supported rat type",
                                                p_ue_context->ue_index, anr_ue_category);
                                }

                                /*spr 17848 fix start*/
                                /*code deleted*/
                                /*spr 17848 fix stop*/
                                if(RRM_FALSE == rat_updated)
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                            "[UE:%d] does not support the required rat type to be configured = %d. Checking next UE",
                                            p_ue_context->ue_index, num_rats_configured);
                                    continue;
                                }

                                /* SPR 12897, 12973 Delete */
                                if(RRM_FAILURE == rrm_build_and_send_meas_config_req(
                                            p_ue_context, MEAS_TYPE_ANR))
                                {
                                    rrm_uem_check_and_reset_meas_config_struct(p_ue_context);
                                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                            "Meas Config Struct is reset for [UE:%d]",
                                            p_ue_context->ue_index);

                                    /* Resset the values*/
                                    p_ue_context->rat_configured = NO_RAT_CONFIGURED;
                                    rat_updated = RRM_FALSE;	
                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                            "Meas Config Request sent for [UE:%d] for rat type [%d]",
                                            p_ue_context->ue_index, p_ue_context->rat_configured);
                                    p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;
                                    /* SPR 15797 Start */
                                    p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING; 
                                    /* SPR 15797 End */
                                    no_of_meas_config_req_sent++;
                                    last_configured_rat = p_ue_context->rat_configured;
                                }
                                /*SPR_15325 start*/
                                /*Code   Deleted*/
                                /*SPR_15325 end*/
                            }
                            /* SPR 17661 Fix Start */
                            else if (RRM_PNULL != p_ue_context)
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                                        "Rat Configured = %d Current procedure state in UE Context = %d", 
                                        p_ue_context->rat_configured, p_ue_context->current_procedure.state); /* SPR 17661 Fix Stop */
                            }

                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                                    "[UE:%d] context not found",
                                    p_cell_context->anr_meas_config_ue_category_list[anr_ue_category].ue_index_list[index]);
                        }
                        if(rat_updated)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Successfully sent! Going to configure next rat"); 
                            /* SPR 12971 Start */
                            /*spr 17848 fix start*/
                            /*code deleted*/
                            /*spr 17848 fix stop*/
                            /* SPR 12971 End */
                            break;
                        }
                    }

                    if(RRM_TRUE == rat_updated) 
                    {
                        /*spr 17848 fix start*/
                        num_rats_configured = rrm_get_next_available_rat(unconf_rat_bitmap,num_rats_configured);
                        /*This is a safe check,but it should not happen ideally*/
                        if(NO_RAT_CONFIGURED == num_rats_configured)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                    "No RAT can be configured further."); 
                            break;
                        }
                        /*spr 17848 fix stop*/
                        anr_ue_category = RRM_CELL_EDGE_UES_SUPPORTING_AUTONOMOUS_GAP;
                        rat_updated = RRM_FALSE;	
                        /*spr 17848 fix start*/
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                " Moving to new rat %d  " , num_rats_configured);
                        /*spr 17848 fix stop*/
                    }
                    else
                    {
                        anr_ue_category++;
                        /*spr 17848 fix start*/
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "  moved to new category now  %d  " , anr_ue_category );
                        /*spr 17848 fix stop*/
                    }

                }
                /*spr 17848 fix start*/
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "  No frequency is configured  for ANR,No Ue is selected ");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "No Algo shall initiate.Number of total_no_ues_categorized is:[%u],p_cell_context->ue_meas_cnt:[%u] ",
                total_no_ues_categorized,p_cell_context->ue_meas_cnt);
    }
    /*spr 17848 fix stop*/

    /* SPR 12973 Delete */

    /* SPR 12971 Start */
    if(no_of_meas_config_req_sent)
    {
        /* Update Starting RAT type to be configured at next timer expiry */
        /*SPR_14854_changes_start*/
        rrm_set_last_configured_rat(p_cell_context,&last_configured_rat);
        /*SPR_14854_changes_end*/

        /* Update Starting RAT type to be configured at next timer expiry */
        p_cell_context->starting_rat_type_for_anr = last_configured_rat;

        /* Start fix for SPR 14987: Store, to be used at UE attach */
        p_cell_context->num_anr_strong_cell_req_sent = no_of_meas_config_req_sent;
        /* End fix for SPR 14987 */
        /*spr 17848 fix start*/
    }
    /*spr 17848 fix stop*/
    /*CID 96913 Start*/
    for(anr_ue_category = RRM_CELL_EDGE_UES_SUPPORTING_AUTONOMOUS_GAP;
            anr_ue_category < RRM_MAX_ANR_MEAS_CONFIG_UE_CATEGORY;
            anr_ue_category++)
        /*CID 96913 End*/
    {
        for(index = RRM_ZERO; (index < p_cell_context->anr_meas_config_ue_category_list[anr_ue_category].count)
                && (index < MAX_NUM_OF_UE);
                index++)
        {
            p_ue_context = rrm_ue_find_context(p_cell_context->anr_meas_config_ue_category_list[anr_ue_category].ue_index_list[index],
                    p_cell_context->cell_index);
            if (RRM_PNULL != p_ue_context)
            {
                p_ue_context->rat_configured = NO_RAT_CONFIGURED;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                        "[UE:%d] context not found",
                        p_cell_context->anr_meas_config_ue_category_list[anr_ue_category].ue_index_list[index]);
            }
        }
        p_cell_context->anr_meas_config_ue_category_list[anr_ue_category].count = RRM_ZERO;
    }
    /*spr 17848 fix start*/
    /*code deleted*/   
    /*spr 17848 fix stop*/

    /* SPR 12971 End */

    RRM_UT_TRACE_EXIT();
    return no_of_meas_config_req_sent;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_is_ue_inactive
 *   DESCRIPTION:   Function checks if the UE is inactive or not.
 *   RETURNS:       RRM_TRUE, if UL and DL throughput of UE are below threshold.
 *                  otherwise, returns RRM_FALSE.
 ******************************************************************************/
rrm_bool_et
    rrm_is_ue_inactive
(
 rrm_cell_context_t *p_cell_context,
 rrm_ue_context_t   *p_ue_context
 )
{
    rrm_bool_et ue_inactive = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    if (RRM_PNULL != p_ue_context)
    {
        /* SPR-10397-fix start */
        if ((p_cell_context->rrm_ue_throughput_ul_anr_threshold > p_ue_context->ue_ecn_list.max_ul_thp) &&
                /* SPR_15697_Fix: Start */
                (p_cell_context->rrm_ue_throughput_dl_anr_threshold > p_ue_context->ue_ecn_list.max_dl_thp))
            /* SPR_15697_Fix: End */
            /* SPR-10397-fix end */
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "[UE:%d] is inactive",
                    p_ue_context->ue_index);
            ue_inactive = RRM_TRUE;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "UE context is found NULL");
    }

    RRM_UT_TRACE_EXIT();
    return ue_inactive;
}

/* SPR 16079 start */
/******************************************************************************
 *   FUNCTION NAME: rrm_check_is_ho_ongoing_or_meas_ongoing
 *
 *   DESCRIPTION:   Check for HO or meas on going or not
 *   RETURNS : TRUE or FALSE
 ******************************************************************************/
rrm_bool_et
    rrm_check_is_ho_ongoing_or_meas_ongoing
(
 rrm_ue_context_t    *p_rrm_ue_context
 )
{
    rrm_bool_et     is_ho_ongoing = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
    if ((RRM_ZERO != p_rrm_ue_context->report_amount_ue) ||
            (RRM_UE_STATE_HO_ONGOING == p_rrm_ue_context->ue_state) ||
        /*SPR_17893_START*/
        (RRM_UE_STATE_WAIT_FOR_CAP_ENQ_RES == p_rrm_ue_context->ue_state)||
        /*SPR_17893_END*/
        /* Spr 18748 Fix Start */
        (RRM_TRUE == rrm_check_if_sec_meas_configured(p_rrm_ue_context)))
        /* Spr 18748 Fix End */
            
    {
        /*SPR_17893_START*/
        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name,RRM_DETAILED,
                "For [UE:%d] either HO is Ongoing/Waiting for UTRAN Capbility"
                " or Meas object is configured",
                p_rrm_ue_context->ue_index);
        /*SPR_17893_END*/
        is_ho_ongoing = RRM_TRUE;
    }

    RRM_UT_TRACE_EXIT();
    return is_ho_ongoing;
}
/* SPR 16079 end */

/******************************************************************************
 *   FUNCTION NAME: rrm_anr_meas_config_ue_selction_algo
 * 
 *   DESCRIPTION:   Algorithms is based upon the following logic:
 *                  Let's suppose we need to have x number of UEs to be selected
 *                  for ANR. 
 *                  1.The first priority would be given to the UEs which are
 *                    on cell edge and are having the autonomous gap capability. 
 *                    (say a number of UEs got selected) {where a < x}. Since a<x,
 *                    so more number of UEs are to be selected for ANR. 
 *                  2.The next priority would be given to the UEs which are on the cell edge
 *                    but for them autonomous gap capability is not supported.(say b
 *                    number of UEs) {where a + b < x}.
 *                  3.The next priority would be given to the number of UEs which are 
 *                    inactive and are having the autonomous gap capability.(say c 
 *                    number of UEs) {where a+b+c < x}
 *                  4.The next priority would be given to the number of UEs which are
 *                    inactive but for them autonomous gap capability is not supported. 
 *
 *   RETURNS:       NONE
 ******************************************************************************/
rrm_void_t
    rrm_anr_meas_config_ue_selction_algo
(
 rrm_cell_context_t *p_cell_context
 )
{
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* SPR 20652 Fix End */
    rrm_ue_position_et ue_position       = RRM_UE_POSITION_AT_CELL_CENTER;
    U8                 count             = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    /* SPR 20652 Fix Start */
    rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, p_cell_context->cell_index);
    while(RRM_PNULL != p_ue_context)
    {
        /* SPR 20652 Fix End */
        if((p_ue_context->supported_rats != RRM_ZERO) &&
                /* SPR 16079 start */
                (RRM_FALSE == rrm_check_is_ho_ongoing_or_meas_ongoing(p_ue_context)) && 
                /* SPR 16079 end */
                /* SPR 16406 Start */
                (RRM_FALSE == p_ue_context->is_cgi_process_in_progress))

            /* SPR 16406 End */
        {
            /* If a UE is found with the specified cell index */
            if (p_cell_context->cell_index == p_ue_context->cell_index)
            {
                /* SPR-13322-fix start */
                if ((RRM_FALSE  ==  p_ue_context->interfreq_interrat_meas_configured) &&
                        (RRM_TRUE == rrm_is_ue_attached(p_ue_context)) &&
                        (RRM_UE_CDRX_DISABLED == p_ue_context->cdrx_status))
                    /* SPR-13322-fix end */
                {
                    ue_position = p_ue_context->dynamic_icic_info.\
                                  rrm_ue_dynamic_icic_present_data.ue_present_position;

                    if (RRM_UE_POSITION_AT_CELL_EDGE == ue_position)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Cell-edge UE");
                        if (RRM_TRUE == rrm_is_ue_supporting_autonomous_gap(p_ue_context))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Autonomous gaps");
                            count = p_cell_context->anr_meas_config_ue_category_list[RRM_CELL_EDGE_UES_SUPPORTING_AUTONOMOUS_GAP].count;
                            /* SPR 20526 Fix Start */
                            if(p_cell_context->anr_meas_config_ue_category_list[RRM_CELL_EDGE_UES_SUPPORTING_AUTONOMOUS_GAP].count < MAX_NUM_OF_UE)
                            {
                                /* SPR 20652 Fix Start */
                                p_cell_context->anr_meas_config_ue_category_list[RRM_CELL_EDGE_UES_SUPPORTING_AUTONOMOUS_GAP].\
                                    ue_index_list[count] = p_ue_context->ue_index;
                                /* SPR 20652 Fix End */
                                p_cell_context->anr_meas_config_ue_category_list[RRM_CELL_EDGE_UES_SUPPORTING_AUTONOMOUS_GAP].count++;
                            }
                            /* SPR 20526 Fix End */
                        }
                        else
                        {
                            if( RRM_TRUE == is_ue_supported_fgi_for_cdrx(p_ue_context))
                            {    
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "CDRX supported by UE");
                                count = p_cell_context->anr_meas_config_ue_category_list[RRM_CELL_EDGE_UES_NOT_SUPPORTING_AUTONOMOUS_GAP].count;
                                /* SPR 20526 Fix Start */
                                if(p_cell_context->anr_meas_config_ue_category_list[RRM_CELL_EDGE_UES_NOT_SUPPORTING_AUTONOMOUS_GAP].count < MAX_NUM_OF_UE)
                                {
                                    /* SPR 20652 Fix Start */
                                    p_cell_context->anr_meas_config_ue_category_list[RRM_CELL_EDGE_UES_NOT_SUPPORTING_AUTONOMOUS_GAP].\
                                        ue_index_list[count] = p_ue_context->ue_index;
                                    /* SPR 20652 Fix End */
                                    p_cell_context->anr_meas_config_ue_category_list[RRM_CELL_EDGE_UES_NOT_SUPPORTING_AUTONOMOUS_GAP].count++;
                                }
                                /* SPR 20526 Fix End */
                            }
                        }
                    }
                    else if (RRM_TRUE == rrm_is_ue_inactive(p_cell_context, p_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "INactive UE");
                        if (RRM_TRUE == rrm_is_ue_supporting_autonomous_gap(p_ue_context))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "Autonomous gaps");
                            count = p_cell_context->anr_meas_config_ue_category_list[RRM_INACTIVE_UES_SUPPORTING_AUTONOMOUS_GAP].count;
                            /* SPR 20526 Fix Start */
                            if(p_cell_context->anr_meas_config_ue_category_list[RRM_INACTIVE_UES_SUPPORTING_AUTONOMOUS_GAP].count < MAX_NUM_OF_UE)
                            {
                                /* SPR 20652 Fix Start */
                                p_cell_context->anr_meas_config_ue_category_list[RRM_INACTIVE_UES_SUPPORTING_AUTONOMOUS_GAP].\
                                    ue_index_list[count] = p_ue_context->ue_index;
                                /* SPR 20652 Fix End */
                                p_cell_context->anr_meas_config_ue_category_list[RRM_INACTIVE_UES_SUPPORTING_AUTONOMOUS_GAP].count++;
                            }
                            /* SPR 20526 Fix End */
                        }
                        else 
                        {
                            if( RRM_TRUE == is_ue_supported_fgi_for_cdrx(p_ue_context))
                            {    
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "CDRX supported by UE");
                                count = p_cell_context->anr_meas_config_ue_category_list[RRM_INACTIVE_UES_NOT_SUPPORTING_AUTONOMOUS_GAP].count;
                                /* SPR 20526 Fix Start */
                                if(p_cell_context->anr_meas_config_ue_category_list[RRM_INACTIVE_UES_NOT_SUPPORTING_AUTONOMOUS_GAP].count < MAX_NUM_OF_UE)
                                {
                                    /* SPR 20652 Fix Start */
                                    p_cell_context->anr_meas_config_ue_category_list[RRM_INACTIVE_UES_NOT_SUPPORTING_AUTONOMOUS_GAP].\
                                        ue_index_list[count] = p_ue_context->ue_index;
                                    /* SPR 20652 Fix End */
                                    p_cell_context->anr_meas_config_ue_category_list[RRM_INACTIVE_UES_NOT_SUPPORTING_AUTONOMOUS_GAP].count++;
                                }
                                /* SPR 20526 Fix End */
                            }
                        }
                    }
                    else
                    {
                        /* Start fix for SPR 14987 */
                        if (RRM_TRUE == p_cell_context->apply_anr_to_all_ue)
                        {
                            if ( (RRM_TRUE == rrm_is_ue_supporting_autonomous_gap(p_ue_context)) ||
                                    (RRM_TRUE == is_ue_supported_fgi_for_cdrx(p_ue_context)) )
                            {
                                /* SPR 20652 Fix Start */
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "[UE:%d] not falling in any of the ANR category, so put in RRM_REMAINING_ACTIVE_UES category",
                                        p_ue_context->ue_index);
                                /* SPR 20652 Fix End */
                                count = p_cell_context->anr_meas_config_ue_category_list[RRM_REMAINING_ACTIVE_UES].count;
                                /* SPR 20526 Fix Start */
                                if(p_cell_context->anr_meas_config_ue_category_list[RRM_REMAINING_ACTIVE_UES].count < MAX_NUM_OF_UE)
                                {
                                    /* SPR 20652 Fix Start */
                                    p_cell_context->anr_meas_config_ue_category_list[RRM_REMAINING_ACTIVE_UES].\
                                        ue_index_list[count] = p_ue_context->ue_index;
                                    /* SPR 20652 Fix End */
                                    p_cell_context->anr_meas_config_ue_category_list[RRM_REMAINING_ACTIVE_UES].count++;
                                }
                                /* SPR 20526 Fix End */
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "CDRX/Autonomous gaps not supported by UE rquired for ANR");
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "[UE:%d] not falling in any of the ANR category",
                                    p_ue_context->ue_index);
                        }
                        /* End fix for SPR 14987 */
                    }
                }
            }
        }
        else
        {
            /* SPR 16406 Start */
            /* coverity_fix 88198 ++ */
            if(PNULL == p_ue_context)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "UE index not satisfying the criteria for selection in ANR");
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "[UE:%d] not satisfying the criteria for selection in ANR",
                        p_ue_context->ue_index);
            }
            /* coverity_fix 88198 -- */
            /* SPR 16406 End  */
            /* SPR 21802 Fix Start */
	   /*code removed*/
            /* SPR 21802 Fix Start */
        }
        /* SPR 20652 Fix Start */
        ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, p_cell_context->cell_index);
    }
    /* Coverity_fix_start_62535 */
    /* SPR 20652 Fix End */
    /* Coverity_fix_end_62535 */
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_send_meas_config_req
 *   DESCRIPTION:
 *          This function prepares and sends the meas config request to RRC
 *          for Strongest cells Reporting purpose
 *   RETURNS:
 *             rrm_void_et
 ******************************************************************************/
rrm_void_t
    rrm_uem_send_meas_config_req
(
 rrm_cell_context_t *p_cell_context
 )
{
    U8 no_of_meas_config_req_sent = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if (RRM_PNULL != p_cell_context)
    {
        rrm_anr_meas_config_ue_selction_algo(p_cell_context);
        no_of_meas_config_req_sent = rrm_send_meas_config_request_to_selected_ues(p_cell_context);
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "No of UEs for which meas config request sent is %d",
                no_of_meas_config_req_sent);


    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Cell context is NULL");
    }

    RRM_UT_TRACE_EXIT();
}
/* Fix for CSR: 00059124 */

/* UE MEAS CHANGES : ENDS */

/*! Macros for QUEUE mechanisms for message queuing */
/******************************************************************************
 *   FUNCTION NAME: rrm_init_queue 
 *   DESCRIPTION:
 *           function to initialize the queue
 *   RETURNS:
 *		void
 ******************************************************************************/
 rrm_void_t 
    rrm_init_queue
(
 rrm_ue_proc_queue_t *p_procedure_queue
 )
{
    ylInit(p_procedure_queue);
}

/******************************************************************************
 *   FUNCTION NAME: rrm_get_queue_count
 *   DESCRIPTION:
 *           function to get the number of procedures in queue 
 *   RETURNS:
 *		void
 ******************************************************************************/
 U32 
    rrm_get_queue_count
(
 rrm_ue_proc_queue_t *p_procedure_queue
 )
{
    return ylCount(p_procedure_queue);
}

/*SPR 21479 Fix start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_get_ctxt
 *   DESCRIPTION:
 *          Function to get context of UE 
 *   RETURNS:
 *		void
 ******************************************************************************/
 rrm_ue_global_context_t * rrm_uem_get_ctxt(U16 module_id)
{
    rrm_error_et error_code = RRM_NO_ERROR;    
    return qvModuleContext(qvGetServiceEx(module_id,(int *)&error_code));
}
/*SPR 21479 Fix end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_request_enqueue 
 *   DESCRIPTION:
 *           function to enqueue the procedure 
 *   RETURNS:
 *		void
 ******************************************************************************/
 rrm_void_t 
    rrm_request_enqueue
(
 rrm_ue_proc_queue_t *p_procedure_queue, 
 rrm_ue_procedure_record_t *p_procedure_record
 )
{
    ylPushTail(p_procedure_queue, &(p_procedure_record)->s_node);
}

/* CSR00069389 Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_request_enqueue_before 
 *   DESCRIPTION:
 *           function to enqueue the procedure before the specified node
 *   RETURNS:
 *		void
 ******************************************************************************/
 rrm_void_t 
    rrm_request_enqueue_before
(
 rrm_ue_proc_queue_t *p_procedure_queue, 
 rrm_ue_procedure_record_t *p_procedure_record_next,
 rrm_ue_procedure_record_t *p_procedure_record
 )
{
    /* SPR_20915 - Fix - Starts */
    if(RRM_PNULL != p_procedure_record_next)
    {
    ylInsertBefore(p_procedure_queue, &(p_procedure_record_next)->s_node, &(p_procedure_record)->s_node);
    }
    else
    {
        ylPushTail(p_procedure_queue, &(p_procedure_record)->s_node);
    }
    /* SPR_20915 - Fix - Ends */
}
/* CSR00069389 End */

/* SPR 15849 Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_request_esmlc_dequeue 
 *   DESCRIPTION:
 *          function to dequeue the procedure
 *   RETURNS:
 *		void
 ******************************************************************************/
rrm_ue_procedure_record_t * 
    rrm_request_esmlc_dequeue
(
 rrm_ue_context_t *p_ue_context 
 )
{
    YLNODE *snode = ylPopHead(&(p_ue_context->esmlc_meas_req_queue));
    if(snode != RRM_PNULL)
    {
        return (rrm_ue_procedure_record_t*)YMEMBEROF
            (rrm_ue_procedure_record_t, s_node, snode);
    }
    return RRM_PNULL;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_request_dequeue 
 *   DESCRIPTION:
 *          function to dequeue the procedure
 *   RETURNS:
 *		void
 ******************************************************************************/
rrm_ue_procedure_record_t * 
    rrm_request_dequeue
(
 rrm_ue_context_t *p_ue_context
 )
{
    YLNODE *snode = ylPopHead(&(p_ue_context->procedure_queue));
    if(snode != RRM_PNULL)
    {
        rrm_ue_procedure_record_t *p_rrm_ue_procedure_record = (rrm_ue_procedure_record_t*)YMEMBEROF
            (rrm_ue_procedure_record_t, s_node, snode);

        if((p_ue_context->p_proc_queue_first_meas_node) == p_rrm_ue_procedure_record) 
        {

            YLNODE *tnode = ylFirst(&(p_ue_context->procedure_queue)); 
            p_ue_context->p_proc_queue_first_meas_node = (rrm_ue_procedure_record_t*)YMEMBEROF
                (rrm_ue_procedure_record_t, s_node, tnode);

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Updating p_proc_queue_first_meas_node from %p to %p",
                    p_ue_context->p_proc_queue_first_meas_node, 
                    p_rrm_ue_procedure_record);
        }
        return p_rrm_ue_procedure_record;
    }
    return RRM_PNULL;
}
/* SPR 15849 End */


/****************************************************************************
 * Function Name  : rrm_search_and_release_lowest_priority_arp 
 * Inputs         : rrm_void_t 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Find and release the lowest priorty rab_id
 ****************************************************************************/
/*SPR-695 Fix Starts*/
    rrm_return_et 
rrm_cellm_search_and_release_lowest_priority_arp(rrm_cell_index_t cell_index, U8 count)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    /* warnings removal: unused variable 'ue_erb', 10/05/2012 */
    /* rrm_ue_erb_t             ue_erb = {0};  */

    U16                      trans_id = RRM_ZERO;
    /*SPR-695 Fix Starts*/
    //rrm_ue_index_t ue_index = RRM_ZERO;
    rrmuem_cm_ue_rel_ind_t ue_rel_int_req = {RRM_ZERO};
    /*SPR-695 Fix Ends*/

    RRM_UT_TRACE_ENTER();
    /*SPR-695 Fix Starts*/
    ue_rel_int_req.trans_id = trans_id;
    ue_rel_int_req.cell_index = cell_index;
    ue_rel_int_req.count = count;

    if (count != RRM_ZERO)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "CELLM send RRMUEM_CM_DELETE_LOW_PRIORITY_UE_REQ for count:%d, cell_index:%d",
                ue_rel_int_req.count,
                ue_rel_int_req.cell_index);
        ret_val = rrm_send_internal_msg((U16)RRM_UEM_MODULE_ID,
                RRMUEM_CM_DELETE_LOW_PRIORITY_UE_REQ,
                sizeof(rrmuem_cm_ue_rel_ind_t),
                (void *)(&ue_rel_int_req));
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                "CELLM is not sending RRMUEM_CM_DELETE_LOW_PRIORITY_UE_REQ as the number of low priority UE found is:%d for cell_index:%d",
                count,
                cell_index);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR-695 Fix Ends*/
/* SPR 8315 FIX START*/

rrm_void_t
    rrm_uem_init_mac_ue_reconf_seq_list
(
 rrm_ue_global_context_t *p_rrm_glb_ctxt 
 )
{
    RRM_UT_TRACE_ENTER();

    /* Initialize the meas context lists */
    ylInit(&(p_rrm_glb_ctxt->mac_ue_reconfig_sequence_list));

    RRM_UT_TRACE_EXIT();
}
/* SPR 8315 FIX END*/
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_init
 *   DESCRIPTION:
 *       initialize the UEM module
 *   RETURNS:
 *       rrm_void_t * to global context.
 ******************************************************************************/
    rrm_void_t *
rrm_uem_init ( rrm_void_t *p_ue_init_data )
{
    rrm_ue_global_context_t *p_rrm_glb_ctxt = RRM_PNULL;
    U8                       index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    U8 rrm_ue_erb_list_index = RRM_NULL;

    RRM_INIT_LOG(RRM_PNULL);

    p_rrm_glb_ctxt = 
        (rrm_ue_global_context_t *)rrm_mem_get(sizeof(rrm_ue_global_context_t));
    if ( p_rrm_glb_ctxt == RRM_PNULL)
    {
        /*SPR 17777 +-*/
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_rrm_glb_ctxt failed"
                "Unused variable p_ue_init_data=%p",p_ue_init_data);
        /*SPR 17777 +-*/
        RRM_UT_TRACE_EXIT();
        return RRM_PNULL ;
    }
    RRM_MEMSET(p_rrm_glb_ctxt, RRM_ZERO, sizeof(rrm_ue_global_context_t));

    for(; rrm_ue_erb_list_index < RRM_MAX_ERAB_PRIORITY; rrm_ue_erb_list_index++)
    {
        ylInit(&ue_erab_priority_list[rrm_ue_erb_list_index]);
    }
    if(RRM_PNULL == p_rrm_glb_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                "rrm_init: unable to Allocate Memory for "
                "RRM global context!");
        return RRM_PNULL;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, 
                "Entry rrm_uem_init");
    }
    p_rrm_glb_ctxt->log_level = RRM_OAM_BRIEF;
    p_rrm_glb_ctxt->log_enabled = RRM_TRUE;
    /*Event Config Req Start*/
    p_rrm_glb_ctxt->event_config.pe_subcls = RRM_FALSE;
    p_rrm_glb_ctxt->event_config.ee_subcls = RRM_FALSE;
    rrm_set_pe_subclass_index(p_rrm_glb_ctxt, EVENT_ACTION_NONE);
    rrm_set_ee_subclass_index(p_rrm_glb_ctxt, EVENT_ACTION_NONE);
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_PE_INDEX] = EVENT_ACTION_NOTIFY_LOG;
    p_rrm_glb_ctxt->event_config.action_prfmd[RRM_EE_INDEX] = EVENT_ACTION_NOTIFY_LOG;
    /*Event Config Req End*/    

    /* RACH_OPTIMIZATION_CHANGES_START */
    p_rrm_glb_ctxt->rrm_uem_rach_info_data.is_ue_rach_report_active = RRM_FALSE;
    p_rrm_glb_ctxt->rrm_uem_rach_info_data.ue_reports_periodicity = RRM_ZERO;
    p_rrm_glb_ctxt->rrm_uem_rach_info_data.rach_sample_count = RRM_ZERO;
    p_rrm_glb_ctxt->rrm_uem_rach_info_data.strong_cell_info_count = RRM_ZERO;
    ylInit(&(p_rrm_glb_ctxt->rrm_uem_rach_info_data.rach_report_list));
    /* RACH_OPTIMIZATION_CHANGES_END */
    /* Carrier Aggregation start*/
    for( index = RRM_ZERO ; index < 50 ; index++ )
    {
        p_rrm_glb_ctxt->tb_block[index].transaction_id = RRM_MINUS_ONE;
        p_rrm_glb_ctxt->tb_block[index].handler = RRM_NULL;
    }
    /* Carrier Aggregation end */
    /* SPR 8315 FIX START*/
    rrm_uem_init_mac_ue_reconf_seq_list(p_rrm_glb_ctxt);
    /* SPR 8315 FIX END*/
    SET_MODULE_LOG_LEVEL(RRM_OAM_BRIEF);
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
            "UEM Initialized");
    rrm_ue_send_rrmim_init_req(RRM_UEM_MODULE_ID);/*SPR 17777 +-*/
    RRM_UT_TRACE_EXIT();
    return p_rrm_glb_ctxt;
}

/******************************************************************************
 *   FUNCTION NAME: RrmUeMDestinationList
 *   DESCRIPTION:
 *       To set the ue destination list
 *   RETURNS:
 *       static const unsigned long
 ******************************************************************************/

static const unsigned long RrmUeMDestinationList[] =
{
    RRC_MODULE_ID,
    RRM_MIF_MODULE_ID,
    RRM_CM_MODULE_ID,
    0
};

/******************************************************************************
 *   FUNCTION NAME: UeRrmEntity
 *   DESCRIPTION:
 *       initialize the RRM Module
 *   RETURNS:
 *       const QMANIFEST
 ******************************************************************************/
const   QMANIFEST UeRrmEntity =
{
    "RRM_UEM_MODULE_ID",
    RRM_UEM_MODULE_ID,
    { RRM_ZERO, rrm_uem_init },
    { rrm_ue_mgr_msg_handler, rrm_ue_process_timer_msg},/*MC,MR &HO */
    { RRM_ZERO, RRM_ZERO, RRM_ZERO },
    RrmUeMDestinationList
};

/*UE RELEASE FROM OAM ->MIF->UE->RRC*/


/******************************************************************************
 *   FUNCTION NAME:rrm_uem_handle_rmif_ue_release_from_oam_req
 *   DESCRIPTION:
 *       Process the ue release  req from mif
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/


    rrm_return_et
rrm_uem_handle_rmif_ue_release_from_oam_req(rrm_void_t *p_data)

{           
    U16 trans_id=RRM_ZERO;
    rrm_ue_index_t ue_index=RRM_ZERO;
    rrm_cell_index_t cell_index = RRM_ZERO;

    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    rrmuem_rmif_ue_release_req_t *rrmuem_rmif_ue_release_req =RRM_PNULL;
    rrmuem_rmif_ue_release_req=(rrmuem_rmif_ue_release_req_t *)(p_data);
    ue_index= rrmuem_rmif_ue_release_req->ue_index;                
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */

    /*SPR_11366_FIX_START*/
    cell_index = rrmuem_rmif_ue_release_req->cell_index; 
    SET_CELL_AND_UE_INDEX(cell_index, ue_index);
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->RRMUEM_RMIF_UE_REL_REQ->UEM");
    if(RRM_MAX_CELLS_REPORTED <= cell_index)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,
                RRM_ERROR, "Invalid cell index [%d]", cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*Cov_fix_start_63560*/ 
    ret_val= rrm_build_and_send_ue_connection_release_ind(
            ue_index,
            RRM_S1AP_CAUSE_MISC,
            CAUSE_MISC_OAM_INTERVENTION,
            trans_id,
            RRM_PNULL,
            /* SPR_10729_fix */
            cell_index);
    /*SPR_11366_FIX_END*/
    if (ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Error in sending UE release indication");
    }
    else
    {
        /* SPR 20652 Fix Start */
        /*BUG 585 FIX START*/
        p_ue_context = rrm_ue_find_context(ue_index,
                cell_index);

        if (RRM_PNULL == p_ue_context)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING, "[UE:%d], failed to find ue context",
                    ue_index);
            ret_val = RRM_FAILURE;
        }
        else
        {
            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off,
                        p_g_rrm_uem_facility_name,
                        RRM_DETAILED,
                        "ue_connection_release_ind sent, Failed to clean up ue resources");
                ret_val = RRM_FAILURE;

            }
        }
    }
    /* SPR 20652 Fix End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
    /*Cov_fix_end_63560*/
}
/* MC,MR & HO START  */ 
    rrm_return_et
rrm_ue_mgr_timer_event_handler (
        rrm_ue_states_et            ue_state,				/*!< FSM states for UE				*/
        rrm_ue_events_et            ue_event,			    /*!< current event for FSM			*/
        rrm_ue_global_context_t *p_rrm_glb_ctxt
        )
{
    /* SPR 15441 start */
    return  rrm_uem_process_fsm(ue_state, 
            ue_event,
            p_rrm_glb_ctxt);
    /* SPR 15441 end  */
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_handle_rmif_release_all_existing_ue_forcefully_req
 *   DESCRIPTION:
 *       Process the all active ue release forcefully req from mif
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/


    rrm_return_et
rrm_uem_handle_rmif_release_all_existing_ue_forcefully_req (void *p_data)

{
    U16 trans_id = RRM_ZERO;
    rrm_cell_index_t cell_index = RRM_ZERO;
    /* SPR 20652 Fix Start */
    rrm_ue_context_t    *p_ue_context = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* Code Removed */
    /* SPR 20652 Fix End */

    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    rrmuem_rmif_release_all_existing_ue_forcefully_req_t *rrmuem_rmif_release_all_existing_ue_forcefully_req = RRM_PNULL;
    rrmuem_rmif_release_all_existing_ue_forcefully_req = (rrmuem_rmif_release_all_existing_ue_forcefully_req_t *)(p_data);
    cell_index = rrmuem_rmif_release_all_existing_ue_forcefully_req->cell_index;
    trans_id = rrmuem_rmif_release_all_existing_ue_forcefully_req->transaction_id;
    SET_CELL_INDEX(cell_index);
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->UEM:RRMUEM_RMIF_RELEASE_ALL_EXISTING_UE_FORCEFULLY_REQ");
    /* SPR 20652 Fix Start */
    rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
    while(p_ue_context != RRM_PNULL)
    {
        if (p_ue_context->cell_index == cell_index) 
        {
            /* SPR-20656 START */
            if (RRM_FALSE == rrm_is_ue_special_previledge(p_ue_context))
                /* SPR-20656 END */
            {

                ret_val= rrm_build_and_send_ue_connection_release_ind(
                        p_ue_context->ue_index,
                        RADIO_NETWORK_LAYER_TYPE,
                        UNSPECIFIED,
                        trans_id,
                        RRM_PNULL,
                        /* SPR_10729_fix */
                        cell_index);
                if (ret_val == RRM_FAILURE)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            "Error in sending UE release indication");
                }
                else
                {
                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off,
                                p_g_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "ue_connection_release_ind sent, \
                                Failed to clean up ue resources");
                        ret_val = RRM_FAILURE;

                    }
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Unspecified Cell Index!!");
        }
        ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
        /* SPR 20652 Fix End */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_handle_rmif_non_emergency_active_call_ho_req 
 *   DESCRIPTION:
 *       Process the HO_REQ from mif
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/

    rrm_return_et
rrm_uem_handle_rmif_non_emrgncy_active_calls_ho_req (void *p_data)
{
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* SPR 20652 Fix End */
    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_cell_index_t cell_index = RRM_ZERO;

    rrmuem_rmif_non_emrgncy_active_calls_ho_req_t *rrmuem_rmif_non_emrgncy_active_calls_ho_req = RRM_PNULL;
    rrmuem_rmif_non_emrgncy_active_calls_ho_req = (rrmuem_rmif_non_emrgncy_active_calls_ho_req_t *) p_data;
    rrm_ue_timer_buf_t timer_buff;
    rrm_cell_context_t*          p_cell_ctxt  = RRM_PNULL;

    /*SPR 16364 START*/
    U16                        transaction_id = RRM_ZERO;
    /* SPR 17488 Fix Start */
    /* Line deleted */
    /* SPR 17488 Fix End */
    /*SPR 16364 END*/

    RRM_UT_TRACE_ENTER();
    cell_index = rrmuem_rmif_non_emrgncy_active_calls_ho_req->cell_index;
    SET_CELL_INDEX(cell_index);
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"MIF->RRMUEM_RMIF_NON_EMRGNCY_ACTIVE_CALLS_HO_REQ->UEM");
    RRM_MEMSET (&timer_buff, RRM_ZERO, sizeof(rrm_ue_timer_buf_t));
    timer_buff.timer_type = RRM_UE_CELL_BLOCKED_W_FOR_HO_TIMER;
    timer_buff.trans_id = g_uem_gbl_proc.trans_id = rrmuem_rmif_non_emrgncy_active_calls_ho_req->transaction_id;
    timer_buff.cell_index = g_uem_gbl_proc.cell_index = cell_index;
    /*bug_1016*/
    g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_HO_TIMER] = rrm_ue_start_timer (
            (RRM_BLOCK_CELL_HO_RESP_WAIT_DURATION * RRM_SEC_TO_MILLI_SEC_CONV /*1000*/ ),
            &timer_buff, sizeof(rrm_ue_timer_buf_t),RRM_FALSE);
    /* CSR-58333-fix end*/
    if (g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_HO_TIMER] == RRM_PNULL)
    {
        RRM_TRACE(g_uem_log_on_off,
                p_g_rrm_uem_facility_name, RRM_ERROR,
                "Failed to start Cell block HO Timer");
        ret_val = RRM_FAILURE;
    }
    else
    {
        /* SPR 20652 Fix Start */
        rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
        while(p_ue_context != RRM_PNULL)
        {
            /*SPR 17490 START*/
            p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
            /* Soft Lock start - Global variable removal */
            /*CID 65845 Start*/
            if (RRM_PNULL != p_cell_ctxt)
            {
                p_cell_ctxt->administrative_procedure_ongoing = RRM_TRUE;
            }
            /*CID 65845 End*/
            /* Soft Lock end - Global variable removal */
            /*SPR 17490 END*/
            /* SPR 17488 Fix Start */
            if (RRM_UE_STATE_ACTIVE == p_ue_context->ue_state)
                /* SPR 17488 Fix End */
            {
                /* SPR 16406 8SEP start */
                p_ue_context->meas_rep_event = MEAS_REP_EVENT_A2;
                /* SPR 16406 8SEP end */
                /* SPR 15232 start */
                p_ue_context->ho_params.a2_event_received = RRM_TRUE;
                /* SPR 15232 end */

                RRM_MEMSET (&timer_buff,RRM_ZERO,sizeof(rrm_ue_timer_buf_t));
                timer_buff.timer_type = RRM_UE_BLIND_HO_TIMER;
                timer_buff.ue_index = p_ue_context->ue_index;
                /* Bug_12469_Fix: Start */
                timer_buff.cell_index = p_ue_context->cell_index;
                /* Bug_12469_Fix: End */
                p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
                /*CID 65845:start*/
                if (RRM_PNULL != p_cell_ctxt)
                {
                    /* Soft Lock start - Global variable removal */
                    p_cell_ctxt->administrative_procedure_ongoing = RRM_TRUE;
                    /* Soft Lock end - Global variable removal */

                    if(RRM_ZERO != p_cell_ctxt->ho_parameters.ho_blind_timer_duration) 
                    {
                        /* CSR-58333-fix start*/
                        p_ue_context->ho_params.blind_timer = rrm_ue_start_timer (
                                (p_cell_ctxt->ho_parameters.ho_blind_timer_duration * RRM_SEC_TO_MILLI_SEC_CONV /*1000*/),
                                &timer_buff,
                                sizeof(rrm_ue_timer_buf_t),
                                RRM_FALSE);
                        /* CSR-58333-fix end*/
                    }
                }
                /*CID 65845:end*/
                if(p_ue_context->ho_params.blind_timer == NULL)
                {
                    RRM_TRACE(g_uem_log_on_off,
                            p_g_rrm_uem_facility_name,
                            RRM_ERROR,
                            "Failed to start Blind  Timer for [UE:%u]",
                            p_ue_context->ue_index);
                }
                /*SPR 20123 Fix Start*/
                /*Sending meas config once for ES Cell switch Off*/
                if (RRM_FALSE == p_ue_context->ue_block_params.rrm_ue_meas_config_req_sent)
                {
                    /*SPR 20123 Fix End*/
                    ret_val = rrm_build_and_send_meas_config_req (p_ue_context, MEAS_TYPE_HO);
                    if(RRM_SUCCESS ==  ret_val)
                    {
                        p_ue_context->ue_block_params.
                            rrm_ue_meas_config_req_sent = RRM_TRUE;

                        RRM_TRACE(g_uem_log_on_off, 
                                p_g_rrm_uem_facility_name, RRM_DETAILED, 
                                "For Block Cell Req: Sent RRC_RRM_MEAS_CONFIG_REQ to RRC for UE Index : %d", p_ue_context->ue_index);

                        /*CA HARDENING CHANGES REPORT EVENT*/
                        /* Bug_12952_fix: Start */
                            /* SPR-20656 START */
                            /* code deleted */
                            /* SPR-20656 START */
                    }
                    /*SPR 16364 START*/
                    else
                    {
                        transaction_id = rrm_generate_txn_id();
                        if(RRM_SUCCESS == rrm_build_and_send_ho_required_for_daho(p_ue_context,transaction_id))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "HO required has been sent successfully for DAHO cell");
                        }
                        else
                        {
                            transaction_id = rrmuem_rmif_non_emrgncy_active_calls_ho_req->transaction_id;
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                    "HO required couldn't be sent for DAHO");
                            /*SPR 17488 Fix Start */
                            /* Measurement config request sent is failed and no DAHO cell is present
                             * then RRM shall send connection release indication directly to RRC and
                             * clean all the resources allocated at RRM for active UEs. Once Active
                             * UE count becomes RRM_ZERO RRM shall inform MIF that no active UEs
                             * present in RRM send the cell block resp and move the state to
                             * MIF_FSM_STATE_CELL_ALREADY_BLOCKED */
                            /* SPR-20656 START */
                            if (RRM_FALSE == rrm_is_ue_special_previledge(p_ue_context))
                                /* SPR-20656 END */
                            {
                                ret_val = rrm_build_and_send_ue_connection_release_ind(
                                        p_ue_context->ue_index,
                                        RRM_S1AP_CAUSE_MISC,
                                        CAUSE_MISC_OAM_INTERVENTION,
                                        transaction_id,
                                        RRM_PNULL,
                                        p_ue_context->cell_index);
                                if (ret_val == RRM_FAILURE)
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                            "Error in sending UE release indication");
                                }
                                else
                                {
                                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                                    {
                                        RRM_TRACE(g_uem_log_on_off,
                                                p_rrm_uem_facility_name,
                                                RRM_DETAILED,
                                                "ue_connection_release_ind sent, \
                                                Failed to clean up ue resources");
                                        ret_val = RRM_FAILURE;

                                    }

                                }
                                /*SPR 17488 Fix end */
                                /* SPR-20656 START */
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                        "Skipping UE[%u] for release as establishment cause is[%u]",
                                        p_ue_context->ue_index,
                                        p_ue_context->establishment_cause);
                            }
                            /* SPR-20656 END */
                        }
                        /*SPR 16364 END*/
                    }
                    /*SPR 20123 Fix Start*/
                }
                /*SPR 20123 Fix End*/
            }
            /*SPR 17488 Fix Start */
            else if(RRM_UE_WAIT_FOR_CAP_IND == p_ue_context->ue_state)
            {
                transaction_id = rrmuem_rmif_non_emrgncy_active_calls_ho_req->transaction_id;
                /* Measurement config request sent is failed and no DAHO cell is present
                 * then RRM shall send connection release indication directly to RRC and
                 * clean all the resources allocated at RRM for active UEs. Once Active
                 * UE count becomes RRM_ZERO RRM shall inform MIF that no active UEs
                 * present in RRM send the cell block resp and move the state to
                 * MIF_FSM_STATE_CELL_ALREADY_BLOCKED */
                /* SPR-20656 START */
                if (RRM_FALSE == rrm_is_ue_special_previledge(p_ue_context))
                    /* SPR-20656 END */
                {
                    ret_val = rrm_build_and_send_ue_connection_release_ind(
                            p_ue_context->ue_index,
                            RRM_S1AP_CAUSE_MISC,
                            CAUSE_MISC_OAM_INTERVENTION,
                            transaction_id,
                            RRM_PNULL,
                            p_ue_context->cell_index);
                    if (ret_val == RRM_FAILURE)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                                "Error in sending UE release indication");
                    }
                    else
                    {
                        if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                        {
                            RRM_TRACE(g_uem_log_on_off,
                                    p_rrm_uem_facility_name,
                                    RRM_DETAILED,
                                    "ue_connection_release_ind sent, \
                                    Failed to clean up ue resources");
                            ret_val = RRM_FAILURE;

                        }
                    }
                    /* SPR-20656 START */
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                            "Skipping UE[%u] for release as establishment cause is[%u]",
                            p_ue_context->ue_index,
                            p_ue_context->establishment_cause);
                }
                /* SPR-20656 END */
            }
            /*SPR 17488 Fix End */

            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Unspecified Cell Index!!");
                ret_val = RRM_FAILURE;
            }
            /* SPR_18611 Fix Start */    
            ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
            /* SPR 20652 Fix End */
            /* SPR_18611 Fix End */
        }
    }
    /*SPR 16364 START*/
    /*code deleted*/
    /*SPR 16364 END*/
    /*SPR 16364 START*/
    RRM_UT_TRACE_EXIT();
    /*SPR 16364 END*/

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_send_rmif_non_emrgncy_active_calls_ho_resp
 *   DESCRIPTION:
 *       Send the non-emergency active calls HO response to MIF
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
    rrm_return_et
rrm_uem_send_rmif_non_emrgncy_active_calls_ho_resp(
        U16 trans_id,
        rrm_cell_index_t cell_index,
        rrm_bool_et response
        )
{
    rrm_return_et ret_val = RRM_FAILURE;
    U16           api_id = RRM_ZERO;
    U16           msg_size = RRM_ZERO;
    U8            *p_msg = RRM_PNULL;
    /* SPR 18943 Fix Start */
    RRM_UT_TRACE_ENTER();
    /* SPR 18943 Fix Stop */

    /* SPR 17446 START */
    rrm_cell_context_t    *p_cell_ctxt  = RRM_PNULL;
    /* SPR 17446 END */
    rrmuem_rmif_non_emrgncy_active_calls_ho_resp_t    *p_rrmuem_rmif_non_emrgncy_active_calls_ho_resp;

    p_rrmuem_rmif_non_emrgncy_active_calls_ho_resp = rrm_mem_get(sizeof(rrmuem_rmif_non_emrgncy_active_calls_ho_resp_t));
    if( RRM_PNULL == p_rrmuem_rmif_non_emrgncy_active_calls_ho_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
        return RRM_FAILURE;
    }

    p_rrmuem_rmif_non_emrgncy_active_calls_ho_resp->transaction_id = trans_id;
    p_rrmuem_rmif_non_emrgncy_active_calls_ho_resp->cell_index = cell_index;
    p_rrmuem_rmif_non_emrgncy_active_calls_ho_resp->response = response;
    /* SPR 17446 START */
    if (response == RRM_FALSE)
    {
        p_cell_ctxt = rrm_cellm_get_cell_context(cell_index);
        /*CID 97156 Start*/
        if(p_cell_ctxt!=RRM_PNULL)
        {
            p_cell_ctxt->stop_adm_flag = RRM_FALSE;
        }
        /*CID 97156 End*/

    }
    /* SPR 17446 END */

    msg_size = sizeof(rrmuem_rmif_non_emrgncy_active_calls_ho_resp_t);
    p_msg = (void *)p_rrmuem_rmif_non_emrgncy_active_calls_ho_resp;
    api_id = RRMUEM_RMIF_NON_EMRGNCY_ACTIVE_CALLS_HO_RESP;

    ret_val = rrm_uem_send_internal_msg (RRM_MIF_MODULE_ID, api_id, msg_size, p_msg);
    if( RRM_FAILURE == ret_val )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"RRM send to MIF failed %d\n",api_id);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Sent to MIF %d", api_id);
    }
    RRM_MEM_FREE(p_rrmuem_rmif_non_emrgncy_active_calls_ho_resp);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/*LTE_RRM_TM_SWITCH_START*/
/******************************************************************************
 *   FUNCTION NAME: rrm_process_ue_l2_report
 *   DESCRIPTION:
 *       Process the UE data 
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_process_ue_l2_report(rrm_ue_events_et   current_event,
        /* eICIC_PHASE_1_2_CHANGES_START */
        rrm_ue_global_context_t *p_ue_glbl_ctxt,
        /* eICIC_PHASE_1_2_CHANGES_END */
        rrm_void_t         *p_ue_data_report)
{
    rrm_return_et	ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if( RRM_PNULL == p_ue_data_report )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "NULL pointer for [UE:%d] Mac reported Data", p_ue_glbl_ctxt->p_ue_context->ue_index);
        ret_val = RRM_FAILURE;
    }
    else
    {	
        if( RRM_MAC_PERIODIC_REPORTS_IND_EVENT  == current_event )
        {
            ret_val = rrm_process_ue_mac_periodic_stats(
                    /* eICIC_PHASE_1_2_CHANGES_START */
                    p_ue_glbl_ctxt,
                    /* eICIC_PHASE_1_2_CHANGES_END */
                    /* + SPR 20078 */
                    (PeriodicReportInfo *)p_ue_data_report);
            /* - SPR 20078 */
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_is_scell_valid_for_ue
 *   INPUT      : p_rrm_ue_context, scell_index, scell_arr_idx
 *   OUTPUT     : none
 *   DESCRIPTION: Checks if the UE is using the given scell's cell index & gives 
 *                the array index on which the given scell is stored.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
 *******************************************************************************/
/* Note: This function is used for RRM-RRC interface as on this interface Cell Index of Scells 
   is used to communicate Scell's info. */ 
    rrm_return_et
rrm_is_scell_valid_for_ue(rrm_ue_context_t   *p_rrm_ue_context,
        rrm_cell_index_t    scell_index,
        U8                 *p_scell_arr_idx)
{
    U8 scell_count = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_context != RRM_PNULL)
    {
        if(p_rrm_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL )
        {
            for(scell_count = RRM_ZERO; scell_count < p_rrm_ue_context->ue_scell_add_params.count; scell_count++)
            {
                if(scell_index == p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_count].scell_cell_index)
                {
                    *p_scell_arr_idx = scell_count;
                    ret_val = RRM_SUCCESS;
                    break; 
                }
            }
        }        
    }
    else /* else of RRM_PNULL != p_ue_context */
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "NULL POINTER EXCEPTION for ue context!!");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_is_scell_index_valid_for_ue
 *   INPUT      : p_rrm_ue_context, scell_index, scell_arr_idx
 *   OUTPUT     : none
 *   DESCRIPTION: Checks if the UE is using the given scell index & gives the
 *                array index on which the given scell is stored.
 *   RETURNS    :
 *               RRM_SUCCESS on Success
 *               RRM_FAILURE on Failure
 *******************************************************************************/
/* Note: This function is used for RRM-MAC interface as MAC reports are received in terms of 
   Scell's Index */
    rrm_return_et
rrm_is_scell_index_valid_for_ue(rrm_ue_context_t   *p_rrm_ue_context,
        U8                  scell_idx_on_ue,
        U8                 *p_scell_arr_idx)
{
    U8 scell_count = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_context != RRM_PNULL)
    {
        if(p_rrm_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL )
        {
            for(scell_count = RRM_ZERO; scell_count < p_rrm_ue_context->ue_scell_add_params.count; scell_count++)
            {
                if(scell_idx_on_ue == p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_count].scell_index)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Scell Index [%d] found at Index [%d]", scell_idx_on_ue, *p_scell_arr_idx);
                    *p_scell_arr_idx = scell_count;
                    ret_val = RRM_SUCCESS;
                    break; 
                }
            }
        }        
    }
    else /* else of RRM_PNULL != p_ue_context */
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "NULL POINTER EXCEPTION for ue context!!");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_process_ue_mac_periodic_stats
 *   DESCRIPTION:
 *       Process the all active ue release  ind from mif
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_process_ue_mac_periodic_stats(
        /* eICIC_PHASE_1_2_CHANGES_START */
        rrm_ue_global_context_t *p_ue_glbl_ctxt,
        /* eICIC_PHASE_1_2_CHANGES_END */
        /* + SPR 20078 */
        PeriodicReportInfo      *p_ue_mac_stas)
/* - SPR 20078 */
{

    rrm_return_et      ret_val = RRM_SUCCESS;
    U16                report_index = RRM_ZERO;
    /* eICIC_PHASE_1_2_CHANGES_START */
    rrm_ue_context_t    *p_ue_context = p_ue_glbl_ctxt->p_ue_context;
    /* eICIC_PHASE_1_2_CHANGES_END */
    U8                 count = RRM_ZERO;
    U8                 scell_arr_idx = RRM_ZERO;
#ifdef ENDC_ENABLED
    rrm_cell_context_t    *p_cell_ctxt  = RRM_PNULL;
    U8                     min_rep_count = RRM_ZERO;
    U8                     drb_index     = RRM_ZERO;
    endc_eligible_erab_list_t erb_change_list[RRM_MAX_NUM_DRB_PER_UE] ;
    U8                      erb_change_list_count = RRM_ZERO;
    rrm_ue_channel_quality_reports_t 
                *p_ue_chnnel_quality_temp_reports = RRM_PNULL;
    rrm_ue_channel_quality_reports_t 
                *p_ue_chnnel_quality_final_reports = RRM_PNULL;
#endif
    RRM_UT_TRACE_ENTER();

    if( RRM_PNULL == p_ue_mac_stas )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "NULL pointer for [UE:%d] Mac reported Data", p_ue_context->ue_index);
        ret_val = RRM_FAILURE;
    }
    else
    {
        report_index = p_ue_context->p_ue_mac_report->report_index;

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "Total Reports reported from L2 [%d]",report_index + RRM_ONE);

        report_index = (report_index % RRM_MAX_REPORT_STAT_UE);

        p_ue_context->p_ue_mac_report->ue_stats[report_index] = *p_ue_mac_stas;

        /* BUG-7937 START */ 
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "UE MAC report Stored on Index [%d] by RRM for [UE:%d]",
                /* + SPR 20078 */
                report_index,p_ue_context->p_ue_mac_report->ue_stats[report_index].ueIndex );
        /* - SPR 20078 */

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "Uplink Sinr Value[%d]",
                p_ue_context->p_ue_mac_report->ue_stats[report_index].uplinkSINRValue);
        /* BUG-7937 END */
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "Downlink SINRCW0[%d], Downlink SINRCW1[%d] ",
                p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW0,
                p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW1);

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "Uplink Bler Value[%d] Downlink BlerCW0[%d], Downlink BlerCW1[%d] ",
                p_ue_context->p_ue_mac_report->ue_stats[report_index].uplinkBlerValue,
                p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkBlerValueCW0,
                p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkBlerValueCW1);

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "Uplink Pathloss Value[%d], TimingAdvanceValue[%d] ",
                /* + SPR 20078 */
                p_ue_context->p_ue_mac_report->ue_stats[report_index].uplinkPathLossValue,
                /* - SPR 20078 */
                p_ue_context->p_ue_mac_report->ue_stats[report_index].timingAdvanceValue);

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "Pucch SINR Value[%d], PucchBler Value[%d] ",
                p_ue_context->p_ue_mac_report->ue_stats[report_index].pucchSINRValue,
                p_ue_context->p_ue_mac_report->ue_stats[report_index].pucchBlerValue);

        /*Start changes for TTI bundling feature*/

        /* SPR 18641_18843 fix start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, \
                "RB used by UE [%d]",
                /* + SPR 20078 */
                p_ue_context->p_ue_mac_report->ue_stats[report_index].uplinkPRB);
        /* - SPR 20078 */
        /* SPR 18641_18843 fix end */

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "downlinkSINRValueCW0Layers2 [%d], downlinkSINRValueCW1Layers2 [%d] ",
                p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW0Layers2 ,
                p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW1Layers2);

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "downlinkBlerValueCW0Layers2 [%d], downlinkBlerValueCW1Layers2 [%d] ",
                p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkBlerValueCW0Layers2,
                p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkBlerValueCW1Layers2);
        /*End changes for TTI bundling feature*/

        /* eICIC_PHASE_1_2_CHANGES_START */
        /* + SPR 20078 */
        if((p_ue_context->p_ue_mac_report->ue_stats[report_index].bitMask &
                    /* - SPR 20078 */
                    RRM_MAC_UE_PERIODIC_CSI_SUBFRAME_SET2_REPORT_PRESENCE_BITMASK ))
        {
            /* Print the values for logs */
            /* + SPR 20078 */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                    "csiSubframe_set2 downlinkSINRValueCW0_2 [%d], downlinkSINRValueCW0Layers2_2 [%d]",
                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                    csiSubframeSet2Report.downlinkSINRValueCW0_2,
                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                    csiSubframeSet2Report.downlinkSINRValueCW0Layers2_2);

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                    "csiSubframe_set2 downlinkSINRValueCW1_2 [%d], downlinkSINRValueCW1Layers2_2 [%d]",
                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                    csiSubframeSet2Report.downlinkSINRValueCW1_2,
                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                    csiSubframeSet2Report.downlinkSINRValueCW1Layers2_2);

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                    "csiSubframe_set2 downlinkBlerValueCW0_2 [%d], downlinkBlerValueCW0Layers2_2 [%d]",
                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                    csiSubframeSet2Report.downlinkBlerValueCW0_2,
                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                    csiSubframeSet2Report.downlinkBlerValueCW0Layers2_2);

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                    "csiSubframe_set2 downlinkBlerValueCW1_2 [%d] downlinkBlerValueCW1Layers2_2 [%d]",
                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                    csiSubframeSet2Report.downlinkBlerValueCW1_2,
                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                    csiSubframeSet2Report.downlinkBlerValueCW1Layers2_2);
            /* - SPR 20078 */

        }
        /* eICIC_PHASE_1_2_CHANGES_END */
        /* Scell UE Report present */
        /* UT-fix */
        /* + SPR 20078 */
        if((p_ue_context->p_ue_mac_report->ue_stats[report_index].bitMask &
                    RRM_MAC_UE_PERIODIC_SCELL_REPORT_PRESENCE_BITMASK )&& 
                ((p_ue_context->ue_scell_add_params.count > RRM_ZERO) &&
                 (p_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL)))
            /* - SPR 20078 */
        {
            /* + SPR 20078 */
            /* Check scellReportBitMask for Cell Index used as Scell on current Cell for which Report is received */
            /* Bit 1-7 represent the Scell Index */
            for(count=RRM_ONE; count<RRM_MAX_SCELL; count++)
            {
                if((p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReportBitMask & (RRM_ONE<<count)))
                    /* - SPR 20078 */
                {
                    /* Print the values for logs */
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
                            "Scell downlinkSINRValueCW0 [%d], Scell downlinkSINRValueCW0Layers1 [%d] ",
                            p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkSINRValueCW0,
                            p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkSINRValueCW0Layers2);
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
                            "Scell downlinkSINRValueCW1 [%d], Scell downlinkSINRValueCW1Layers2 [%d] ",
                            p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkSINRValueCW1,
                            p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkSINRValueCW1Layers2);
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
                            "Scell downlinkBlerValueCW0 [%d], Scell downlinkBlerValueCW0Layers2 [%d] ",
                            p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkBlerValueCW0,
                            p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkBlerValueCW0Layers2);
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED, \
                            "Scell downlinkBlerValueCW1 [%d], Scell downlinkBlerValueCW1Layers2 [%d] ",
                            p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkBlerValueCW1,
                            p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkBlerValueCW1Layers2);

                    /* Scell Index maps to the Scell Index given to the Cell Index at time of Scell addition.
                       Currently only 1 scell added, so valid scell index is only 1. Hence bit 2 of the scellReportBitMask
                       should be High. */
                    if((rrm_is_scell_index_valid_for_ue(p_ue_context, count, &scell_arr_idx) == RRM_SUCCESS))
                    {
                        if(p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_arr_idx].
                                scell_periodic_stats.scell_report_count < RRM_MAX_REPORT_STAT_UE)
                        {
                            /* Update Scell Report count for that Scell in UE context->ue_scell_add_params */
                            (p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_arr_idx].scell_periodic_stats.scell_report_count)++;
                        }
                        else
                        {
                            p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_arr_idx].scell_periodic_stats.scell_report_count = RRM_ZERO;
                            /* + SPR 20078 */
                            p_ue_context->p_ue_mac_report->ue_stats[report_index].bitMask = RRM_ZERO ;
                            /* - SPR 20078 */
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, \
                                    "Scell count 0 for the [UE:%d]", p_ue_context->ue_index);
                        }
                    }
                    else
                    {
                        /* + SPR 20078 */
                        p_ue_context->p_ue_mac_report->ue_stats[report_index].bitMask = RRM_ZERO ;
                        /* - SPR 20078 */
                    }
                }
            }
        }


        (  p_ue_context->p_ue_mac_report->report_index)++;

        if( p_ue_context->p_ue_mac_report->report_count < RRM_MAX_REPORT_STAT_UE )

        {
            (p_ue_context->p_ue_mac_report->report_count)++;
        }

        /* when report_index(U16) reaches on its maximum value that it can have.
           furthur increment on this wrap around and value beome "ZERO". and new mac 
           report for UE goes into wrong index and it also affects when calculating
           average for mac data, as this report index is used to divide the sum of reports.
           and divide by zero exception is raised.
Solution : we keep { (last report index) + 1 (next index) + maximum report }
to fix all these hurdles .
*/
        if(RRM_ZERO == (p_ue_context->p_ue_mac_report->report_index))
        {
            p_ue_context->p_ue_mac_report->report_index =
                (p_ue_context->p_ue_mac_report->report_index) + RRM_MAX_REPORT_STAT_UE +
                report_index + RRM_ONE;   
        }

        /* Uplink power control starts */
        /* eICIC_PHASE_1_2_CHANGES_START */
        rrm_calulate_average_mac_stats( p_ue_glbl_ctxt);
        /* eICIC_PHASE_1_2_CHANGES_END */
        /* Uplink power control end */


/* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED
            RRM_MEMSET(erb_change_list,RRM_NULL,sizeof(endc_eligible_erab_list_t)*RRM_MAX_NUM_DRB_PER_UE);
            p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
            if (RRM_PNULL == p_cell_ctxt)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                        "Cell Context not found");
            }
            else
            {
                min_rep_count = p_cell_ctxt->operator_info.endc_info.min_num_ue_thp_report;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                        "Min number of reports to trigger ENDC thruput algo :- [%d]\n",
                        min_rep_count);

                p_ue_chnnel_quality_temp_reports = 
                            &(p_ue_context->rrm_endc_nr_data.rrm_ue_temp_reports.\
                                   rrm_ue_channel_quality_reports);
                p_ue_chnnel_quality_final_reports = 
                            &(p_ue_context->rrm_endc_nr_data.rrm_ue_final_reports.\
                                   rrm_ue_channel_quality_reports);


                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "Report No [%d] recieved from MAC,Check to trigger ENDC thruput algo \n",
                            p_ue_context->rrm_endc_nr_data.report_sample_count +  RRM_ONE );
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "Update the MAC stats in UE context for ENDC \n");
                    p_ue_context->rrm_endc_nr_data.reports_resfreshed = 0;
                    p_ue_chnnel_quality_temp_reports->sinr_ul = 
                        p_ue_chnnel_quality_temp_reports->sinr_ul + p_ue_mac_stas->uplinkSINRValue;
                    p_ue_chnnel_quality_temp_reports->bler_ul = 
                        p_ue_chnnel_quality_temp_reports->bler_ul + p_ue_mac_stas->uplinkBlerValue;
                    p_ue_chnnel_quality_temp_reports->sinr_dl_cw0 = 
                        p_ue_chnnel_quality_temp_reports->sinr_dl_cw0 + p_ue_mac_stas->downlinkSINRValueCW0;
                    p_ue_chnnel_quality_temp_reports->sinr_dl_cw1 = 
                        p_ue_chnnel_quality_temp_reports->sinr_dl_cw1 + p_ue_mac_stas->downlinkSINRValueCW1;
                    p_ue_chnnel_quality_temp_reports->bler_dl_cw0 = 
                        p_ue_chnnel_quality_temp_reports->bler_dl_cw0 + p_ue_mac_stas->downlinkBlerValueCW0;
                    p_ue_chnnel_quality_temp_reports->bler_dl_cw1 = 
                        p_ue_chnnel_quality_temp_reports->bler_dl_cw1 + p_ue_mac_stas->downlinkBlerValueCW1;

                    p_ue_context->rrm_endc_nr_data.report_sample_count++;

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "Updated MAC stats:- sinr_ul[%d] sinr_dl_cw0[%d] sinr_dl_cw1[%d] "
                            "bler_ul[%d] bler_dl_cw0[%d] bler_dl_cw1[%d] \n",
                            p_ue_chnnel_quality_temp_reports->sinr_ul,
                            p_ue_chnnel_quality_temp_reports->sinr_dl_cw0,
                            p_ue_chnnel_quality_temp_reports->sinr_dl_cw1,
                            p_ue_chnnel_quality_temp_reports->bler_ul,
                            p_ue_chnnel_quality_temp_reports->bler_dl_cw0,
                            p_ue_chnnel_quality_temp_reports->bler_dl_cw1);
                if( p_ue_context->rrm_endc_nr_data.report_sample_count == min_rep_count)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "Average the stats and Update in UE context for ENDC \n");
                    /* Average the stats */
                    p_ue_chnnel_quality_final_reports->sinr_ul = 
                       (p_ue_chnnel_quality_temp_reports->sinr_ul / 
                            p_ue_context->rrm_endc_nr_data.report_sample_count);

                    p_ue_chnnel_quality_final_reports->sinr_dl_cw0 = 
                       (p_ue_chnnel_quality_temp_reports->sinr_dl_cw0 / 
                            p_ue_context->rrm_endc_nr_data.report_sample_count);

                    p_ue_chnnel_quality_final_reports->sinr_dl_cw1 = 
                       (p_ue_chnnel_quality_temp_reports->sinr_dl_cw1 / 
                            p_ue_context->rrm_endc_nr_data.report_sample_count);


                    p_ue_chnnel_quality_final_reports->bler_ul = 
                       (p_ue_chnnel_quality_temp_reports->bler_ul / 
                            p_ue_context->rrm_endc_nr_data.report_sample_count);

                    p_ue_chnnel_quality_final_reports->bler_dl_cw0 = 
                       (p_ue_chnnel_quality_temp_reports->bler_dl_cw0 / 
                            p_ue_context->rrm_endc_nr_data.report_sample_count);

                    p_ue_chnnel_quality_final_reports->bler_dl_cw1 = 
                       (p_ue_chnnel_quality_temp_reports->bler_dl_cw1 / 
                            p_ue_context->rrm_endc_nr_data.report_sample_count);

                    RRM_MEMSET(p_ue_chnnel_quality_temp_reports, RRM_ZERO,
                                sizeof(rrm_ue_channel_quality_reports_t));

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "ENDC: Avergaed MAC stats:- sinr_ul[%d] sinr_dl_cw0[%d] sinr_dl_cw1[%d] "
                            "bler_ul[%d] bler_dl_cw0[%d] bler_dl_cw1[%d] \n",
                            p_ue_chnnel_quality_final_reports->sinr_ul,
                            p_ue_chnnel_quality_final_reports->sinr_dl_cw0,
                            p_ue_chnnel_quality_final_reports->sinr_dl_cw1,
                            p_ue_chnnel_quality_final_reports->bler_ul,
                            p_ue_chnnel_quality_final_reports->bler_dl_cw0,
                            p_ue_chnnel_quality_final_reports->bler_dl_cw1);

                    p_ue_context->rrm_endc_nr_data.report_sample_count = 0;
                    p_ue_context->rrm_endc_nr_data.reports_resfreshed = 1;

                    /* Check for database assisted or meas assisted sgnb addition */
/* NR_BAND_FIX_START */
                    if( RRM_TRUE ==
                            rrm_check_trigger_to_configure_nr_database(p_ue_context,\
                                TRIGGER_TYPE_CHANNEL_QUALITY,0xFF))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                                "Trigger DB assisited SGNB addition on the basis of UE's channel quality\n");
                        /* if here , trigger dc bearer change req */
                        rrm_build_list_of_selected_erabs(p_ue_context,erb_change_list,&erb_change_list_count);
                        /* NR_REP_CONFIG_FIX_START */
                        if ( (erb_change_list_count > RRM_ZERO ) && 
(RRM_SUCCESS == rrm_check_is_configured_peer_gnb_pci_valid(p_ue_context->cell_index)))
                            /* NR_REP_CONFIG_FIX_END */
                        {
                            if(RRM_FAILURE ==
                                    rrm_build_and_send_dc_bearer_change_req(p_ue_context,\
                                        erb_change_list,erb_change_list_count,\
                                        RRM_NULL,RRM_NULL))
                            {
                                for(drb_index=0;drb_index<erb_change_list_count;drb_index++)
                                {
                                    p_ue_context->drb_configured.\
                                        erab_item[erb_change_list[drb_index].drb_index].\
                                        new_lc_id = RRM_ZERO;
                                    p_ue_context->drb_configured.\
                                        erab_item[erb_change_list[drb_index].drb_index].\
                                        new_drb_id = RRM_ZERO;
                                }
                            }
                        }
                    }
                    else if( RRM_TRUE == 
/* NR_BAND_FIX_END */
                        rrm_check_trigger_to_configure_nr_meas(p_ue_context,TRIGGER_TYPE_CHANNEL_QUALITY))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                                "Trigger Measurements for SGNB addition on the basis of UE's channel quality\n");
                        rrm_build_and_send_meas_config_req_for_endc(p_ue_context,MEAS_REP_EVENT_B1_NR);
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                                "No need to trigger sgnb addition or measurements ");
                    }
                }
            }
#endif
/* ENDC_MEAS_CHANGES_END */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_uem_caclulate_avg_sinr_for_eicic_CsisubFrameSet2 
 *   DESCRIPTION:
 *       Calculate average mac stats in rrm
 *   RETURNS:
 *           SUCCESS
 *           FAILURE
 ******************************************************************************/
    rrm_return_et
rrm_uem_caclulate_avg_sinr_for_eicic_CsisubFrameSet2( rrm_ue_context_t *p_ue_context,
        U16               report_index,
        U8                valid_csi_subframe_set2_dl_sinr_cw1,
        U8                valid_csi_subframe_set2_dl_sinr_cw0_layer2,
        U8                valid_csi_subframe_set2_dl_sinr_cw1_layer2,
        U32               total_downlinkSINRValueCW0_subframeSet2,
        U32               total_downlinkSINRValueCW1_subframeSet2,
        U32               total_downlinkSINRValueCW0Layers2_subframeSet2,
        U32               total_downlinkSINRValueCW1Layers2_subframeSet2)
{
    rrm_return_et ret_val = RRM_SUCCESS; 

    RRM_UT_TRACE_ENTER();

    /* + SPR 20078 */
    if(p_ue_context->ue_avg_stats.bitMask &
            RRM_MAC_UE_PERIODIC_CSI_SUBFRAME_SET2_REPORT_PRESENCE_BITMASK)
    {
        p_ue_context->ue_avg_stats.csiSubframeSet2Report.downlinkSINRValueCW0_2 =
            (total_downlinkSINRValueCW0_subframeSet2/ report_index);

        if (valid_csi_subframe_set2_dl_sinr_cw1)
        {
            p_ue_context->ue_avg_stats.csiSubframeSet2Report.downlinkSINRValueCW1_2 =
                (total_downlinkSINRValueCW1_subframeSet2 / report_index);
        }

        if (valid_csi_subframe_set2_dl_sinr_cw0_layer2)
        {
            p_ue_context->ue_avg_stats.csiSubframeSet2Report.downlinkSINRValueCW0Layers2_2 =
                (total_downlinkSINRValueCW0Layers2_subframeSet2/ valid_csi_subframe_set2_dl_sinr_cw0_layer2);
        }

        if (valid_csi_subframe_set2_dl_sinr_cw1_layer2)
        {
            p_ue_context->ue_avg_stats.csiSubframeSet2Report.downlinkSINRValueCW1Layers2_2 =
                (total_downlinkSINRValueCW1Layers2_subframeSet2 / valid_csi_subframe_set2_dl_sinr_cw1_layer2);
        }
        /* - SPR 20078 */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_caclulate_avg_sinr_for_scell
 *   DESCRIPTION:
 *       Calculate average mac stats in rrm
 *   RETURNS:
 *           SUCCESS
 *           FAILURE
 ******************************************************************************/
    rrm_return_et
rrm_caclulate_avg_sinr_for_scell( rrm_ue_context_t *p_ue_context,
        U16               report_index,
        U8                valid_scell_dl_sinr_cw1,
        U8                valid_scell_dl_sinr_cw0_layer2,
        U8                valid_scell_dl_sinr_cw1_layer2,
        U32               scell_total_downlinkSINRValueCW0,
        U32               scell_total_downlinkSINRValueCW1,
        U32               scell_total_downlinkSINRValueCW0Layers2,
        U32               scell_total_downlinkSINRValueCW1Layers2 )
{
    rrm_return_et ret_val = RRM_SUCCESS; 
    U8 count = RRM_ZERO;
    U8 scell_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    /* UT-Fix */
    /* + SPR 20078 */
    if(p_ue_context->ue_avg_stats.bitMask &
            RRM_MAC_UE_PERIODIC_SCELL_REPORT_PRESENCE_BITMASK)
    {
        /* Check scellReportBitMask for Cell Index used as Scell on current Cell for which Report is received */
        /* Bit 1-7 represent the Scell Index */
        for(count=RRM_ONE; count<RRM_MAX_SCELL; count++)
        {
            if((p_ue_context->ue_avg_stats.scellReportBitMask & (RRM_ONE<<count)) &&
                    /* - SPR 20078 */
                    ((p_ue_context->ue_scell_add_params.count > RRM_ZERO) &&
                     (p_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL)))
            {
                for(scell_count = RRM_ZERO; scell_count < p_ue_context->ue_scell_add_params.count; scell_count++)
                {
                    if(p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_count].scell_index == count)
                    {
                        p_ue_context->ue_avg_stats.scellReport[count].downlinkSINRValueCW0 =
                            (scell_total_downlinkSINRValueCW0 / report_index);

                        if (valid_scell_dl_sinr_cw1)
                        {
                            p_ue_context->ue_avg_stats.scellReport[count].downlinkSINRValueCW1 =
                                (scell_total_downlinkSINRValueCW1 / report_index);
                        }

                        if (valid_scell_dl_sinr_cw0_layer2)
                        {
                            p_ue_context->ue_avg_stats.scellReport[count].downlinkSINRValueCW0Layers2 =
                                (scell_total_downlinkSINRValueCW0Layers2 / valid_scell_dl_sinr_cw0_layer2);
                        }

                        if (valid_scell_dl_sinr_cw1_layer2)
                        {
                            p_ue_context->ue_avg_stats.scellReport[count].downlinkSINRValueCW1Layers2 =
                                (scell_total_downlinkSINRValueCW1Layers2 / valid_scell_dl_sinr_cw1_layer2);
                        }
                    }
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_calulate_average_mac_stats
 *   DESCRIPTION:
 *       Calculate average mac stats in rrm 
 *   RETURNS:
 *       void
 *       
 ******************************************************************************/
/* Uplink power control starts */
rrm_void_t
rrm_calulate_average_mac_stats(
        /* eICIC_PHASE_1_2_CHANGES_START */
        rrm_ue_global_context_t *p_ue_glbl_ctxt
        /* eICIC_PHASE_1_2_CHANGES_END */
        )
{
    U16    report_index = RRM_ZERO;
    U8     valid_dl_sinr_cw1 = RRM_ZERO;
    U8     valid_dl_sinr_cw0_layer2 = RRM_ZERO;
    U8     valid_dl_sinr_cw1_layer2 = RRM_ZERO;
    U8     valid_dl_bler_cw0_layer2 = RRM_ZERO;
    U8     valid_dl_bler_cw1_layer2 = RRM_ZERO;

    U32    total_uplinkSINRValue = RRM_ZERO;       
    U32    total_uplinkBlerValue = RRM_ZERO;       
    U32    total_uplinkPathlossValue = RRM_ZERO;
    U32    total_downlinkSINRCW0 = RRM_ZERO;
    U32    total_downlinkSINRCW1 = RRM_ZERO;
    U32    total_dlSINRValueCW0Layers2 = RRM_ZERO;
    U32    total_dlSINRValueCW1Layers2 = RRM_ZERO;
    U32    total_dlBlerValueCW0Layers2 = RRM_ZERO;
    U32    total_dlBlerValueCW1Layers2 = RRM_ZERO;
    /*ECN load start*/
    U32    total_downlinkSINRValue = RRM_ZERO;
    /*ECN load end*/
    /*  DYNAMIC ICIC CHANGES START  */
    U32    total_pucch_SINR_Value = RRM_ZERO;
    U32    total_pucch_Bler_Value = RRM_ZERO;
    /*  DYNAMIC ICIC CHANGES END  */
    /*Start changes for TTI bundling feature*/
    /* SPR 18641_18843 fix start */
    U32    latest_rb_used_by_ue = RRM_ZERO;
    /* SPR 18641_18843 fix end */
    /*End changes for TTI bundling feature*/
    /* CA_Stage_3_Scell_TM_change: Start */
    U8     count = RRM_ZERO;
    U8     scell_count = RRM_ZERO;
    U8     valid_scell_dl_sinr_cw1 = RRM_ZERO;
    U8     valid_scell_dl_sinr_cw0_layer2 = RRM_ZERO;
    U8     valid_scell_dl_sinr_cw1_layer2 = RRM_ZERO;
    U32    scell_total_downlinkSINRValueCW0 = RRM_ZERO;
    U32    scell_total_downlinkSINRValueCW1 = RRM_ZERO;
    U32    scell_total_downlinkSINRValueCW0Layers2 = RRM_ZERO;
    U32    scell_total_downlinkSINRValueCW1Layers2 = RRM_ZERO;
    /* eICIC_PHASE_1_2_CHANGES_START */
    U8     valid_csi_subframe_set2_dl_sinr_cw1 = RRM_ZERO;
    U8     valid_csi_subframe_set2_dl_sinr_cw0_layer2 = RRM_ZERO;
    U8     valid_csi_subframe_set2_dl_sinr_cw1_layer2 = RRM_ZERO;
    U32    total_downlinkSINRValueCW0_subframeSet2 = RRM_ZERO;
    U32    total_downlinkSINRValueCW1_subframeSet2 = RRM_ZERO;
    U32    total_downlinkSINRValueCW0Layers2_subframeSet2 = RRM_ZERO;
    U32    total_downlinkSINRValueCW1Layers2_subframeSet2 = RRM_ZERO;
    rrm_cell_context_t    *p_cell_ctxt  = RRM_PNULL;
    rrm_ue_context_t *p_ue_context = p_ue_glbl_ctxt->p_ue_context; 
    /* eICIC_PHASE_1_2_CHANGES_END */

    /* CA_Stage_3_Scell_TM_change: End */

    RRM_UT_TRACE_ENTER();

    for( ;((report_index < p_ue_context->p_ue_mac_report->report_index)
                && (report_index < (RRM_MAX_REPORT_STAT_UE))) ; report_index++ )
    {
        total_uplinkSINRValue = total_uplinkSINRValue + p_ue_context->p_ue_mac_report->ue_stats[report_index]
            .uplinkSINRValue;
        total_uplinkBlerValue = total_uplinkBlerValue + p_ue_context->p_ue_mac_report->ue_stats[report_index]
            .uplinkBlerValue;
        /* + SPR 20078 */
        total_uplinkPathlossValue = total_uplinkPathlossValue + p_ue_context->p_ue_mac_report->ue_stats[report_index]
            .uplinkPathLossValue;
        /* - SPR 20078 */
        total_downlinkSINRCW0 = total_downlinkSINRCW0 + p_ue_context->p_ue_mac_report->ue_stats[report_index]
            .downlinkSINRValueCW0;
        if( p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW1 )
        {
            total_downlinkSINRCW1 = (total_downlinkSINRCW1 + p_ue_context->p_ue_mac_report->ue_stats[report_index]
                    .downlinkSINRValueCW1);
            valid_dl_sinr_cw1++;
        }
        /*ECN load start*/
        total_downlinkSINRValue = total_downlinkSINRValue +
            p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW0 +
            p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW1;
        /*ECN load end*/
        /*  DYNAMIC ICIC CHANGES START  */
        total_pucch_SINR_Value += p_ue_context->p_ue_mac_report->ue_stats[report_index].pucchSINRValue;
        total_pucch_Bler_Value += p_ue_context->p_ue_mac_report->ue_stats[report_index].pucchBlerValue;
        /*  DYNAMIC ICIC CHANGES END  */
        /*Start changes for TTI bundling feature*/
        /* SPR 18641_18843 fix start */
        /* + SPR 20078 */
        latest_rb_used_by_ue += p_ue_context->p_ue_mac_report->ue_stats[report_index].uplinkPRB;
        /* - SPR 20078 */
        /* SPR 18641_18843 fix end */
        /*End changes for TTI bundling feature*/

        if( p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW0Layers2 )
        {
            total_dlSINRValueCW0Layers2 = total_dlSINRValueCW0Layers2 +
                p_ue_context->p_ue_mac_report->ue_stats[report_index]. \
                downlinkSINRValueCW0Layers2;
            valid_dl_sinr_cw0_layer2++;
        }
        if( p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkSINRValueCW1Layers2 )
        {
            total_dlSINRValueCW1Layers2 = total_dlSINRValueCW1Layers2 + 
                p_ue_context->p_ue_mac_report->ue_stats[report_index]. \
                downlinkSINRValueCW1Layers2;
            valid_dl_sinr_cw1_layer2++;
        }
        if( p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkBlerValueCW0Layers2 )
        {
            total_dlBlerValueCW0Layers2 = total_dlBlerValueCW0Layers2 +
                p_ue_context->p_ue_mac_report->ue_stats[report_index]. \
                downlinkBlerValueCW0Layers2;
            valid_dl_bler_cw0_layer2++;
        }
        if( p_ue_context->p_ue_mac_report->ue_stats[report_index].downlinkBlerValueCW1Layers2 )
        {
            total_dlBlerValueCW1Layers2 = total_dlBlerValueCW1Layers2 +
                p_ue_context->p_ue_mac_report->ue_stats[report_index]. \
                downlinkBlerValueCW1Layers2;
            valid_dl_bler_cw1_layer2++;
        }
        /* CA_Stage_3_Scell_TM_change: Start */
        /* + SPR 20078 */
        if(p_ue_context->p_ue_mac_report->ue_stats[report_index].bitMask &
                RRM_MAC_UE_PERIODIC_SCELL_REPORT_PRESENCE_BITMASK)
        {
            /* Check scellReportBitMask for Cell Index used as Scell on current Cell for which Report is received */
            /* Bit 1-7 represent the Scell Index */
            for(count=RRM_ONE; count<RRM_MAX_SCELL; count++)
            {
                if((p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReportBitMask & (RRM_ONE<<count)))
                {
                    for(scell_count = RRM_ZERO; scell_count < p_ue_context->ue_scell_add_params.count; scell_count++)
                    {
                        if(p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_count].scell_index == count)
                        {
                            /*UT-Fix*/
                            p_ue_context->ue_avg_stats.bitMask |=
                                RRM_MAC_UE_PERIODIC_SCELL_REPORT_PRESENCE_BITMASK;

                            p_ue_context->ue_avg_stats.scellReportBitMask |= (RRM_ONE<<count); 
                            scell_total_downlinkSINRValueCW0 = (scell_total_downlinkSINRValueCW0 +
                                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                                    scellReport[count].downlinkSINRValueCW0);

                            if(p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkSINRValueCW1)
                            {
                                scell_total_downlinkSINRValueCW1 = (scell_total_downlinkSINRValueCW1 +
                                        p_ue_context->p_ue_mac_report->ue_stats[report_index].
                                        scellReport[count].downlinkSINRValueCW1);
                                valid_scell_dl_sinr_cw1++;
                            }

                            if(p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkSINRValueCW0Layers2)
                            {
                                scell_total_downlinkSINRValueCW0Layers2 = (scell_total_downlinkSINRValueCW0Layers2 +
                                        p_ue_context->p_ue_mac_report->ue_stats[report_index].
                                        scellReport[count].downlinkSINRValueCW0Layers2);
                                valid_scell_dl_sinr_cw0_layer2++;
                            }

                            if(p_ue_context->p_ue_mac_report->ue_stats[report_index].scellReport[count].downlinkSINRValueCW1Layers2)
                            {
                                scell_total_downlinkSINRValueCW1Layers2 = (scell_total_downlinkSINRValueCW1Layers2 +
                                        p_ue_context->p_ue_mac_report->ue_stats[report_index].
                                        scellReport[count].downlinkSINRValueCW1Layers2);
                                valid_scell_dl_sinr_cw1_layer2++;
                            }
                        }
                    }
                }
            }
            /* - SPR 20078 */
        }
        /* CA_Stage_3_Scell_TM_change: End */

        /* eICIC_PHASE_1_2_CHANGES_START */
        /* + SPR 20078 */
        if(p_ue_context->p_ue_mac_report->ue_stats[report_index].bitMask &
                /* - SPR 20078 */
                RRM_MAC_UE_PERIODIC_CSI_SUBFRAME_SET2_REPORT_PRESENCE_BITMASK)
        {
            /* SPR 14286 start */
            if(RRM_MAX_REPORT_STAT_UE == p_ue_context->p_ue_mac_report->eicic_set2_report_count)
            {
                p_ue_context->p_ue_mac_report->eicic_set2_report_count = RRM_ZERO;
                total_downlinkSINRValueCW0_subframeSet2 = RRM_ZERO;
                total_downlinkSINRValueCW1_subframeSet2 = RRM_ZERO;
                total_downlinkSINRValueCW0Layers2_subframeSet2 = RRM_ZERO;
                total_downlinkSINRValueCW1Layers2_subframeSet2 = RRM_ZERO;
            }
            p_ue_context->p_ue_mac_report->eicic_set2_report_count++ ;
            /* SPR 14286 end  */
            /* + SPR 20078 */
            p_ue_context->ue_avg_stats.bitMask |=
                RRM_MAC_UE_PERIODIC_CSI_SUBFRAME_SET2_REPORT_PRESENCE_BITMASK;
            /* - SPR 20078 */

            /* + SPR 20078 */
            total_downlinkSINRValueCW0_subframeSet2 = (total_downlinkSINRValueCW0_subframeSet2 +
                    p_ue_context->p_ue_mac_report->ue_stats[report_index].
                    csiSubframeSet2Report.downlinkSINRValueCW0_2);
            /* - SPR 20078 */

            /* + SPR 20078 */
            if(p_ue_context->p_ue_mac_report->ue_stats[report_index].csiSubframeSet2Report.downlinkSINRValueCW1_2)
            {
                total_downlinkSINRValueCW1_subframeSet2 = (total_downlinkSINRValueCW1_subframeSet2 +
                        p_ue_context->p_ue_mac_report->ue_stats[report_index].
                        csiSubframeSet2Report.downlinkSINRValueCW1_2);
                valid_csi_subframe_set2_dl_sinr_cw1++;
            }

            if(p_ue_context->p_ue_mac_report->ue_stats[report_index].csiSubframeSet2Report.downlinkSINRValueCW0Layers2_2)
            {
                total_downlinkSINRValueCW0Layers2_subframeSet2 = (total_downlinkSINRValueCW0Layers2_subframeSet2+
                        p_ue_context->p_ue_mac_report->ue_stats[report_index].
                        csiSubframeSet2Report.downlinkSINRValueCW0Layers2_2);
                valid_csi_subframe_set2_dl_sinr_cw0_layer2++;
            }

            if(p_ue_context->p_ue_mac_report->ue_stats[report_index].csiSubframeSet2Report.downlinkSINRValueCW1Layers2_2)
            {
                total_downlinkSINRValueCW1Layers2_subframeSet2 = (total_downlinkSINRValueCW1Layers2_subframeSet2 +
                        p_ue_context->p_ue_mac_report->ue_stats[report_index].
                        csiSubframeSet2Report.downlinkSINRValueCW1Layers2_2);
                valid_csi_subframe_set2_dl_sinr_cw1_layer2++;
            }
            /* - SPR 20078 */
        }
        /* eICIC_PHASE_1_2_CHANGES_END */
    }

    report_index = p_ue_context->p_ue_mac_report->report_index;

    if( report_index < (RRM_MAX_REPORT_STAT_UE ))
    {
        p_ue_context->ue_avg_stats.uplinkSINRValue = (total_uplinkSINRValue / report_index);
        p_ue_context->ue_avg_stats.uplinkBlerValue = (total_uplinkBlerValue / report_index);
        /* + SPR 20078 */
        p_ue_context->ue_avg_stats.uplinkPathLossValue = (total_uplinkPathlossValue / report_index);
        /* - SPR 20078 */
        p_ue_context->ue_avg_stats.downlinkSINRValueCW0 = (total_downlinkSINRCW0 / report_index );

        /* take the average of downlink sinr cw1 if number of valid samples are 
           present. sample will be considered as valid if value is non zero  */
        if( valid_dl_sinr_cw1 )
            p_ue_context->ue_avg_stats.downlinkSINRValueCW1 = (total_downlinkSINRCW1 / valid_dl_sinr_cw1 );

        /*ECN load start*/
        p_ue_context->ue_ecn_list.total_downlinkSINRValue = (total_downlinkSINRValue /report_index);
        /*ECN load end*/
        /*  DYNAMIC ICIC CHANGES START  */
        p_ue_context->ue_avg_stats.pucchSINRValue = (total_pucch_SINR_Value / report_index);
        p_ue_context->ue_avg_stats.pucchBlerValue = (total_pucch_SINR_Value / report_index);
        /*  DYNAMIC ICIC CHANGES END  */
        /* SPR 18641_18843 fix start */
        /* + SPR 20078 */
        p_ue_context->ue_avg_stats.uplinkPRB = latest_rb_used_by_ue/report_index;
        /* - SPR 20078 */
        /* SPR 18641_18843 fix end */
        /* CA_Stage_3_Scell_TM_change: Start */
        rrm_caclulate_avg_sinr_for_scell( p_ue_context,
                report_index,
                valid_scell_dl_sinr_cw1,
                valid_scell_dl_sinr_cw0_layer2,
                valid_scell_dl_sinr_cw1_layer2,
                scell_total_downlinkSINRValueCW0,
                scell_total_downlinkSINRValueCW1,
                scell_total_downlinkSINRValueCW0Layers2,
                scell_total_downlinkSINRValueCW1Layers2);

        /* SPR 14286 start */

        p_ue_context->p_ue_mac_report->eicic_report_count++;	
        rrm_uem_caclulate_avg_sinr_for_eicic_CsisubFrameSet2(p_ue_context,
                /* SPR 14286 start  */
                p_ue_context->p_ue_mac_report->eicic_set2_report_count,
                /* SPR 14286 end  */
                valid_csi_subframe_set2_dl_sinr_cw1,
                valid_csi_subframe_set2_dl_sinr_cw0_layer2,
                valid_csi_subframe_set2_dl_sinr_cw1_layer2,
                total_downlinkSINRValueCW0_subframeSet2,
                total_downlinkSINRValueCW1_subframeSet2,
                total_downlinkSINRValueCW0Layers2_subframeSet2,
                total_downlinkSINRValueCW1Layers2_subframeSet2); 


        /* SPR 14286 end */
        /* CA_Stage_3_Scell_TM_change: End */

    }
    else
    {
        p_ue_context->ue_avg_stats.uplinkSINRValue  = (total_uplinkSINRValue / (RRM_MAX_REPORT_STAT_UE));
        p_ue_context->ue_avg_stats.uplinkBlerValue  = (total_uplinkBlerValue / (RRM_MAX_REPORT_STAT_UE));
        /* + SPR 20078 */
        p_ue_context->ue_avg_stats.uplinkPathLossValue  = (total_uplinkPathlossValue / (RRM_MAX_REPORT_STAT_UE));
        /* - SPR 20078 */
        p_ue_context->ue_avg_stats.downlinkSINRValueCW0 = (total_downlinkSINRCW0 / (RRM_MAX_REPORT_STAT_UE) );

        /* take the average of downlink sinr cw1 if number of valid samples are 
           present. sample will be considered as valid if value is non zero  */
        if( valid_dl_sinr_cw1 )
            p_ue_context->ue_avg_stats.downlinkSINRValueCW1 = (total_downlinkSINRCW1 / valid_dl_sinr_cw1 );

        /*ECN load start*/
        p_ue_context->ue_ecn_list.total_downlinkSINRValue = (total_downlinkSINRValue / (RRM_MAX_REPORT_STAT_UE));
        /*ECN load end*/
        /*  DYNAMIC ICIC CHANGES START  */
        p_ue_context->ue_avg_stats.pucchSINRValue = (total_pucch_SINR_Value / RRM_MAX_REPORT_STAT_UE);
        p_ue_context->ue_avg_stats.pucchBlerValue = (total_pucch_SINR_Value / RRM_MAX_REPORT_STAT_UE);
        /*  DYNAMIC ICIC CHANGES END  */
        /* SPR 18641_18843 fix start */
        /* + SPR 20078 */
        p_ue_context->ue_avg_stats.uplinkPRB = latest_rb_used_by_ue/RRM_MAX_REPORT_STAT_UE;
        /* - SPR 20078 */
        /* SPR 18641_18843 fix end */
        /* CA_Stage_3_Scell_TM_change: Start */ 
        rrm_caclulate_avg_sinr_for_scell( p_ue_context,
                report_index,
                valid_scell_dl_sinr_cw1,
                valid_scell_dl_sinr_cw0_layer2,
                valid_scell_dl_sinr_cw1_layer2,
                scell_total_downlinkSINRValueCW0,
                scell_total_downlinkSINRValueCW1,
                scell_total_downlinkSINRValueCW0Layers2,
                scell_total_downlinkSINRValueCW1Layers2);
        /* CA_Stage_3_Scell_TM_change: End */
        /* eICIC_PHASE_1_2_CHANGES_START */

        /* SPR 14286 start */
        p_ue_context->p_ue_mac_report->eicic_report_count++;
        if((RRM_MAX_REPORT_STAT_UE == report_index) || (RRM_MAX_REPORT_STAT_UE == p_ue_context->p_ue_mac_report->eicic_report_count))
        {

            p_ue_context->p_ue_mac_report->eicic_report_count = RRM_ZERO;	
            p_ue_glbl_ctxt->p_ue_context = p_ue_context;

            p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
            if (RRM_PNULL == p_cell_ctxt)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                        "Cell Context not found");
            }
            else
            {
                /* SPR 14613 Fix start */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "CQI reporting MODE is %d",p_cell_ctxt->operator_info.admission_control_info.\
                        ue_service_profile.radio_res_config.\
                        physical_config_dedicated.cqi_reporting.\
                        rrm_cqi_reporting_mode_configured);
                /* SPR 14613 Fix end */
                /* SPR_14046_START */    
                if(RRM_TRUE == rrm_cellm_is_victim_node(p_cell_ctxt) && 
                        /*SPR 14613 Fix start */
                        (RRM_DISABLE_CQI_REPORTING != p_cell_ctxt->operator_info.admission_control_info.\
                         ue_service_profile.radio_res_config.\
                         physical_config_dedicated.cqi_reporting.\
                         rrm_cqi_reporting_mode_configured))
                    /*SPR 14613 Fix end */
                    /* SPR_14046_END */    
                {
                    /* SPR 19858 Fix Start */
                    if(p_ue_context->ue_sps_data.is_sps_erab_established != RRM_TRUE && 
                            p_ue_context->drb_configured.num_of_list != RRM_ZERO &&
                            RRM_UE_ERB_NULL == p_ue_context->current_procedure.state) 
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                " victim ue identification starts ");
                        rrm_calculate_victim_ue(p_ue_glbl_ctxt, p_cell_ctxt);
                    }
                    else if ( RRM_UE_ERB_NULL != p_ue_context->current_procedure.state)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                                " victim ue identification halts as current procedure state for [UE:%d] is: %d  ",\
                                p_ue_context->ue_index,p_ue_context->current_procedure.state);

                    }
                    /* SPR 19858 Fix End */
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                                " victim ue identification halts as sps is enabled or  " 
                                " drb is not configured for UE ");
                    }
                }
                else
                {        
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,\
                            "Neither of VICTIM nor VICTIM-AGGRESSOR BOTH" \
                            "and CQI is disabled"\
                            "in this cell[%d]", p_ue_context->cell_index); 
                }
            }
        }
        else
        {

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    " MAC report for victim UE:[%d], MAC set2 report for victim UE:[%d]", 
                    p_ue_context->p_ue_mac_report->eicic_report_count,
                    p_ue_context->p_ue_mac_report->eicic_set2_report_count);

            rrm_uem_caclulate_avg_sinr_for_eicic_CsisubFrameSet2(p_ue_context,
                    /* SPR 14286 start  */
                    p_ue_context->p_ue_mac_report->eicic_set2_report_count,
                    /* SPR 14286 end  */
                    valid_csi_subframe_set2_dl_sinr_cw1,
                    valid_csi_subframe_set2_dl_sinr_cw0_layer2,
                    valid_csi_subframe_set2_dl_sinr_cw1_layer2,
                    total_downlinkSINRValueCW0_subframeSet2,
                    total_downlinkSINRValueCW1_subframeSet2,
                    total_downlinkSINRValueCW0Layers2_subframeSet2,
                    total_downlinkSINRValueCW1Layers2_subframeSet2);

            /* + SPR 20078 */
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, \
                    "Average downlinkSINRValueCW0_subframeSet2 [%d],\
                    Average downlinkSINRValueCW1_subframeSet2 [%d]",\
                    p_ue_context->ue_avg_stats.csiSubframeSet2Report.downlinkSINRValueCW0_2,\
                    p_ue_context->ue_avg_stats.csiSubframeSet2Report.downlinkSINRValueCW1_2);
            /* - SPR 20078 */

        }


        /* SPR 14286 end */
    }

    /* eICIC_PHASE_1_2_CHANGES_END */

    /* calculate the average value if valid samples are present */
    if( valid_dl_sinr_cw0_layer2 )
        p_ue_context->ue_avg_stats.downlinkSINRValueCW0Layers2 = total_dlSINRValueCW0Layers2 / valid_dl_sinr_cw0_layer2;
    if( valid_dl_sinr_cw1_layer2 )
        p_ue_context->ue_avg_stats.downlinkSINRValueCW1Layers2 = total_dlSINRValueCW1Layers2 / valid_dl_sinr_cw1_layer2;
    if( valid_dl_bler_cw0_layer2 )
        p_ue_context->ue_avg_stats.downlinkBlerValueCW0Layers2 = total_dlBlerValueCW0Layers2 / valid_dl_bler_cw0_layer2;
    if( valid_dl_bler_cw1_layer2 )
        p_ue_context->ue_avg_stats.downlinkBlerValueCW1Layers2 = total_dlBlerValueCW1Layers2 / valid_dl_bler_cw1_layer2;


    /*Start changes for TTI bundling feature*/
    /*End changes for TTI bundling feature*/
    /* BUG-7937 START */
    /* + SPR 20078 */
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
            "Average of last %d UE stats report are(if UE stats reports is recieved >= 20 times,"
	    " Then given value are average of last 20 reports) "
	    " Average uplinkSINRValue [%d],Average uplinkBlerValue[%d],"
	    " Average uplinkPathLossValue[%d] ,Avg SINR dl[%d],Average SINR downlinkCW0 [%d],"
	    " Average SINR downlinkCW1[%d] Avg PUCCH SINR[%d], Avg PUCCH BLER[%d], Latest Uplink PHR[%d] ",
            report_index,p_ue_context->ue_avg_stats.uplinkSINRValue,\
            p_ue_context->ue_avg_stats.uplinkBlerValue,p_ue_context->ue_avg_stats.uplinkPathLossValue,
            p_ue_context->ue_ecn_list.total_downlinkSINRValue,p_ue_context->ue_avg_stats.downlinkSINRValueCW0,
            p_ue_context->ue_avg_stats.downlinkSINRValueCW1,p_ue_context->ue_avg_stats.pucchSINRValue,
            p_ue_context->ue_avg_stats.pucchBlerValue,
            /* SPR 18641_18843 fix start */
            p_ue_context->ue_avg_stats.uplinkPRB);
    /* SPR 18641_18843 fix end */
    /* - SPR 20078 */

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, \
            "Average scell_total_downlinkSINRValueCW0[%d],"
            " Average scell_total_downlinkSINRValueCW1[%d]",
            p_ue_context->ue_avg_stats.scellReport[1].downlinkSINRValueCW0,
            p_ue_context->ue_avg_stats.scellReport[1].downlinkSINRValueCW1);
    /* BUG-7937 END */
    RRM_UT_TRACE_EXIT();
}

/* eICIC_PHASE_1_2_CHANGES_START */
/*SPR Fix 15664 Start */
rrm_return_et
    rrm_ue_fill_meas_config_req_for_changed_gap_offset
(
 rrc_rrm_meas_config_req_t  *p_rrc_rrm_meas_config_req,
 rrm_ue_context_t           *p_ue_context,
 U8                         final_changed_meas_gap_offset 
 )
{
    if ((RRM_PNULL == p_rrc_rrm_meas_config_req )
            || (RRM_PNULL == p_ue_context))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Either p_rrc_rrm_meas_config_req, p_ue_context is NULL");
        return RRM_FAILURE;
    }

    p_rrc_rrm_meas_config_req->ue_index   = p_ue_context->ue_index;

    /* Configuring meas_gap params for changed meas_gap_offset*/
    p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_GAP_CONFIG_PRESENT;

    p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.meas_gap_config_type
        = RRM_ONE;
    p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.bitmask
        |= MEAS_GAP_CONFIG_SETUP_CONFIG_INFO_PRESENT;

    if(RRM_MEAS_GAP_TYPE_0 == p_ue_context->meas_gap_type)
    {
        p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.setup_config_info.bitmask 
            |= MEAS_GAP_CONFIG_GP0_PRESENT;

        p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.setup_config_info.gp0
            = final_changed_meas_gap_offset;

    }
    else
    {
        p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.setup_config_info.bitmask 
            |= MEAS_GAP_CONFIG_GP1_PRESENT;
        p_rrc_rrm_meas_config_req->meas_config.meas_gap_config.setup_config_info.gp1
            = final_changed_meas_gap_offset;
    }

    return RRM_SUCCESS;
}

/*SPR Fix 15664 End*/
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_handler_schedule_victim_ue 
 *   DESCRIPTION:   This function calculate victim as per reprted DLSINR from L2
 *   INPUT:         p_ue_glbl_ctxt:ue context      
 *   OUTPUT:        NONE
 *   RETURNS:       RRM_SUCCESS/RRM_FAILURE 
 ******************************************************************************/
rrm_return_et
rrm_uem_handler_schedule_victim_ue
(
 rrm_ue_global_context_t   *p_rrm_glb_ctxt,
 rrm_void_t                *p_api,
 /*SPR 17777 +-*/
 U16                        data_len 
 )
{
    rrm_return_et ret_val = RRM_FAILURE;
    rrm_ue_context_t *p_ue_context = RRM_PNULL;
    rrm_cell_context_t *p_cell_context = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_ctx = RRM_PNULL;
    rrm_seq_data_info_t        ue_node;
    /* SPR 20652 Fix End */
    rrm_ue_index_t      ue_index_list[MAX_NUM_OF_UE]  = {RRM_ZERO};   
    rrm_ue_index_t      ue_index = RRM_NULL;
    rrm_cell_index_t    cell_index = RRM_NULL;
    victim_ue_node_t    *p_victim_node= RRM_PNULL;
    /* SPR 14576 start */ 
    rrm_victim_schedule_cause_et schedule_cause;
    /* SPR 14576 end */ 
    /*SPR 15663 start*/
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    /*SPR 15663 end*/
    YLIST               victim_ue_list;
    U16                 count_of_victim_ue_to_be_reconf = RRM_ZERO;
    U16			num_of_valid_aggressor = RRM_ZERO;
    U16			valid_aggressor_list[RRM_MAX_AGGRESSOR_CNT] = {RRM_ZERO}; 	
    U32                 victim_ue_count                = RRM_ZERO;
    U32                 ue_update_count                = RRM_ZERO;
    U16                 victim_index                   = RRM_ZERO; 
    /*SPR Fix 15664 Start */
    rrm_meas_config_info_t *p_cell_meas_config_info =RRM_NULL;
    U8                  meas_gap_offset_stored = RRM_ZERO;
    U8                  final_changed_meas_gap_offset = RRM_ZERO;
    U8                  abs_pattern_bianry[RRM_FORTY] = {RRM_ZERO};
    U16                 transaction_id                 = RRM_ZERO;
    rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req = RRM_PNULL;
    /*SPR Fix 15664 End */


    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_SCHEDULE_VICTIM_UE_IND");
    
    /*SPR Fix 15664 Start */
    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*)
        rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t)); 
    if (RRM_PNULL == p_rrc_rrm_meas_config_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }
    /*SPR Fix 15664 End */

    if( data_len < sizeof(rrmuem_cm_schedule_victim_ue_ind_t) )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "rrm_cell_info_transfer_object Message Buffer corruption at UE Mgr");
        /* Coverity ID 87128 Starts */
        RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
        /* Coverity ID 87128 Ends */
        ret_val = RRM_FAILURE;
    }
    else 
    {
        cell_index = ((rrmuem_cm_schedule_victim_ue_ind_t *)p_api)->cell_index;
        SET_CELL_INDEX(cell_index);

        num_of_valid_aggressor = ((rrmuem_cm_schedule_victim_ue_ind_t *)p_api)->aggressor_count;
        /* SPR 14576 start */ 
        schedule_cause = ((rrmuem_cm_schedule_victim_ue_ind_t *)p_api)->schedule_cause;
        /* SPR 14576 end */ 
        RRM_MEMCPY(valid_aggressor_list ,((rrmuem_cm_schedule_victim_ue_ind_t *)p_api)->valid_aggressor_list, RRM_MAX_AGGRESSOR_CNT) ;
        p_cell_context = rrm_cellm_get_cell_context(cell_index);

        /*SPR 15663 start*/
        /* SPR 20652 Fix Start */
        rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
        while(RRM_PNULL != p_ue_context)
        {
            /* SPR 19016 Fix Start */
            /*SPR 22464 Fix Start*/
            if((RRM_TRUE ==  rrm_is_set_fgi_bit(p_ue_context, RRM_HUNDRED_FIFTEEN)) &&
                    (RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                     eutra_radio_capability_info_def.access_stratum_release))
            /*SPR 22464 Fix Stop*/
                /* SPR 19016 Fix End */
            {  
                if((RRM_VICTIM_SCHEDULE_WITH_ABS_CHANGE == schedule_cause)
                        && (RRM_UE_NO_VICTIM_STATE == p_ue_context->rrm_ue_eicic_info.victim_ue))
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            " Sending UE reconfig for REL10 victim UE to RRC ");
                    ret_val = rrm_uem_send_rrc_ue_reconfig_for_victim_ue(p_ue_context,RRM_TRUE, RRM_ZERO);
                    if(RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                                "[UE:%d] reconfig failed while scheduling with ABS on RRC", ue_index);
                    }
                    else
                    {
                        p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_NON_VICTIM;
                        p_ue_context->rrm_ue_eicic_info.non_vitim_reconfig_flag = RRM_TRUE;
                    }    
                }   
            } 
            ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
            /* SPR 20652 Fix End */
        }    
        /*SPR 15663 end*/

        if (RRM_PNULL == p_cell_context)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                    "Cell Context not found");
            RRM_UT_TRACE_EXIT();
            /* Coverity ID 87128 Starts */
            RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
            /* Coverity ID 87128 Ends */
            return RRM_FAILURE;
        }

        victim_ue_list = p_rrm_glb_ctxt->victim_ue_info.
            rrm_victim_ue_on_cell[cell_index].victim_ue_list;

        /* Deletion of UEs for which aggressors reported are invalid */
        rrm_uem_update_victim_ue_list_based_on_valid_aggressor(&victim_ue_list, cell_index,
                valid_aggressor_list, num_of_valid_aggressor);

        /* SPR_14046_START */

        p_rrm_glb_ctxt->victim_ue_info.
            rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;
        /* SPR_14046_END */

        /* counting total victim ue present in list */
        victim_ue_count = ylCount(&victim_ue_list);
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "victim ue count = [%d] after refreshing the list", victim_ue_count);
        /* cov_fix_69596 */
        /*CID:71368 start*/
        if(victim_ue_count)
        {    
            /* sorting victim ue list based on dl_sinr */
            ylSort(&victim_ue_list, rrm_uem_key_of_victim_ue , rrm_uem_compare_victim_ue_based_on_sinr);

            /* SPR 14610 start */
            p_rrm_glb_ctxt->victim_ue_info.
                rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;
            /* SPR 14610 end */
            /* bug_13911_start */
            p_victim_node =  (victim_ue_node_t *)ylFirst(&victim_ue_list);
            /* bug_13911_end */
            if(RRM_PNULL == p_victim_node)
            {

                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                        "victim node not found");
                RRM_UT_TRACE_EXIT();
                /* Coverity ID 87128 Starts */
                RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
                /* Coverity ID 87128 Ends */
                return RRM_FAILURE;

            }

            if(RRM_FAILURE == rrm_uem_find_num_eligible_ue_for_ue_reconfig(p_cell_context, 
                        victim_ue_count, &count_of_victim_ue_to_be_reconf))
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to derive num of eligible ue for reconfig");
                /* Coverity ID 87128 Starts */
                RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
                /* Coverity ID 87128 Ends */
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE; 
            } 

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    " Eligible victim UE Count = [%d] ", count_of_victim_ue_to_be_reconf);

            /* SPR 14576 start */ 
            /* SPR 14923 start */ 
            while(p_victim_node && (victim_index < count_of_victim_ue_to_be_reconf))
            {
                ue_index = p_victim_node->victim_ue_node_data.ue_index; 

                /* SPR 20652 Fix Start */
                p_ue_ctx = rrm_ue_find_context(ue_index, cell_index); 
                if (RRM_PNULL == p_ue_ctx)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "UE Context not found");
                    /* Coverity ID 87128 Starts */
                    RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
                    /* Coverity ID 87128 Ends */
                    /* SPR 14226 start */
                    RRM_UT_TRACE_EXIT();
                    /* SPR 14226 end*/
                    return RRM_FAILURE;
                }

                /* SPR 20652 Fix Start */
                /* Code Removed */
                /* SPR 20652 Fix End */
                if((RRM_VICTIM_SCHEDULE_WITH_NO_ABS_CHANGE == schedule_cause)
                        && (RRM_UE_VICTIM_STATE == p_ue_ctx->rrm_ue_eicic_info.victim_ue))
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "[UE:%d] has already been configured with ABS", p_ue_ctx->ue_index);
                    p_victim_node = (victim_ue_node_t *)ylNext(&p_victim_node->node);
                    continue;	
                    /* SPR 14923 end*/
                }
                /* SPR 14576 end */ 
                /* sending ue reconfig request to rrc for REL10 UE's */
                /* SPR_14046_START */    
            /*SPR 22464 Fix Start*/
                if((RRM_TRUE ==  rrm_is_set_fgi_bit(p_rrm_glb_ctxt->p_ue_context, RRM_HUNDRED_FIFTEEN)) && 
                        (RRM_REL10 <= p_ue_ctx->ue_capability_params.rrm_eutra_radio_capability_info.
                         eutra_radio_capability_info_def.access_stratum_release))
            /*SPR 22464 Fix Stop*/
                    /* SPR_14046_END */    
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            " Sending UE reconfig for REL10 victim UE to RRC ");
                    ret_val = rrm_uem_send_rrc_ue_reconfig_for_victim_ue(p_ue_ctx,RRM_TRUE, RRM_ONE); 
                    if(RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                                "[UE:%d] reconfig failed while scheduling with ABS on RRC", ue_index);
                    }
                    /* SPR 14471 start */
                    p_ue_ctx->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM;
                    /* SPR 14471 end */

                    /*SPR 20461 START*/
                    /*Code Deleted*/
                    /*SPR 20461 END*/
                    /*SPR Fix 15664 Start */
                    /* MEAS GAP ALIGNMNET WITH eICIC*/
                    if (RRM_TRUE == p_ue_ctx->is_meas_gap_configured)
                    {
                        p_cell_meas_config_info = 
                            (rrm_meas_config_info_t*)rrm_cellm_get_meas_config_info(p_cell_context->cell_index);
                        if ((p_cell_meas_config_info->bitmask & RRMCM_RMIF_MEAS_GAP_CONFIG_PRESENT) &&
                                (p_cell_meas_config_info->meas_gap_config.bitmask & RRMCM_RMIF_EUTRAN_GAP_OFFSET_TYPE_PRESENT )
                           )
                        {
                            rrm_uem_convert_abs_pattern_to_binary(
                                    p_cell_context->rrm_eicic_cell_info.usable_abs_pattern_applied, abs_pattern_bianry);

                            /* UEM shall move the meas gap offset */
                            meas_gap_offset_stored = p_ue_ctx->meas_gap_offset;
                            final_changed_meas_gap_offset = rrm_uem_align_meas_offset_with_eicic(
                                    &p_ue_ctx->meas_gap_offset, abs_pattern_bianry, RRM_ONE);
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                    "meas_gap_offset is [%u] after applying common ABS",final_changed_meas_gap_offset);

                            if (meas_gap_offset_stored != final_changed_meas_gap_offset)
                            {
                                if(RRM_SUCCESS == rrm_ue_fill_meas_config_req_for_changed_gap_offset(p_rrc_rrm_meas_config_req,
                                            p_ue_ctx, final_changed_meas_gap_offset))
                                {
                                    transaction_id = rrm_generate_txn_id();
                                    if(RRM_SUCCESS == rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                                                RRM_MODULE_ID, RRC_MODULE_ID, transaction_id, p_ue_ctx->cell_index))
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                                "Successfully send meas_config_req for changed meas_gap_offset");
                                    }
                                }
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                        "No change in meas_gap_offset[%d] So no need to send meas config",final_changed_meas_gap_offset);
                            }
                        }
                    }
                    /*SPR Fix 15664 End */

                }
                else
                {
                    if(ue_update_count < MAX_NUM_OF_UE)
                    {
                        ue_index_list[ue_update_count] = p_ue_ctx->ue_index;
                        ue_update_count++;
                    }
                    /* SPR 20652 Fix End */
                    else
                    {
                        /* keeping track of num_of_eligible_ue in global context */
                        p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.num_of_eligible_ue = ue_update_count;

                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                " Sending UE reconfig for victim UE's [%d]  to MAC ", ue_update_count);
                        /* send ue reconfig to MAC */
                        ret_val =  rrm_uem_send_l2_ue_reconfig_for_victim_ue(
                                p_rrm_glb_ctxt,
                                ue_index_list,
                                ue_update_count,
                                cell_index);
                        if(RRM_FAILURE == ret_val)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                                    "[UE:%d] reconfig failed while scheduling with ABS on MAC", ue_index);
                        }
                        ue_update_count = RRM_ZERO;
                        /* SPR 14471 start */
                        p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM;
                        /* SPR 14471 end */

                        RRM_MEMSET(ue_index_list, RRM_NULL, MAX_NUM_OF_UE);
                    } 
                }
                p_victim_node = (victim_ue_node_t *)ylNext(&p_victim_node->node);
                /* SPR 14576 start */ 
                victim_index++;
                /* SPR 14576 end */ 
            }

            /* keeping track of num_of_eligible_ue in global context ***/
            p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.num_of_eligible_ue = ue_update_count;

            /* bug_13911_start */
            if(ue_update_count)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        " Sending UE reconfig for victim UE's [%d]  to MAC ", ue_update_count);
                /* bug_13911_end */
                /* send ue reconfig to MAC */
                ret_val =  rrm_uem_send_l2_ue_reconfig_for_victim_ue(
                        p_rrm_glb_ctxt, 
                        ue_index_list, 
                        ue_update_count,
                        cell_index);
                if(RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                            "[UE:%d] reconfig failed while scheduling with ABS on MAC", ue_index);
                }
                /* SPR 14471 start */
                p_rrm_glb_ctxt->p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM;
                /* SPR 14471 end */
            }
        }

        /*CID:71368 end*/
    }

    /* Coverity ID 87128 Starts */
    RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
    /* Coverity ID 87128 Ends */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR Fix 15664 Start  */
/******************************************************************************
 *   FUNCTION NAME: rrm_max_eligible_active_victim_ue
 *   DESCRIPTION:   This function calculate maximum no. of eligible victim UE
 *   INPUT:         p_count_of_victim_ue_to_be_reconf
 *   OUTPUT:
 *   RETURNS:
 ******************************************************************************/
rrm_void_t
    rrm_max_eligible_active_victim_ue
(
 U16*  p_count_of_victim_ue_to_be_reconf,
 U16  max_eligible_active_victim_ue
 )
{
    RRM_UT_TRACE_ENTER();
    if(*p_count_of_victim_ue_to_be_reconf < max_eligible_active_victim_ue)
    {
        *p_count_of_victim_ue_to_be_reconf = max_eligible_active_victim_ue;
    }

    RRM_UT_TRACE_EXIT();
}
/* SPR Fix 15664 End  */

/****************************************************************************
 * Function Name  : rrm_uem_find_num_eligible_ue_for_ue_reconfig 
 * Inputs    	  : rrm_cell_context_t p_cell_context, U32 victim_ue_count
 * Outputs        : U32 count_of_victim_ue_to_be_reconf 
 * Returns        : NONE 
 * Description    : derive num of ue eligible for ue reconfig at a time 
 ****************************************************************************/
rrm_return_et
rrm_uem_find_num_eligible_ue_for_ue_reconfig
(
 rrm_cell_context_t *p_cell_context,
 U32                victim_ue_count,
 /* SPR 14226 start */
 U16*               p_count_of_victim_ue_to_be_reconf 
 /* SPR 14226 end*/
 )
{
    rrm_return_et retVal = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(p_cell_context != RRM_PNULL);

    /* SPR 14226 start */
    switch (p_cell_context->cell_load_action.u.comp_load_info.curr_load_lvl)
    {
        case RRM_LOW:
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        " Low load level selected for deriving " 
                        " percentage restriction on ue reconfig ");
                *p_count_of_victim_ue_to_be_reconf = ((float )p_cell_context->
                        operator_info.eicic_info.eligible_ue /
                        (float)RRM_PERCENTAGE) * victim_ue_count; 

                retVal = RRM_SUCCESS;

            }
            break;

        case RRM_MEDIUM:
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        " Medium load level selected for deriving "
                        " percentage restriction on ue reconfig ");
                *p_count_of_victim_ue_to_be_reconf= ((float )p_cell_context->
                        cell_load_action.u.comp_load_info.mid_load.
                        eicic_load_config.eligible_ue /
                        (float)RRM_PERCENTAGE) * victim_ue_count;
                retVal = RRM_SUCCESS;

            }
            break;

        case RRM_HIGH:
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        " High load level selected for deriving "
                        " percentage restriction on ue reconfig ");
                *p_count_of_victim_ue_to_be_reconf = ((float )p_cell_context->
                        cell_load_action.u.comp_load_info.high_load.
                        eicic_load_config.eligible_ue /
                        (float)RRM_PERCENTAGE) * victim_ue_count;
                retVal = RRM_SUCCESS;

            }
            break;

        case RRM_OVERLOAD:
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        " Over load level selected for deriving "
                        " percentage restriction on ue reconfig ");
                *p_count_of_victim_ue_to_be_reconf = ((float )p_cell_context->
                        cell_load_action.u.comp_load_info.over_load.
                        eicic_load_config.eligible_ue /
                        (float)RRM_PERCENTAGE) * victim_ue_count;
                retVal = RRM_SUCCESS;
            }
            break;
        default :
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    " Invalid Load level[%d] while deriving"
                    " percentage restriction on ue reconfig ",
                    p_cell_context->cell_load_action.u.comp_load_info.curr_load_lvl);
            retVal = RRM_FAILURE;
    }

    if((RRM_SUCCESS == retVal) && (RRM_ZERO != victim_ue_count) 
            && (RRM_ZERO == *p_count_of_victim_ue_to_be_reconf))
    {
        *p_count_of_victim_ue_to_be_reconf = RRM_ONE;
    }	
    /* SPR 14226 end*/
    /*SPR Fix 15664 Start */
    if((RRM_SUCCESS == retVal) && (RRM_ZERO != victim_ue_count)
            && (RRM_ZERO != *p_count_of_victim_ue_to_be_reconf))
    {
        rrm_max_eligible_active_victim_ue(p_count_of_victim_ue_to_be_reconf, RRM_MAX_ELIGIBLE_ACTIVE_VICTIM_UE);
    }
    /*SPR Fix 15664 End */

    RRM_UT_TRACE_EXIT();
    return retVal;
}

/****************************************************************************
 * Function Name  : rrm_uem_update_victim_ue_list_based_on_valid_aggressor 
 * Inputs    	  : YLIST *victim_list, U16 *aggressor_list
 * Outputs        : YLIST * victim_list 
 * Returns        : NONE 
 * Description    : update victim ue list based on valid aggressor 
 * 		    nodes fetched from CellM  
 ****************************************************************************/
rrm_void_t
    rrm_uem_update_victim_ue_list_based_on_valid_aggressor
(
 YLIST *victim_list,
 rrm_cell_index_t cell_index,
 U16   *valid_aggressor,
 U16	num_valid_aggressor
 ) 
{
    victim_ue_node_t *p_victim_node = RRM_PNULL;	
    S32 ret_val = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /* bug_13891_start */
    p_victim_node = (victim_ue_node_t *)ylFirst(victim_list);	
    /* bug_13891_end */

    while(p_victim_node)
    {
        ret_val = rrm_uem_check_valid_victim_ue(p_victim_node, cell_index, valid_aggressor, num_valid_aggressor);
        if(RRM_MINUS_ONE == ret_val)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    " deleting invalid victim [UE:%d] based on aggressor reported ", 
                    p_victim_node->victim_ue_node_data.ue_index);
            /* deleting victim ue from list for which aggressors are not valid */
            ylDelete(victim_list, (YLNODE *)p_victim_node);
            RRM_MEM_FREE(p_victim_node);
        }
        else
        {
            p_victim_node = (victim_ue_node_t *)ylNext(&(p_victim_node->node));
        }
    }
}

/****************************************************************************
 * Function Name  : rrm_uem_check_valid_victim_ue 
 * Inputs    	  : victim_ue_node_t *victim_node 
 * Outputs        : NONE 
 * Returns        : return S32 value for validity of given node 
 * Description    : check victim node validity based on aggressor list 
 ****************************************************************************/
S32
    rrm_uem_check_valid_victim_ue
(
 victim_ue_node_t *p_victim_node,
 rrm_cell_index_t cell_index,
 U16		 *aggressor_list,
 U16		 num_of_aggressor
 )
{

    S32 ret_val = RRM_MINUS_ONE;
    U8 count = RRM_ZERO;
    U8 cell_count = RRM_ZERO;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    rrm_ue_context_t *p_ue_context = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    for(count = RRM_ZERO; count < num_of_aggressor; count++ )
    {
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(p_victim_node->victim_ue_node_data.ue_index,
                cell_index);       

        if(RRM_PNULL != p_ue_context )
        {
            /* SPR 20652 Fix End */
            for(cell_count = RRM_ZERO; cell_count < MAX_AGGRESSOR_COUNT; cell_count++)
            {
                if(p_ue_context->eicic_meas_result.valid_aggressor_list[cell_count] == aggressor_list[count] )  
                {
                    ret_val = RRM_ONE;
                    RRM_UT_TRACE_EXIT();
                    return ret_val;    
                }
            }
        } 
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                    "[UE:%d] context not found", p_victim_node->victim_ue_node_data.ue_index);
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_uem_key_of_victim_ue 
 * Inputs    	  : YLNODE *p_input_node 
 * Outputs        : NONE 
 * Returns        : key value(dl_sinr) of input node
 * Description    : return dl_sinr value of given node  
 ****************************************************************************/
const rrm_void_t *
    rrm_uem_key_of_victim_ue
(
 const YLNODE *p_input_node
 )
{
    /* SPR 14659 start */
    victim_ue_node_t *p_data = RRM_NULL;
    U32* dl_sinr = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    if (RRM_NULL == p_input_node)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Victim UE List : pointer to node is NULL\n");
    }
    else
    {
        p_data = YMEMBEROF(victim_ue_node_t, node, p_input_node);
        dl_sinr = &(p_data->victim_ue_node_data.dl_sinr);

    }
    RRM_UT_TRACE_EXIT();
    return (rrm_void_t *)dl_sinr;
    /* SPR 14659 end */

}


/****************************************************************************
 * Function Name  : rrm_uem_compare_victim_ue_based_on_sinr 
 * Inputs    	  : U32 key1, U32 key2 : value to be compared
 * Outputs        : NONE 
 * Returns        : 
 * Description    : return dl_sinr value of given node  
 ****************************************************************************/
SInt32
    rrm_uem_compare_victim_ue_based_on_sinr
(
 const rrm_void_t * key_value1,
 const rrm_void_t * key_value2
 )
{

    SInt32 ret_val = RRM_ZERO;
    /* SPR 14659 start */
    if (RRM_PNULL == key_value1 || RRM_PNULL == key_value2)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "rrm_uem_compare_victim_ue_based_on_sinr: Pointer to the Count is NULL");
        /*CID:71365,71366 start*/
        return ret_val;
        /*CID:71365,71366 end*/
    }
    /* SPR 14659 end */

    if(*(U32 *)key_value1 > *(U32 *)key_value2)
    {
        ret_val =RRM_ONE;

    }
    else if(*(U32 *)key_value1 < *(U32 *)key_value2)
    {
        ret_val = RRM_MINUS_ONE;

    }
    else
    {
        ret_val = RRM_ZERO;
    }

    return ret_val;

}

/* bug_13919_start */
/****************************************************************************
 * Function Name  : rrm_uem_handle_eicic_provision_req 
 * Inputs    	  : rrm_ue_context_t *p_rrm_ue_ctxt : rrm ue context
 * Outputs        : NONE 
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Perform action based on the inputs received from Cell Manager 
 ****************************************************************************/
rrm_return_et
    rrm_uem_handle_eicic_provision_req
(
 rrm_ue_global_context_t *p_rrm_glb_ctxt, 
 void *p_api_buf
 )
{
    RRM_UT_TRACE_ENTER();

    rrm_cell_index_t cell_index = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;

    rrmuem_cellm_eicic_provision_reconfig_resp_t *p_resp = RRM_NULL;

    cell_index = ((rrmuem_cellm_eicic_provision_reconfig_req_t *)p_api_buf)->cell_index; 

    SET_CELL_INDEX(cell_index);
    /* SPR 14140 start */
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_REQ->UEM");
    
    cell_index = ((rrmuem_cellm_eicic_provision_reconfig_req_t *)p_api_buf)->cell_index; 
    if(RRMUEM_CELLM_MEAS_SF_PATTERN_RECONFIG & 
            (((rrmuem_cellm_eicic_provision_reconfig_req_t *)p_api_buf)->bitmask)) 
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                " eicic reconfig with RRMUEM_CELLM_MEAS_SF_PATTERN_RECONFIG "); 
        ret_val = rrm_uem_handle_meas_sf_pattern_reconfig(p_rrm_glb_ctxt, cell_index);
        /*SPR 17777 +-*/

    }
    /* cov_69659_fix*/
    if(RRMUEM_CELLM_EICIC_PROVISION_RECONFIG & 
            (((rrmuem_cellm_eicic_provision_reconfig_req_t *)p_api_buf)->bitmask))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                " eicic reconfig with RRMUEM_CELLM_EICIC_PROVISION_RECONFIG "); 
        ret_val = rrm_uem_handle_reset_scenario_for_eicic(p_rrm_glb_ctxt);
    }
    if(RRM_PNULL == p_rrm_glb_ctxt->p_ue_context)
    {
        ret_val = RRM_SUCCESS;
    }

    /* SPR 14140 end */
    p_resp = rrm_mem_get(sizeof(rrmuem_cellm_eicic_provision_reconfig_resp_t));

    if( RRM_PNULL == p_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Memory Allocation Failure");
        return RRM_FAILURE;
    }


    p_resp->cell_index = cell_index;

    p_resp->transaction_id = ((rrmuem_cellm_eicic_provision_reconfig_req_t *)p_api_buf)->transaction_id;

    p_resp->response = ret_val;

    if (RRM_FAILURE == rrm_uem_send_internal_msg(
                RRM_CM_MODULE_ID,
                RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_RESP,
                sizeof(rrmuem_cellm_eicic_provision_reconfig_resp_t),
                (rrm_void_t *)p_resp))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "RRM send to MIF Failed");
        ret_val = RRM_FAILURE;
    }

    RRM_MEM_FREE(p_resp);

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR 14140 start */
/****************************************************************************
 * Function Name  : rrm_uem_handle_meas_sf_pattern_reconfig 
 * Inputs    	  : p_api_buf and rrm ue global context 
 * Outputs        : NONE 
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : perform meas pattern reconfiguration on UE's 
 ****************************************************************************/
rrm_return_et
rrm_uem_handle_meas_sf_pattern_reconfig
(
 /*SPR 17777 +-*/
 rrm_ue_global_context_t *p_rrm_glb_ctxt,
 rrm_cell_index_t cell_index
 )
{
    rrm_bool_et x2_up_flag = RRM_FALSE;
    victim_ue_node_t* p_victim_node = RRM_PNULL;
    YLIST victim_ue_list;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t           *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    rrc_rrm_ue_service_profile_t *p_ue_service_profile = RRM_PNULL;
    rrm_ue_index_t    ue_index = RRM_ZERO;
    rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_rrm_glb_ctxt);
    if(RRM_PNULL == p_rrm_glb_ctxt->p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Ue Context not found");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    p_cell_ctx = rrm_cellm_get_cell_context(cell_index);
    if(RRM_PNULL == p_cell_ctx)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Cell Context not found[%d]",cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }


    victim_ue_list = p_rrm_glb_ctxt->victim_ue_info.
        rrm_victim_ue_on_cell[cell_index].victim_ue_list;

    p_ue_service_profile = rrm_cellm_get_ue_service_profile(
            cell_index);
    if(RRM_PNULL == p_ue_service_profile)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ue_service_profile return NULL");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    p_victim_node = (victim_ue_node_t *)ylFirst
        (&(victim_ue_list));
    while (RRM_PNULL != p_victim_node)
    {
        ue_index = p_victim_node->victim_ue_node_data.ue_index; 
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context (ue_index, cell_index);

        if( RRM_PNULL == p_ue_context)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "Ue Context not found for [UE:%d]",ue_index);
            ret_val = RRM_FAILURE;
        }

        else 
        {
            if (p_victim_node->victim_ue_node_data.victim_state == RRM_UE_VICTIM_STATE)
            {
                /* sending ue reconfig request to rrc for REL10 UE's */
                if((RRM_TRUE ==  rrm_is_set_fgi_bit(p_rrm_glb_ctxt->p_ue_context, RRM_HUNDRED_FIFTEEN)) && 
                        (RRM_REL10 <= p_ue_context->ue_capability_params.
                         rrm_eutra_radio_capability_info.
                         eutra_radio_capability_info_def.access_stratum_release))
                {
                    /* SPR14157start */
                    if ((RRMCM_RMIF_EICIC_INFO_PRESENT & p_cell_ctx->operator_info.bitmask) && 
                            (RRM_OAM_EICIC_DEACTIVATED != p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type))
                    {
                        x2_up_flag = rrm_check_for_x2_link_status(p_cell_ctx);
                        /* SPR14157end*/
                    }
                    if((RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED == p_ue_service_profile->radio_res_config.
                                physical_config_dedicated.cqi_reporting.rrm_cqi_reporting_mode_configured) ||
                            ( RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED == p_ue_service_profile->
                              radio_res_config.physical_config_dedicated.cqi_reporting.rrm_cqi_reporting_mode_configured))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                                "Sending UE reconfig for victim [%d] to RRC ", ue_index);
                        if(RRM_FAILURE==rrm_uem_send_rrc_ue_reconfig_for_victim_ue(p_ue_context,x2_up_flag, RRM_ONE))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                                    "[UE:%d] rrcreconfig failed while removing csi subframe reporting", ue_index);
                            ret_val = RRM_FAILURE;	
                        }
                        /* SPR 14471 start */
                        p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM;
                        /* SPR 14471 end */
                    }
                }
            }

        }

        p_victim_node = (victim_ue_node_t *)ylNext(&(p_victim_node->node));
        /* SPR 20652 Fix End */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/* SPR 14960 start */
/****************************************************************************
 * Function Name  : rrm_uem_flush_victim_and_aggressor_node 
 * Inputs    	  : rrm_ue_global_context_t *p_rrm_glb_ctxt 
 * Outputs        : NONE 
 * Returns        : NONE
 * Description    : flushes victim and aggressor lists if cell is deleted. 
 ****************************************************************************/
rrm_void_t
    rrm_uem_flush_victim_and_aggressor_node
(
 rrm_ue_global_context_t *p_rrm_glb_ctxt
 )
{
    aggressor_node_t* p_aggressor_node = RRM_PNULL;
    victim_ue_node_t* p_victim_node = RRM_PNULL;
    YLIST victim_ue_list;
    YLIST aggressor_node_list;
    rrm_cell_index_t cell_index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_rrm_glb_ctxt);

    if(RRM_PNULL == p_rrm_glb_ctxt->p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Ue Context not found");
        return ;
    }
    cell_index = p_rrm_glb_ctxt->p_ue_context->cell_index;

    victim_ue_list = p_rrm_glb_ctxt->victim_ue_info.
        rrm_victim_ue_on_cell[cell_index].victim_ue_list;

    aggressor_node_list = p_rrm_glb_ctxt->aggressor_node_info.
        rrm_aggressor_on_cell[cell_index].aggressor_node_list;

    /*Flushing The victim ue list  */
    while (RRM_PNULL != (p_victim_node = (victim_ue_node_t *)ylPopTail
                (&(victim_ue_list))))
    {
        RRM_MEM_FREE(p_victim_node);
    }
    /*Flushing The Aggresor node List  */
    while (RRM_PNULL != (p_aggressor_node = (aggressor_node_t *)ylPopTail
                (&(aggressor_node_list))))
    {
        RRM_MEM_FREE(p_aggressor_node);
    }
    /*SPR 14959 start*/
    p_rrm_glb_ctxt->victim_ue_info.
        rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;

    p_rrm_glb_ctxt->aggressor_node_info.
        rrm_aggressor_on_cell[cell_index].aggressor_node_list = aggressor_node_list;
    /*SPR 14959 end*/

    RRM_UT_TRACE_EXIT();
}
/*SPR  14960 end */



/* SPR14140end */
/****************************************************************************
 * Function Name  : rrm_uem_handle_reset_scenario_for_eicic 
 * Inputs    	  : rrm_ue_global_context_t *p_rrm_glb_ctxt 
 * Outputs        : NONE 
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : perform deletion of all victim and aggressor lists in
 * 			crtical scenarios 
 ****************************************************************************/
rrm_return_et
    rrm_uem_handle_reset_scenario_for_eicic
(
 rrm_ue_global_context_t *p_rrm_glb_ctxt 
 )
{

    rrm_bool_et x2_up_flag = RRM_FALSE;
    aggressor_node_t* p_aggressor_node = RRM_PNULL;
    victim_ue_node_t* p_victim_node = RRM_PNULL;
    rrm_ue_index_t  ue_index_list[RRM_ONE]  = {RRM_ZERO};
    YLIST victim_ue_list;
    YLIST aggressor_node_list;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t             *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    rrm_ue_index_t    ue_index = RRM_ZERO;
    rrm_cell_index_t cell_index = RRM_ZERO;
    rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /* cov fix start */
    RRM_ASSERT(RRM_PNULL != p_rrm_glb_ctxt);
    if(RRM_PNULL == p_rrm_glb_ctxt->p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Ue Context not found");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    cell_index = p_rrm_glb_ctxt->p_ue_context->cell_index;
    /* cov fix end */

    victim_ue_list = p_rrm_glb_ctxt->victim_ue_info.
        rrm_victim_ue_on_cell[cell_index].victim_ue_list;

    aggressor_node_list = p_rrm_glb_ctxt->aggressor_node_info.
        rrm_aggressor_on_cell[cell_index].aggressor_node_list;

    /* SIT_FIX_START */
    p_cell_ctx = rrm_cellm_get_cell_context(cell_index);
    if(RRM_PNULL == p_cell_ctx)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Cell Context not found[%d]",cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /* SIT_FIX_END */
    /*Flushing The victim ue list  */
    while (RRM_PNULL != (p_victim_node = (victim_ue_node_t *)ylPopTail
                (&(victim_ue_list))))
    {
        ue_index = p_victim_node->victim_ue_node_data.ue_index; 
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context (ue_index, cell_index);

        if( RRM_PNULL == p_ue_context)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "Ue Context not found for [UE:%d]",ue_index);
            RRM_UT_TRACE_EXIT();
            ret_val = RRM_FAILURE;
        }

        else 
        {
            /* SPR 14285 start */    
            if(p_ue_context->rrm_ue_eicic_info.victim_ue == RRM_UE_VICTIM_CANDIDATE)
                /* SPR 14285 end */   
            {
                if(RRM_SUCCESS == rrm_uem_send_remove_meas_config_for_victim(p_ue_context))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                            "Successfully sent remove meas id request for victim [UE:%d]",
                            p_ue_context->ue_index);
                }
            }

            /* SPR 14285 start */    
            if (p_ue_context->rrm_ue_eicic_info.victim_ue == RRM_UE_VICTIM_STATE)
                /* SPR 14285 end */    
            {
                /* sending ue reconfig request to rrc for REL10 UE's */
                /* SPR_14046_START */
            /*SPR 22464 Fix Start*/
                if((RRM_TRUE ==  rrm_is_set_fgi_bit(p_rrm_glb_ctxt->p_ue_context, RRM_HUNDRED_FIFTEEN)) && 
                        (RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                         eutra_radio_capability_info_def.access_stratum_release))
            /*SPR 22464 Fix Stop*/
                    /* SPR_14046_END */
                {
                    /* SPR14157start */
                    if ((RRMCM_RMIF_EICIC_INFO_PRESENT & p_cell_ctx->operator_info.bitmask) && 
                            (RRM_OAM_EICIC_DEACTIVATED != p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type))
                    {
                        x2_up_flag = rrm_check_for_x2_link_status(p_cell_ctx);
                        /* SPR14157end*/
                    }

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                            "Sending UE reconfig for victim [UE:%d] to RRC ", 
                            p_ue_context->ue_index);
                    if(RRM_FAILURE==rrm_uem_send_rrc_ue_reconfig_for_victim_ue(p_ue_context,x2_up_flag, RRM_ZERO))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                                "[UE:%d] rrcreconfig failed while removing csi subframe reporting", ue_index);
                        ret_val = RRM_FAILURE;	
                    }
                    /* SPR 14471 start */
                    p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_NON_VICTIM;
                    /* SPR 14471 end */
                }
                else
                {
                    ue_index_list[RRM_ZERO] = p_victim_node->victim_ue_node_data.ue_index;
                    if(MAC_UE_RECONF_NOT_ONGOING  == (rrm_get_mac_ue_reconfig_mutex( cell_index )) )
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                                "Sending UE reconfig for victim [UE:%d] to MAC ", 
                                p_ue_context->ue_index);
                        /* Marking UE as non victim at L2 */
                        ret_val= build_and_send_l2_ue_reconfig_req_for_victim(cell_index, ue_index_list, RRM_ONE, RRM_ZERO); 
                    }

                    if(RRM_SUCCESS == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "Successfully send [UE:%d] reconfig req to  MAC for victim UEs", 
                                p_ue_context->ue_index); 

                /* SPR14126start */
                rrm_set_mac_ue_reconfig_mutex(cell_index, W_FOR_MAC_UE_RECONF_CNF_FOR_EICIC);
                /* SPR14126end */
                /* SPR 14471 start */
                p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_NON_VICTIM;
                /* SPR 14471 end */
                        /*SPR 21235 Fix Start*/
                        p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
                        p_ue_context->rrm_ue_eicic_info.scheduled_on_abs = RRM_FALSE;
                        p_ue_context->rrm_ue_eicic_info.rrm_ue_eicic_reconfig_ongoing = RRM_FALSE;
                        p_ue_context->rrm_ue_eicic_info.meas_report_id = RRM_ZERO;
                        p_ue_context->rrm_ue_eicic_info.non_vitim_reconfig_flag= RRM_FALSE;
                        /*SPR 21235 Fix Stop*/
            }
			else
			{
				RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
						"Unable to send Mac UE reconfig request for UE[%d]to L2",
						p_ue_context->ue_index);
			}

                }

            }
            RRM_MEM_FREE(p_victim_node);
        }
    }
    /* SPR 20652 Fix End */
    /*Flushing The Aggresor node List  */
    while (RRM_PNULL != (p_aggressor_node = (aggressor_node_t *)ylPopTail
                (&(aggressor_node_list))))
    {
        RRM_MEM_FREE(p_aggressor_node);
    }

    /* SPR_14046_START */
    p_rrm_glb_ctxt->victim_ue_info.
        rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;

    p_rrm_glb_ctxt->aggressor_node_info.
        rrm_aggressor_on_cell[cell_index].aggressor_node_list = aggressor_node_list;
    /* SPR_14046_END */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* bug_13919_end */


/* bug_13909_start */
/*SPR 15663 start*/
rrm_void_t 
    fill_drx_offset_for_particular_drx_cycle
(
 rrm_oam_long_drx_cycle_start_offset_et applied_long_drx_cycle,
 rrc_drx_config_param_t                 *p_drx_config_param,
 U16                                    drx_start_offset
 )    
{
    RRM_UT_TRACE_ENTER();  
    switch(applied_long_drx_cycle)
    {
        case RRM_OAM_SF10 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_10 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_10_PRESENT;
            break;
        case RRM_OAM_SF20 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_20 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_20_PRESENT;
            break; 
        case RRM_OAM_SF32 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_32 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_32_PRESENT;
            break;

        case RRM_OAM_SF40 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_40 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_40_PRESENT;
            break;

        case RRM_OAM_SF64 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_64 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_64_PRESENT;
            break;

        case RRM_OAM_SF80 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_80 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_80_PRESENT;
            break;

        case RRM_OAM_SF128 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_128 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_128_PRESENT;
            break;

        case RRM_OAM_SF160 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_160 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_160_PRESENT;
            break;

        case RRM_OAM_SF256 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_256 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_256_PRESENT;
            break;

        case RRM_OAM_SF320 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_320 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_320_PRESENT;
            break;

        case RRM_OAM_SF640 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_640 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_640_PRESENT;
            break;

        case RRM_OAM_SF1024 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_1024 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_1024_PRESENT;
            break;

        case RRM_OAM_SF1280 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_1280 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_1280_PRESENT;
            break;

        case RRM_OAM_SF2048:
            p_drx_config_param->long_drx_cycle_start_offset.sf_2048 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_2048_PRESENT;
            break;

        case RRM_OAM_SF2560 :
            p_drx_config_param->long_drx_cycle_start_offset.sf_2560 = drx_start_offset; 
            p_drx_config_param->long_drx_cycle_start_offset.bitmask |= RRC_LONG_DRX_CYCLE_START_OFFSET_SF_2560_PRESENT;
            break;

        default :
            break;
    }   
    RRM_UT_TRACE_EXIT();
}
/*SPR 15663 end*/
/* SPR14048start */
/****************************************************************************
 * Function Name  : rrm_uem_send_rrc_ue_reconfig_for_victim_ue 
 * Inputs    	  : rrm_ue_context_t *p_rrm_ue_ctxt : rrm ue context
 * Outputs        : NONE 
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Perform action based on the inputs received from Cell Manager 
 ****************************************************************************/
rrm_return_et
    rrm_uem_send_rrc_ue_reconfig_for_victim_ue
(
 rrm_ue_context_t *p_rrm_ue_context,
 rrm_bool_et    x2_up_flag,
 U8  request_type
 )
{

    /* SPR 14123 start */
    /*SPR 20780 Fix Start*/
    U8            sr_config_index   = p_rrm_ue_context->sr_params.sr_configuration_index;
    /*SPR 20780 Fix Stop*/
    U8            row_num           = INVALID_FRAME;
    U16           col_num           = INVALID_SLOT;
    U16           ri_index          = INVALID_RI_INDEX;
    U16           cqi_pmi_config_index  = INVALID_CQI_CFG_INDEX;
    U8            cqi_res_index     = INVALID_RES_INDEX;
    U16           ri_index_2          = INVALID_RI_INDEX;
    U16           cqi_pmi_config_index_2  = INVALID_CQI_CFG_INDEX;
    /*SPR 15663 start*/
    rrm_cell_drx_config_resources_t *p_cell_drx_config_res = RRM_PNULL;
    U16         sr_offset = RRM_ZERO;
    U16         cqi_offset = RRM_ZERO;
    U16         cqi_periodicity   =   RRM_ZERO ;
    rrm_bool_et collision_resolved = RRM_FALSE;
    rrm_ue_sr_paramas_t sr_param_temp = {RRM_ZERO};
    U8            sr_res_index      = INVALID_SR_CFG_INDEX;
    U16           sr_config_modification = RRM_ZERO;
    U16           meas_gap_offset = RRM_ZERO;
    U32           long_drx_cycle_value = RRM_ZERO;
    U8           sr_row_num = INVALID_FRAME;
    U16           sr_col_num = INVALID_SLOT;
    U16           drx_start_offset = RRM_ZERO;
    rrm_return_et  srs_ret_val = RRM_SUCCESS;
    /*SPR 15663 end*/
    /*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    U8               abs_size = RRM_ZERO;
#endif
    /*EICIC_TDD_CHANGES_END*/
    /* SPR 14123 end*/
    U16           transaction_id = RRM_ZERO;
    rrm_return_et			      ret_val = RRM_SUCCESS;
    rrc_rrm_ue_reconfig_req_t	  rrc_rrm_ue_reconfig_req = {RRM_ZERO};
    admission_control_info_t      *p_admission_control_info = RRM_NULL;
    rrc_mac_main_config_ue_service_profile_t    
        *p_ue_profile_mac_main_config = RRM_NULL;
    rrc_rrm_ue_service_profile_t
        *p_ue_service_profile         = RRM_PNULL;
    /* SPR 14419 start */
    const rrm_tm_mode_additional_info_t 
        *p_rrm_tm_mode_additional_info = RRM_NULL;
    /* SPR 14419 end */
    U32                             aperiodic_mode = RRM_OUT_OF_RANGE_FOUR_BYTE;
    rrmc_mac_config_t             *p_rrmc_mac_config  = RRM_NULL;
    rrm_cell_context_t            *p_cell_context; 
    U8                             dl_bandwidth              = RRM_ZERO;
    U8                             num_of_layer = RRM_ZERO;
    U8                             abs_count = RRM_ZERO;
    /* SPR 14098 start */
#ifndef TDD_MODE_FLAG
    /*14892_start*/
    U8			   common_abs_pattern1[RRM_MAX_PATTERN_BYTE] = {RRM_ZERO};	
    /*14892_end*/
    /*14893_start*/
    U8			   common_abs_pattern2[RRM_MAX_PATTERN_BYTE] = {RRM_ZERO};	
    /*14893_end*/
    /* SPR 19726 Fix Start */
    U8			   meas_abs_pattern[RRM_MAX_PATTERN_BYTE] = {RRM_ZERO};	
    /* SPR 19726 Fix Stop */
#else
    U8			   common_abs_pattern1[MAX_SUBFRAME_CONFIG0_TDD] = {RRM_ZERO};	
    U8			   common_abs_pattern2[MAX_SUBFRAME_CONFIG0_TDD] = {RRM_ZERO};	
    /* SPR 14098 end*/
    /* SPR 19726 Fix Start */
    U8			   meas_abs_pattern[MAX_SUBFRAME_CONFIG0_TDD] = {RRM_ZERO};	
    /* SPR 19726 Fix Stop */
#endif
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(p_rrm_ue_context != RRM_PNULL);

    p_cell_context = rrm_cellm_get_cell_context(p_rrm_ue_context->cell_index);
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_cell_context->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#endif
    /*EICIC_TDD_CHANGES_END*/
    if(RRM_FALSE == x2_up_flag)
    {
#ifndef TDD_MODE_FLAG
        /*SPR 14675 start*/
        /* SPR 19726 Fix Start */
        if(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask & RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT)
        {
            RRM_MEMCPY(common_abs_pattern1, p_cell_context->operator_info.eicic_info.
                    abs_info.abs_pattern.victim_abs_pattern,
                    MAX_SUBFRAME_PATTERN_FDD);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                    " victim ABS Pattern not configured ");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        if(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask & RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT)
        {
            RRM_MEMCPY(meas_abs_pattern, p_cell_context->operator_info.eicic_info.
                    abs_info.abs_pattern.victim_meas_subset,
                    MAX_SUBFRAME_PATTERN_FDD);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                    " victim Meas Subset not configured ");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        /* SPR 19726 Fix Stop */

        /* SSI_CHANGES_START */
        /* SPR 14098 start*/
        if(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask & RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT)
        {	
            for(abs_count = RRM_ZERO;abs_count < MAX_SUBFRAME_PATTERN_FDD;abs_count++)
            {
                common_abs_pattern2[abs_count] = ~(p_cell_context->operator_info.eicic_info.
                        abs_info.abs_pattern.victim_abs_pattern[abs_count]);
            }
        }
        else
        {

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                    " victim ABS not configured ");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }

        /* SPR 14098 end*/

#else
        /* SPR 19726 Fix Start */
        if(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask & RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT)
        {	
            RRM_MEMCPY(common_abs_pattern1, p_cell_context->operator_info.eicic_info.
                    abs_info.abs_pattern.victim_abs_pattern,
                    abs_size);
            rrm_copy_tdd_bits(abs_size,common_abs_pattern1);
        }
        else
        {

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                    " victim ABS Pattern not configured ");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        if(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask & RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT)
        {
            RRM_MEMCPY(meas_abs_pattern, p_cell_context->operator_info.eicic_info.
                    abs_info.abs_pattern.victim_meas_subset,
                    abs_size);
            rrm_copy_tdd_bits(abs_size,meas_abs_pattern);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                    " victim Meas Subset not configured ");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        /* SPR 19726 Fix Stop */

        /* SPR 14098 start*/
        if(p_cell_context->operator_info.eicic_info.abs_info.abs_pattern.bitmask & RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT)
        {	
            for(abs_count = RRM_ZERO;abs_count < abs_size;abs_count++)
            {
                common_abs_pattern2[abs_count] = ~(p_cell_context->operator_info.eicic_info.
                        abs_info.abs_pattern.victim_abs_pattern[abs_count]);
            }
            rrm_copy_tdd_bits(abs_size,common_abs_pattern2);
        }        
        else
        {

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    " victim ABS not configured ");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }

        /* SPR 14098 end*/

#endif  
    }
    else
    {
#ifndef TDD_MODE_FLAG
        /* SPR 19726 Fix Start */
        RRM_MEMCPY(common_abs_pattern1, p_cell_context->rrm_eicic_cell_info.
                usable_abs_pattern_applied, MAX_SUBFRAME_PATTERN_FDD);	
        RRM_MEMCPY(meas_abs_pattern, p_cell_context->rrm_eicic_cell_info.
                serving_meas_abs_pattern_applied, MAX_SUBFRAME_PATTERN_FDD);	
        /* SPR 19726 Fix Stop */

        /* cov_69664_fix  */
        /* SPR 14098 start*/
        for(abs_count = RRM_ZERO;abs_count < MAX_SUBFRAME_PATTERN_FDD;abs_count++)
        {
            common_abs_pattern2[abs_count] = ~(p_cell_context->rrm_eicic_cell_info.
                    usable_abs_pattern_applied[abs_count]);
        }

        /* SPR 14098 end*/

#else
        /* SPR 19726 Fix Start */
        RRM_MEMCPY(common_abs_pattern1, p_cell_context->rrm_eicic_cell_info.
                usable_abs_pattern_applied, abs_size);
        rrm_copy_tdd_bits(abs_size,common_abs_pattern1);
        RRM_MEMCPY(meas_abs_pattern, p_cell_context->rrm_eicic_cell_info.
                serving_meas_abs_pattern_applied, abs_size);
        rrm_copy_tdd_bits(abs_size,meas_abs_pattern);
        /* SPR 19726 Fix Stop */

        /* SPR 14098 start*/
        for(abs_count = RRM_ZERO;abs_count < abs_size;abs_count++)
        {
            common_abs_pattern2[abs_count] = ~(p_cell_context->rrm_eicic_cell_info.
                    usable_abs_pattern_applied[abs_count]);
        }
        rrm_copy_tdd_bits(abs_size,common_abs_pattern2);
        /*SPR 14675 end*/
        /* SPR 14098 end*/
#endif    
    }   

    /* SPR 14098 start*/
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            " common_abs_pattern1 : \n ");
    rrm_print_abs_pattern(common_abs_pattern1);
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            " common_abs_pattern2 : \n ");
    rrm_print_abs_pattern(common_abs_pattern2);
    /* SPR 14098 start*/

    p_admission_control_info = rrm_cellm_get_admission_control_info(
            p_rrm_ue_context->cell_index);
    if(RRM_PNULL == p_admission_control_info)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_admission_control_info return NULL");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    p_rrmc_mac_config = rrm_cellm_get_rrmc_mac_config(
            p_rrm_ue_context->cell_index);
    if(RRM_PNULL == p_rrmc_mac_config)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_rrmc_mac_config return NULL");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    p_ue_service_profile = rrm_cellm_get_ue_service_profile(
            p_rrm_ue_context->cell_index);
    if(RRM_PNULL == p_ue_service_profile)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ue_service_profile return NULL");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    p_ue_profile_mac_main_config =  
        &(p_ue_service_profile->radio_res_config.mac_config.mac_main_config);
    if(RRM_PNULL == p_ue_profile_mac_main_config)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ue_profile_mac_main_config return NULL");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    /* SPR14123start */
    row_num             = p_rrm_ue_context->cqi_params.cqi_res_row;
    col_num             = p_rrm_ue_context->cqi_params.cqi_res_col;

    rrm_cellm_mark_cqi_index_free(p_rrm_ue_context->cell_index, row_num, col_num);

    if( RRM_FAILURE == rrm_cellm_get_cqi_resources( p_rrm_ue_context->cell_index,
                &cqi_res_index, &cqi_pmi_config_index,
                &ri_index, sr_config_index,
                &row_num, &col_num, RRM_EICIC_ABS_PRESENT))
    {

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "rrm_cellm_get_cqi_resources returns failure for cqi/ri config index");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    if( RRM_FAILURE == rrm_cellm_get_cqi_resources( p_rrm_ue_context->cell_index,
                &cqi_res_index, &cqi_pmi_config_index_2,
                &ri_index_2, sr_config_index,
                &row_num, &col_num, RRM_EICIC_ABS_NOT_PRESENT))
    {

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "rrm_cellm_get_cqi_resources returns failure for cqi/ri config index");
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /* SPR14123end*/

    p_rrm_ue_context->cqi_params.cqi_pmi_config_index = cqi_pmi_config_index;
    p_rrm_ue_context->cqi_params.cqi_pmi_config_index_2 = cqi_pmi_config_index_2;
    p_rrm_ue_context->cqi_params.ri_index = ri_index;
    p_rrm_ue_context->cqi_params.ri_index_2 = ri_index_2;
    p_rrm_ue_context->cqi_params.cqi_pucch_res_index = cqi_res_index;
    /* SPR_14048_START */
    /*SPR 15663 Fix Start*/
    if(p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index != NO_DRX_PROFILE) 
    {
        find_cqi_periodicity_from_cell_context(p_cell_context, &cqi_periodicity);

        if(RRM_ONE == request_type)
        {    
            find_cqi_offset(cqi_periodicity,p_rrm_ue_context->cqi_params.cqi_pmi_config_index,&cqi_offset);
        }
        else
        {
            find_cqi_offset(cqi_periodicity,p_rrm_ue_context->cqi_params.cqi_pmi_config_index_2,&cqi_offset);
        }    
        long_drx_cycle_value = rrm_convert_drx_sf_in_ms(p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_long_drx_cycle);
        drx_start_offset = cqi_offset % long_drx_cycle_value;
        RRM_MEMCPY(&sr_param_temp, &(p_rrm_ue_context->sr_params), sizeof(rrm_ue_sr_paramas_t));
        sr_config_index = p_rrm_ue_context->sr_params.sr_configuration_index;
        sr_row_num = p_rrm_ue_context->sr_params.sr_res_row;
        sr_col_num = p_rrm_ue_context->sr_params.sr_res_col;
        sr_res_index = p_rrm_ue_context->sr_params.sr_pucch_res_index;
        do
        {
            rrm_calculate_sr_offset(p_rrm_ue_context->cell_index,&sr_offset,sr_config_index);
            sr_config_modification =  sr_offset % long_drx_cycle_value;
            meas_gap_offset = drx_start_offset + long_drx_cycle_value - RRM_SIX;
            p_rrm_ue_context->meas_gap_offset = meas_gap_offset;
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "sr_config_modification(%d), meas_gap_offset(%d), collision_resolved(%d),"
                    "drx_start_offset(%d) drx_cycle(%d) sr_config_index(%d) sr_offset(%d) cqi_offset(%d)",
                    sr_config_modification,meas_gap_offset,collision_resolved,drx_start_offset,long_drx_cycle_value,sr_config_index, sr_offset,cqi_offset);
            if((sr_config_modification < meas_gap_offset) && (sr_offset != cqi_offset))
            {
                /*No need to change the sr_config_index of UE*/
                collision_resolved = RRM_TRUE;
                p_rrm_ue_context->temp_sr_config.sr_pucch_res_index     = sr_res_index;
                p_rrm_ue_context->temp_sr_config.sr_configuration_index = sr_config_index;
                p_rrm_ue_context->temp_sr_config.sr_res_row             = sr_row_num;
                p_rrm_ue_context->temp_sr_config.sr_res_col             = sr_col_num;
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "sr_res_index(%d), sr_config_index(%d), sr_row_num(%d), sr_col_num(%d)",
                        sr_res_index,sr_config_index, sr_row_num, sr_col_num);
                break;
            }
            else
            {
                /*Need to select new sr_config_index
                 * for UE */
                srs_ret_val = rrm_cellm_get_sr_resources(p_rrm_ue_context->cell_index,
                        &sr_res_index, &sr_config_index,
                        &sr_row_num, &sr_col_num, RRM_TRUE);
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "sr_res_index(%d), sr_config_index(%d), sr_row_num(%d), sr_col_num(%d)",
                        sr_res_index,sr_config_index, sr_row_num, sr_col_num);

            }
            /* Coverity ID 87118 Starts */
        }while(srs_ret_val == RRM_SUCCESS);
        /* Coverity ID 87118 Ends */

    } 
    rrc_rrm_ue_reconfig_req.ue_index = p_rrm_ue_context->ue_index;

    rrc_rrm_ue_reconfig_req.bitmask = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.bitmask |= RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask = RRM_ZERO;
    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask |= 
        RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask = RRM_ZERO; 

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask |= 
        RRM_UE_RECONFIG_MAC_CONFIG_PRESENT;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.ue_priority = MAC_UE_PRIORITY;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.dl_num_harq_process 
        = p_rrmc_mac_config->dl_num_harq_process;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.ul_i_mcs = 
        p_admission_control_info->snr_map.
        snr_dep_params.uplink_snr_dep_params.ul_mcs;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.dl_i_mcs = 
        p_admission_control_info->snr_map.
        snr_dep_params.downlink_snr_dep_params.dl_mcs;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.dl_num_harq_process 
        = p_rrmc_mac_config->dl_num_harq_process ;

    if(p_ue_profile_mac_main_config->ul_sch_config.bitmask &
            RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT)
    {
        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
            mac_main_config_extensions.max_ul_harq_tx
            = p_ue_profile_mac_main_config->ul_sch_config.max_ul_harq_tx;
    }

    if(rrm_cellm_get_rrmc_band_width(p_rrm_ue_context->cell_index,&dl_bandwidth) == RRM_SUCCESS)
    {
        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
            mac_main_config_extensions.dl_max_rb = dl_bandwidth;
    }

    if ( RRM_SUCCESS == rrm_select_num_of_layer_for_ue( p_rrm_ue_context,
                &num_of_layer) )
    {
        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            mac_config.mac_main_config_extensions.num_of_layer
            = num_of_layer;
    }

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
        mac_config.mac_main_config_extensions.
        code_book_index = CODE_BOOK_INDEX;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
        mac_main_config_extensions.bitmask |= 
        RRM_MAC_MAN_CONFIG_EXT_DL_INTERFERENCE_INFO_PRESENT;

    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
        bitmask = RRM_ZERO; 

    /*SPR 15663 start*/
    if(collision_resolved == RRM_TRUE)
    {    
        if((p_rrm_ue_context->sr_params.sr_pucch_res_index == sr_res_index)&&
                (p_rrm_ue_context->sr_params.sr_configuration_index == sr_config_index))
        {


            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "SR PARAMS ARE SAME AS BEFORE ,SO NO NEED TO RECONFIGURE");

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "SR PARAMS RECONFIGURATION");
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask |= RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT;
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |= RRC_PHY_SCHEDULING_REQUEST_CONFIG_PRESENT;
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated.\
                scheduling_request_config.bitmask |= RRC_PHY_SCHEDULING_REQUEST_CONFIG_PARAM_PRESENT;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated.\
                scheduling_request_config.scheduling_request_config_param.sr_pucch_resource_index =  p_rrm_ue_context->temp_sr_config.sr_pucch_res_index;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated.\
                scheduling_request_config.scheduling_request_config_param.sr_configuration_index = 
                p_rrm_ue_context->temp_sr_config.sr_configuration_index;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated.scheduling_request_config.\
                scheduling_request_config_param.dsr_trans_max = RRM_DEFINED_DEFAULT_VALUE_FOR_SR_MAX_TRANS_UE_ADMSN;

            p_rrm_ue_context->temp_sr_config.sr_params_bitmask = RRM_ZERO;
            p_rrm_ue_context->temp_sr_config.sr_params_bitmask |= RRM_UE_RECONFIG_SR_PARAMS_PRESENT;
        }    
    }

    if(p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index != NO_DRX_PROFILE) 
    {
        if(p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_offset_val != drx_start_offset)
        {  

            rrm_ue_rac_clear_drx_res( p_rrm_ue_context->cell_index,
                    p_rrm_ue_context->applied_drx_config.
                    curr_applied_drx_config.applied_drx_profile_index,
                    p_rrm_ue_context->applied_drx_config.
                    curr_applied_drx_config.applied_drx_offset_val
                    );
            p_rrm_ue_context->applied_drx_config.
                curr_applied_drx_config.applied_drx_offset_val = drx_start_offset;
            rrm_ue_rac_apply_drx_res ( p_rrm_ue_context->cell_index,
                    p_rrm_ue_context->applied_drx_config.
                    curr_applied_drx_config.applied_drx_profile_index,
                    p_rrm_ue_context->applied_drx_config.
                    curr_applied_drx_config.applied_drx_offset_val
                    );

            p_cell_drx_config_res = rrm_cellm_get_drx_config_resource(p_rrm_ue_context->cell_index);
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.bitmask = RRM_ZERO;
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.bitmask |= RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT; 
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.bitmask |= RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.drx_config.drx_config_type = RRC_DRX_CONFIG_TYPE_SETUP;
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.drx_config.bitmask |= RRC_DRX_CONFIG_PARAM_PRESENT;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.drx_config.drx_config_param.bitmask = RRM_ZERO;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.drx_config.drx_config_param.on_duration_timer =  
                p_cell_drx_config_res->drx_res_arr[p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index].on_duration_timer;
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.drx_config.drx_config_param.drx_inactivity_timer =  
                p_cell_drx_config_res->drx_res_arr[p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index].drx_inactivity_timer;
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.mac_main_config.drx_config.drx_config_param.drx_retransmission_timer =
                p_cell_drx_config_res->drx_res_arr[p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_drx_profile_index].drx_retransmission_timer;

            fill_drx_offset_for_particular_drx_cycle(p_rrm_ue_context->applied_drx_config.curr_applied_drx_config.applied_long_drx_cycle,
                    &rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.\
                    mac_main_config.drx_config.drx_config_param,drx_start_offset);

            p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask = RRM_ZERO;  
            p_rrm_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |= RRM_UE_RECONFIG_PHY_DRX_CONFIG_ROLLBACK_PRESENT;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "DRX OFFSET IS SAME AS BEFORE ,SO NO NEED TO RECONFIGURE");
        }    
    }
    /*SPR 15663 end*/
    /* SPR 14285 start */
    if((RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED == p_ue_service_profile->radio_res_config.
                physical_config_dedicated.cqi_reporting.rrm_cqi_reporting_mode_configured) || 
            ( RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED == p_ue_service_profile->
              radio_res_config.physical_config_dedicated.cqi_reporting.rrm_cqi_reporting_mode_configured)) 
    {
        /* SPR 14419 start */
        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |= 
            RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT; 

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.bitmask = RRM_ZERO; 

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.bitmask |= 
            RRC_PHY_CQI_REPORT_CONFIG_R10_CSI_SUBFRAME_PATTERN_CONFIG_R10_PRESENT; 
        /* SPR 14419 end */

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask |= 
            RRM_UE_RECONFIG_MEAS_SUBFRAME_PATTERN_PCELL_R10_PRESENT;

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.
            cqi_report_config_r10.nomPDSCH_rs_epre_offset = 
            p_ue_service_profile->radio_res_config.
            physical_config_dedicated.cqi_reporting.
            nom_pdsch_rs_epre_offset ;


        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.bitmask |= 
            RRC_PHY_CQI_REPORT_CONFIG_R10_REPORT_PERIODIC_R10_PRESENT; 

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.bitmask |= 
            RRC_PHY_CQI_REPORT_CONFIG_R10_PMI_RI_REPORT_R9_PRESENT; 

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_pmi_ri_report_r10 =  
            PMI_RI_REPORT_R9_SETUP;

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_periodic_r10.bitmask = RRM_ZERO;    

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_periodic_r10.request_type = RRM_ONE;    

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_periodic_r10.bitmask |= RRC_PHY_CQI_REPORT_PERIODIC_R10SETUP_PRESENT;    

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_periodic_r10.setup.cqi_pucch_resource_index = 
            /* SPR14123start*/
            cqi_res_index;
        /* SPR14123end*/

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_periodic_r10.setup.bitmask = RRM_ZERO;    

        if(RRM_ONE == request_type )
        {
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.cqi_pmi_config_index = 
                p_rrm_ue_context->cqi_params.cqi_pmi_config_index;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.ri_config_index= 
                p_rrm_ue_context->cqi_params.ri_index;

        }
        else
        {
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.cqi_pmi_config_index = 
                p_rrm_ue_context->cqi_params.cqi_pmi_config_index_2;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.ri_config_index= 
                p_rrm_ue_context->cqi_params.ri_index_2;


        }

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_periodic_r10.setup.cqi_format_ind_periodic.bitmask = RRM_ZERO; 

        rrm_rrc_ue_fill_periodic_sub_wide_band (&(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                    rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                    cqi_report_periodic_r10.setup),
                p_rrm_ue_context, p_ue_service_profile->radio_res_config.physical_config_dedicated.
                cqi_reporting.rrm_ul_dl_freq_selective_sched, &ret_val);

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_periodic_r10.setup.bitmask |= RRC_CQI_REPORT_PERIODIC_R10_SETUP_RI_CONFIG_INDEX_PRESENT;    

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_periodic_r10.setup.simultaneous_ack_nack_cqi = 
            p_ue_service_profile->radio_res_config.physical_config_dedicated.
            cqi_reporting.cqi_reporting_periodic.
            cqi_reporting_periodic_param.simultaneous_ack_nack_and_cqi; 


        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            csi_subframePattern_r10.bitmask = RRM_ZERO; 
        /* SPR 14419 start */
        /* SSI_CHANGES_START */
        if(request_type == RRM_ONE)
        {

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.bitmask |= RRC_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_PRESENT;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.csi_config_index.request_type = request_type;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.csi_config_index.bitmask = RRM_ZERO;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.csi_config_index.bitmask |= 
                RRC_PHY_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_SETUP_PRESENT;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.csi_config_index.setup.bitmask = RRM_ZERO;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.csi_config_index.setup.bitmask |= 
                RRC_PHY_CQI_PERIODIC_R10_SETUP_CSI_RI_CONFIG_INDEX2_PRESENT;

            /* SPR14123start*/
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.csi_config_index.setup.cqi_pmi_config_index2 =
                p_rrm_ue_context->cqi_params.cqi_pmi_config_index_2;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                cqi_report_periodic_r10.setup.csi_config_index.setup.ri_config_index2=
                p_rrm_ue_context->cqi_params.ri_index_2;
            /* SPR14123end*/

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                csi_subframePattern_r10.bitmask |= 
                RRC_PHY_CQI_REPORT_CONFIG_R10_CSI_SUBFRAMEPATTERN_CONFIG_SETUP;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                csi_subframePattern_r10.request_type = RRM_ONE;  

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                csi_meas_subframe_set1_r10.bitmask = RRM_ZERO;  

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                csi_meas_subframe_set2_r10.bitmask = RRM_ZERO;  


            /* cov_fix_69557_ */       
#ifndef TDD_MODE_FLAG
            /* cov_fix_69557_ */       
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                csi_meas_subframe_set1_r10.bitmask |= 
                RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10;  

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                csi_meas_subframe_set2_r10.bitmask |= 
                RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10;  

            RRM_MEMCPY(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                    rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                    csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                    csi_meas_subframe_set1_r10.subframe_pattern_fdd_r10.data,
                    common_abs_pattern1,MAX_SUBFRAME_PATTERN_FDD); 	

            RRM_MEMCPY(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                    rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                    csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                    csi_meas_subframe_set2_r10.subframe_pattern_fdd_r10.data,
                    common_abs_pattern2,MAX_SUBFRAME_PATTERN_FDD); 	
#else
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                csi_meas_subframe_set1_r10.bitmask |= 
                RRC_PHY_MEAS_SUBFRAME_PATTERN_TDD_R10;  

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                csi_meas_subframe_set2_r10.bitmask |= 
                RRC_PHY_MEAS_SUBFRAME_PATTERN_TDD_R10;  

            switch(abs_size)
            {
                case RRM_MAX_ABS_PATTERN_BYTE_TDD_0 :
                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                        rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                        csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                        csi_meas_subframe_set1_r10.subframe_pattern_tdd_r10.bitmask |=
                        RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG0_R10;

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                        rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                        csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                        csi_meas_subframe_set2_r10.subframe_pattern_tdd_r10.bitmask |=
                        RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG0_R10;

                    RRM_MEMCPY(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                            csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                            csi_meas_subframe_set1_r10.subframe_pattern_tdd_r10.subframe_config0_r10,
                            common_abs_pattern1,abs_size);
                    rrm_copy_tdd_bits(abs_size,rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                            csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                            csi_meas_subframe_set1_r10.subframe_pattern_tdd_r10.subframe_config0_r10);
                    RRM_MEMCPY(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                            csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                            csi_meas_subframe_set2_r10.subframe_pattern_tdd_r10.subframe_config0_r10,
                            common_abs_pattern2,abs_size);
                    rrm_copy_tdd_bits(abs_size,rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                            csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                            csi_meas_subframe_set2_r10.subframe_pattern_tdd_r10.subframe_config0_r10);
                    break;
                case RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 :

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                        rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                        csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                        csi_meas_subframe_set1_r10.subframe_pattern_tdd_r10.bitmask |=
                        RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG1_5_R10;

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                        rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                        csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                        csi_meas_subframe_set2_r10.subframe_pattern_tdd_r10.bitmask |=
                        RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG1_5_R10;

                    /*CID:83375 start*/
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size,common_abs_pattern1,
                            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                            csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.csi_meas_subframe_set1_r10.subframe_pattern_tdd_r10.
                            subframe_config1_5_r10);
                    /*CID:83375 end*/
                    /*CID:83375 start*/
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size,common_abs_pattern2,
                            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                            csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.csi_meas_subframe_set2_r10.subframe_pattern_tdd_r10.
                            subframe_config1_5_r10);
                    /*CID:83375 end*/
                    break;
                case RRM_MAX_ABS_PATTERN_BYTE_TDD_6 :

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                        rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                        csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                        csi_meas_subframe_set1_r10.subframe_pattern_tdd_r10.bitmask |=
                        RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG6_R10;

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                        rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                        csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.
                        csi_meas_subframe_set2_r10.subframe_pattern_tdd_r10.bitmask |=
                        RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG6_R10;
                    /*CID:83373 start*/
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size,common_abs_pattern1,
                            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                            csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.csi_meas_subframe_set1_r10.
                            subframe_pattern_tdd_r10.subframe_config6_r10);
                    /*CID:83373 end*/
                    /*CID:83374 start*/
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size,common_abs_pattern2,
                            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                            csi_subframePattern_r10.csi_subframe_pattern_config_r10_setup.csi_meas_subframe_set2_r10.subframe_pattern_tdd_r10.
                            subframe_config6_r10);
                    /*CID:83374 end*/
                    break;
                default :
                    RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR,
                            "Invalid TDD configuration[%u] has been given by OAM",
                            abs_size);
            }
#endif

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                meas_subframe_pattern_r10_setup.bitmask = RRM_ZERO;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
                mac_main_config_extensions.dl_interference_info = RRM_ONE;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                bitmask |= MEAS_SUBFRAME_PATTERN_PCELL_R10_SETUP_PRESENT; 

            /* cov_fix_69557_ */       
#ifndef TDD_MODE_FLAG
            /* cov_fix_69557_ */       
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                meas_subframe_pattern_r10_setup.bitmask |= RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10;

            /* SPR 19726 Fix Start */
            /* SPR 14098 start */
            RRM_MEMCPY(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                    rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                    subframe_pattern_fdd_r10.data, 
                    meas_abs_pattern, MAX_SUBFRAME_PATTERN_FDD);
            /* SPR 19726 Fix Stop */
#else
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                meas_subframe_pattern_r10_setup.bitmask |= RRC_PHY_MEAS_SUBFRAME_PATTERN_TDD_R10;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                meas_subframe_pattern_r10_setup.subframe_pattern_tdd_r10.bitmask = RRM_ZERO;

            switch(abs_size)
            {
                /* SPR 19726 Fix Start */
                case RRM_MAX_ABS_PATTERN_BYTE_TDD_0 :

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                        meas_subframe_pattern_r10_setup.subframe_pattern_tdd_r10.bitmask |= RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG0_R10;

                    RRM_MEMCPY(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                            subframe_pattern_tdd_r10.subframe_config0_r10,
                            meas_abs_pattern, abs_size);
                    rrm_copy_tdd_bits(abs_size,rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                            subframe_pattern_tdd_r10.subframe_config0_r10);
                    break;
                case RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 :

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                        meas_subframe_pattern_r10_setup.subframe_pattern_tdd_r10.bitmask |=
                        RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG1_5_R10;
                    /*CID:83372 start*/
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size,meas_abs_pattern,
                            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                            subframe_pattern_tdd_r10.subframe_config1_5_r10);
                    /*CID:83372 end*/

                    break;
                case RRM_MAX_ABS_PATTERN_BYTE_TDD_6 :

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                        meas_subframe_pattern_r10_setup.subframe_pattern_tdd_r10.bitmask |= RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG6_R10;
                    /*CID:83371 start*/
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size,meas_abs_pattern,rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.subframe_pattern_tdd_r10.subframe_config6_r10);
                    /*CID:83371 end*/
                    /* SPR 19726 Fix Stop */
                    break;
                default :
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                            " Invalid TDD configuration[%u] has been given by OAM",
                            abs_size);
            }
            /* SPR 14098 end*/
#endif
        }

        /* SSI_CHANGES_END */
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    " request type : RELEASE for victim UE  : \n ");
            /* Use to remove the CSI subframe set 2 */   
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                csi_subframePattern_r10.request_type = request_type ;

            /* Bug 3961 Fix Start */
	    //Code Removed
	    /* Bug 3961 Fix End */

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
                mac_main_config_extensions.dl_interference_info = RRM_ZERO;
        }


    }
    else if((RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED == p_ue_service_profile->radio_res_config.
                physical_config_dedicated.cqi_reporting.rrm_cqi_reporting_mode_configured))

    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                " CQI Mode : RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED for victim : \n ");

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |= 
            RRC_PHY_CQI_REPORT_CONFIG_R10_REPORT_APERIODIC_R10_PRESENT; 

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_aperiodic_r10.bitmask = RRM_ZERO; 

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
            rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
            cqi_report_aperiodic_r10.request_type =
            request_type;

            /*SPR 22464 Fix Start*/
        if(RRM_REL10 <= p_rrm_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.access_stratum_release)
            /*SPR 22464 Fix Stop*/
        {
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |=
                RRC_PHY_ANTENNA_INFO_R10_PRESENT;
        }
        else
        {
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                rrc_rrm_ue_reconfig_physical_config_dedicated.bitmask |=
                RRC_PHY_ANTENNA_INFORMATION_PRESENT;
        }
        /* R-10 Changes : End */
        rrm_rrc_ue_adm_resp_fill_antenna_information( p_rrm_ue_context,
                &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                    rrc_rrm_ue_reconfig_physical_config_dedicated));

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.presence_bitmask |= 
            RRM_UE_RECONFIG_MEAS_SUBFRAME_PATTERN_PCELL_R10_PRESENT;

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
            meas_subframe_pattern_r10_setup.bitmask = RRM_ZERO;

        if(RRM_ONE == request_type)
        {

            p_rrm_tm_mode_additional_info = rrm_cm_get_mrrm_tm_mode_additional_info(p_rrm_ue_context->cell_index);
            if (RRM_SUCCESS == rrm_assign_aperiodic_mode_from_tm_mode_r10(
                        p_rrm_ue_context,
                        p_ue_service_profile->radio_res_config.physical_config_dedicated.
                        cqi_reporting.rrm_ul_dl_freq_selective_sched,
                        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                        rrc_rrm_ue_reconfig_physical_config_dedicated.
                        antenna_info_r10.explicit_value.transmission_mode,
                        &aperiodic_mode,
                        p_rrm_tm_mode_additional_info))
            {

                rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                    rrc_rrm_ue_reconfig_physical_config_dedicated.cqi_report_config_r10.
                    cqi_report_aperiodic_r10.setup.cqi_reporting_mode_aperiodic = aperiodic_mode;

                rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                    rrc_rrm_ue_reconfig_physical_config_dedicated.
                    cqi_report_config_r10.cqi_report_aperiodic_r10.
                    setup.bitmask = RRM_ZERO;

                if((p_rrm_ue_context->ue_scell_add_params.count > RRM_ZERO ) &&
                        (p_rrm_ue_context->ue_scell_add_params.count < RRM_MAX_SCELL))
                {
                    if(RRM_FAILURE == rrm_fill_aperiodic_csi_trigger
                            ( p_rrm_ue_context,
                              &(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                                  rrc_rrm_ue_reconfig_physical_config_dedicated.
                                  cqi_report_config_r10
                                  .cqi_report_aperiodic_r10.setup.aperiodic_csi_trigger)))

                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                                "Failed to fill the aperiodic_csi_trigger for Pcell!!!");
                        RRM_UT_TRACE_EXIT();
                        return( RRM_FAILURE );
                    }
                    else
                    {
                        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_rrm_ue_reconfig_physical_config_dedicated.
                            cqi_report_config_r10.cqi_report_aperiodic_r10.
                            setup.bitmask |=
                            RRC_CQI_REPORT_APERIODIC_R10_SETUP_APERIODIC_CSI_TRIGGER_PRESENT;

                    }
                }

            }

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                bitmask |= MEAS_SUBFRAME_PATTERN_PCELL_R10_SETUP_PRESENT; 
            /* cov_fix_69557_ */       
#ifndef TDD_MODE_FLAG
            /* cov_fix_69557_ */       
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                meas_subframe_pattern_r10_setup.bitmask |= RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10;

            /* SPR 14098 start */
            /* SPR 19726 Fix Start */
            RRM_MEMCPY(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                    rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                    subframe_pattern_fdd_r10.data, 
                    meas_abs_pattern, MAX_SUBFRAME_PATTERN_FDD);
            /* SPR 19726 Fix Stop */
#else
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                meas_subframe_pattern_r10_setup.bitmask |= RRC_PHY_MEAS_SUBFRAME_PATTERN_TDD_R10;

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                meas_subframe_pattern_r10_setup.subframe_pattern_tdd_r10.bitmask = RRM_ZERO;

            switch(abs_size)
            {
                /* SPR 19726 Fix Start */
                case RRM_MAX_ABS_PATTERN_BYTE_TDD_0 :

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                        meas_subframe_pattern_r10_setup.subframe_pattern_tdd_r10.bitmask |= RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG0_R10;

                    RRM_MEMCPY(rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                            subframe_pattern_tdd_r10.subframe_config0_r10,
                            meas_abs_pattern , abs_size);
                    rrm_copy_tdd_bits(abs_size,rrc_rrm_ue_reconfig_req.radio_resource_reconfig.
                            rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                            subframe_pattern_tdd_r10.subframe_config0_r10);
                    break;
                case RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 :

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                        meas_subframe_pattern_r10_setup.subframe_pattern_tdd_r10.bitmask |=
                        RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG1_5_R10;
                    /*CID:83372 start*/
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size,meas_abs_pattern,
                            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                            subframe_pattern_tdd_r10.subframe_config1_5_r10);
                    /*CID:83372 end*/

                    break;
                case RRM_MAX_ABS_PATTERN_BYTE_TDD_6 :

                    rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.
                        meas_subframe_pattern_r10_setup.subframe_pattern_tdd_r10.bitmask |= RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG6_R10;

                    /*CID:83371 start*/
                    rrm_copy_tdd_bits_from_src_abs_to_dest(abs_size,meas_abs_pattern,
                            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.rrc_meas_subframe_pattern_pcell_r10.meas_subframe_pattern_r10_setup.
                            subframe_pattern_tdd_r10.subframe_config6_r10);
                    /*CID:83371 end*/
                    break;
                    /* SPR 19726 Fix Stop */
                default :
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                            " Invalid TDD configuration[%u] has been given by OAM",
                            abs_size);
            }
            /* SPR 14098 end*/
#endif
            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
                mac_main_config_extensions.dl_interference_info = RRM_ONE;


        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    " request type : RELEASE for victim UE  : \n ");

	    /* Bug 3961 Fix Start */
	    //Code Removed
	    /* Bug 3961 Fix End */

            rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
                mac_main_config_extensions.dl_interference_info = RRM_ZERO;

        }

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                " CQI Mode : RRM_DISABLE_CQI_REPORTING for victim : \n ");

        rrc_rrm_ue_reconfig_req.radio_resource_reconfig.mac_config.
            mac_main_config_extensions.dl_interference_info = request_type;
    }

    /* SPR 14419 end */

    /* SPR 14098 start */
    if(RRM_UE_ERB_NULL == p_rrm_ue_context->current_procedure.state)
    {

        ret_val = rrm_il_send_rrc_rrm_ue_reconfig_req(&rrc_rrm_ue_reconfig_req,
                RRM_MODULE_ID,
                RRC_MODULE_ID,
                transaction_id,
                p_rrm_ue_context->cell_index);
        if(RRM_SUCCESS == ret_val)
        {
            /*set the UE sub state*/
            /* bug_13913_start */
            p_rrm_ue_context->current_procedure.state = RRM_UE_RECONFIG_ONGOING;
            /* bug_13913_end */
            /*SPR 20461 START*/
            if(request_type == RRM_ONE)
            {    
              p_rrm_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM;
            }
            else
            {
              p_rrm_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_NON_VICTIM;   
            }
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                "Setting victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM");
            /*SPR 20461 END*/
            /* SPR 14165 start */
            p_rrm_ue_context->rrm_ue_eicic_info.rrm_ue_eicic_reconfig_ongoing= RRM_TRUE;
            /* SPR 14165 end */
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                    "Unable to send UE reconfig request to RRC.");
        }
    }
    else
    {
        /*enqueue ue_reconfig*/
        rrm_ue_procedure_queue_t    proc_queue;
        /* Coverity ID 85873 Starts */
        RRM_MEMSET(&proc_queue, RRM_ZERO, sizeof(rrm_ue_procedure_queue_t));
        /* Coverity ID 85873 Ends */
        proc_queue.api_id = RRC_RRM_UE_RECONFIG_REQ;
        proc_queue.p_proc_data =
            (rrc_rrm_ue_reconfig_req_t *)rrm_mem_get
            (sizeof(rrc_rrm_ue_reconfig_req_t));

        if(RRM_PNULL == proc_queue.p_proc_data)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "rrm_build_and_send_ue_reconfig_req: Mem allocation failed");
            return RRM_FAILURE;
        }

        RRM_MEMCPY((rrc_rrm_ue_reconfig_req_t*)proc_queue.
                p_proc_data,&rrc_rrm_ue_reconfig_req,
                sizeof(rrc_rrm_ue_reconfig_req_t));
        /**Enqueue ue reconfig request */
        /*SPR 18241 START*/
        rrm_ue_mgr_enqueue_req( &proc_queue,p_rrm_ue_context,RRM_FALSE);
        /*SPR 18241 END*/
        /*Coverity 93991 Fix Start*/
        RRM_MEM_FREE(proc_queue.p_proc_data);
        proc_queue.p_proc_data = PNULL;
        /*Coverity 93991 Fix End*/
    }
    /* SPR 14098 end */

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/* SPR14048end */

/* bug_13909_end */
/****************************************************************************
 * Function Name  : rrm_uem_send_l2_ue_reconfig_for_victim_ue 
 * Inputs    	  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 *                  victim_ue_node_t *p_victim_head_node : victim ue list head
 *                  victim_ue_count : percentage basis restriced victim UEs
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE 
 * Description    : Perform action based on the inputs received from Cell Manager 
 ****************************************************************************/
rrm_return_et
    rrm_uem_send_l2_ue_reconfig_for_victim_ue
(
 rrm_ue_global_context_t     *p_rrm_glb_ctxt,
 rrm_ue_index_t              *ue_index_list,
 U8                          ue_update_count,
 rrm_cell_index_t            cell_index
 )
{
    rrm_return_et       ret_val = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();
    U8      dl_interference_info = RRM_ONE; /* for marking UE's as victim at L2 */

    RRM_ASSERT(RRM_PNULL != p_rrm_glb_ctxt);

    if(MAC_UE_RECONF_NOT_ONGOING  == (rrm_get_mac_ue_reconfig_mutex( cell_index )) )
    {
        /* Sending ue reconfig request on percentage basis restricion */ 
        /* prepare_the mac  ue reconfig request */
        ret_val = build_and_send_l2_ue_reconfig_req_for_victim(cell_index,ue_index_list, ue_update_count, dl_interference_info);
        if(RRM_SUCCESS == ret_val)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Successfully send [UE:%d] reconfig req to  MAC for victim UEs", 
                    p_rrm_glb_ctxt->p_ue_context->ue_index); 

            rrm_set_mac_ue_reconfig_mutex(cell_index, W_FOR_MAC_UE_RECONF_CNF_FOR_EICIC);

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "Unable to send the batch for %d UEs Mac UE reconfig request to L2", ue_update_count);
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*****************************************************************************
 * Array Name     : rrm_check_absPattern_is_null 
 * Inputs         : p_abs_pattern
 * Outputs        : TRUE/FALSE
 * Returns        : None
 * Description    : This function will check abs pattern is null or not.
 ****************************************************************************/
/*review comments changes end*/   
rrm_bool_et
rrm_check_absPattern_is_null
(
  U8 *p_abs_pattern
)
{

    U8 count = RRM_ZERO;
    rrm_bool_et abs_is_null = RRM_TRUE;
    RRM_UT_TRACE_ENTER();

    for (count = RRM_ZERO; count < RRM_MAX_PATTERN_BYTE ; count++)
    {

        if(p_abs_pattern[count] != RRM_ZERO)
        {

            abs_is_null = RRM_FALSE;
            break;
        }
    }

    RRM_UT_TRACE_EXIT();
    return abs_is_null;
    
}


/*SPR 15362 start*/
/*code deleted for SPR 15155*/
/*SPR 15362 end*/
/******************************************************************************
 *   FUNCTION NAME: rrm_calculate_victim_ue 
 *   DESCRIPTION:   This function calculate victim as per reprted DLSINR from L2
 *   INPUT:         p_ue_glbl_ctxt:ue context      
 *   OUTPUT:        NONE
 *   RETURNS:       RRM_SUCCESS/RRM_FAILURE 
 ***********************************************************************************/
void
    rrm_calculate_victim_ue
(
 rrm_ue_global_context_t *p_ue_glbl_ctxt,
 rrm_cell_context_t *p_cell_ctxt
 )
{

    U32 dl_sinr = RRM_ZERO;
    rrm_ue_context_t *p_ue_context = RRM_PNULL;
    U32 dlsinrCW0 = RRM_ZERO;
    U32 dlsinrCW1 = RRM_ZERO;
    U32 dlsinrSubset2CW0 = RRM_ZERO;
    U32 dlsinrSubset2CW1 = RRM_ZERO;
    U32 thresholdlowsinr = RRM_ZERO;
    U32 thresholdhighsinr = RRM_ZERO;
    /*SPR 15362 start*/ 
    transmission_mode_ue_service_profile_et transmission_mode = TRANSMISSION_MODE_TM1;
    /*SPR 15362 end*/ 
    /*eICIC: Bug 3812 Code changes Start*/
    /*SPR 20461 START*/
    rrm_victim_state_et	prev_ue_state = RRM_UE_NO_VICTIM_STATE;
    /*SPR 20461 END*/
    /*eICIC: Bug 3812 Code changes End*/

    RRM_UT_TRACE_ENTER();

    p_ue_context = p_ue_glbl_ctxt->p_ue_context;

    dlsinrCW0 = p_ue_context->ue_avg_stats.downlinkSINRValueCW0; 
    dlsinrCW1 = p_ue_context->ue_avg_stats.downlinkSINRValueCW1; 

    thresholdlowsinr = p_cell_ctxt->operator_info.eicic_info.dl_sinr_threshold_low_mark; 
    /* SPR 14122 start */
    thresholdhighsinr = p_cell_ctxt->operator_info.eicic_info.dl_sinr_threshold_high_mark; 
    /* SPR 14122 end */

    /*SPR 15362 start*/
            /*SPR 22464 Fix Start*/
    if (RRM_REL10 <= p_ue_context->ue_capability_params.\
            rrm_eutra_radio_capability_info.\
            eutra_radio_capability_info_def.\
            access_stratum_release)
            /*SPR 22464 Fix Stop*/
    {
        transmission_mode = (transmission_mode_ue_service_profile_et)
            p_ue_context->ue_phy_config_information.\
            ue_antenna_info_r10.\
            transmission_mode;

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "REL10 UE:Transmission mode is [%d]", 
                transmission_mode);
    }
    else
    {
        transmission_mode = (transmission_mode_ue_service_profile_et)
            p_ue_context->ue_phy_config_information.\
            ue_antenna_information.\
            transmission_mode; 

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "REL8/9 UE:Transmission mode is [%d]", 
                transmission_mode);
    }
    /*SPR 15362 end*/

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "dlsinrCW0[%d], dlsinrCW1[%d],thresholdlowsinr[%d],thresholdhighsinr[%d]",
            dlsinrCW0, 
            dlsinrCW1, 
            thresholdlowsinr, 
            thresholdhighsinr);

    /*SPR 20461 START*/
    prev_ue_state = p_ue_context->rrm_ue_eicic_info.victim_ue;
    /*SPR 20461 END*/
            /*SPR 22464 Fix Start*/
    if((RRM_MAC_UE_PERIODIC_CSI_SUBFRAME_SET2_REPORT_PRESENCE_BITMASK & p_ue_context->ue_avg_stats.bitMask) &&
            (RRM_UE_VICTIM_STATE == p_ue_context->rrm_ue_eicic_info.victim_ue) &&
            (RRM_REL10 <= p_ue_glbl_ctxt->p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
             eutra_radio_capability_info_def.access_stratum_release)) 
            /*SPR 22464 Fix Stop*/
        /* - SPR 20078 */

    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                " Csi set2 report is present for [UE:%d] ", p_ue_context->ue_index);
        /*SPR 15362 start*/
        /*SPR 15444 fix start */
        /** storing average stats for SINR received from MAC for release 10 UE */
        /* + SPR 20078 */
        dlsinrSubset2CW0 = p_ue_context->ue_avg_stats.csiSubframeSet2Report.downlinkSINRValueCW0_2; 
        dlsinrSubset2CW1 = p_ue_context->ue_avg_stats.csiSubframeSet2Report.downlinkSINRValueCW1_2; 
        /* - SPR 20078 */
        /*SPR 18547 START*/
        if ((RRM_ZERO != dlsinrSubset2CW0) || (RRM_ZERO != dlsinrSubset2CW1))
        {
            /*SPR 18547 END*/

            /*SPR 15444 fix end */
            if(TRANSMISSION_MODE_TM1 == transmission_mode)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Transmission mode is TM1 dlsinrSubset2CW0[%d] ",dlsinrSubset2CW0);
                if (dlsinrSubset2CW0 > thresholdhighsinr)
                {
                    p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Transmission mode is NOT TM1 ");

                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "dlsinrSubset2CW0[%d],dlsinrSubset2CW1[%d] ",
                        dlsinrSubset2CW0, 
                        dlsinrSubset2CW1);
                /*code deleted*/
                /* If CSI Set 2 Report is present */
                if(dlsinrSubset2CW0 > dlsinrSubset2CW1)       
                {
                    if(dlsinrSubset2CW0 > thresholdhighsinr)
                    {
                        p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
                    }
                }
                else if(dlsinrSubset2CW1 > thresholdhighsinr)
                {
                    p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
                }
            }
        }
        /*SPR 15444 fix start */
        else
        {
            RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_WARNING,
                    "dlsinrSubset2CW0 [%d] and dlsinrSubset2CW1 [%d] both the"
                    "average MAC stats received zero no need to calculate UE as victim",
                    dlsinrSubset2CW0,dlsinrSubset2CW1);
            p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
        }
        /*SPR 15444 fix end*/
        /*SPR 15362 end*/
    }
            /*SPR 22464 Fix Start*/
    else if((RRM_UE_VICTIM_STATE == p_ue_context->rrm_ue_eicic_info.victim_ue) &&
            (RRM_REL10 <= p_ue_glbl_ctxt->p_ue_context->ue_capability_params.\
             rrm_eutra_radio_capability_info.\
             eutra_radio_capability_info_def.access_stratum_release))
            /*SPR 22464 Fix Stop*/
    {

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                " Csi set1 report is present for REL 10 victim [UE:%d] ", p_ue_context->ue_index);

        RRM_UT_TRACE_EXIT();
        return;
    }

    else if((RRM_UE_VICTIM_STATE == p_ue_context->rrm_ue_eicic_info.victim_ue) && 
            (RRM_REL10 != p_ue_glbl_ctxt->p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
             eutra_radio_capability_info_def.access_stratum_release))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                " Csi set1 report is present for REL 8/9 victim [UE:%d] ", p_ue_context->ue_index);
        /*SPR 15362 start*/
        /*SPR fix 15444 fix start */
        if((RRM_ZERO != dlsinrCW0) && (RRM_ZERO != dlsinrCW1))
        {
            /*SPR fix 15444 fix end */
            if (TRANSMISSION_MODE_TM1 == transmission_mode)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        " Transmision Mode TM1 considering dlsinrCW0 [%d] ", dlsinrCW0);
                if(dlsinrCW0 > thresholdhighsinr)
                {
                    p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
                }
            }
            else 
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Transmission mode is NOT TM1 ");
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "dlsinrCW0[%d],dlsinrCW1[%d] ",
                        dlsinrCW0, dlsinrCW1 );
                if(dlsinrCW0 > dlsinrCW1 )      
                {     
                    if(dlsinrCW0 > thresholdhighsinr)
                    {     
                        p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
                    }     
                }     
                else if(dlsinrCW1 > thresholdhighsinr)
                {     
                    p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
                }
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_WARNING,
                    "dlsinrCW0[%d] and dlsinrCW1[%d] both the"
                    "average MAC stats received zero no need to calculate UE as victim",
                    dlsinrCW0,dlsinrCW1);
            p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
        }
        /*SPR 15362 end*/
    }
    /* SPR 14285 end*/
    else 
    {
        /*eICIC: Bug 3812 Code changes Start*/
        /*SPR 20461 START*/
        /*code moved*/
        /*SPR 20461 START*/
        /*eICIC: Bug 3812 Code changes End*/
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                " updating victim UE list for [UE:%d] ", p_ue_context->ue_index);
        /*SPR 15362 start*/
        /*SPR fix 15444 fix start */
        /*SPR 18547 START*/
        if((RRM_ZERO != dlsinrCW0) || (RRM_ZERO != dlsinrCW1))
            /*SPR 18547 END*/
        {
            if (TRANSMISSION_MODE_TM1 == transmission_mode)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        " Transmision Mode TM1 considering sinrCW0 [%d] ", dlsinrCW0);
                if(dlsinrCW0 < thresholdlowsinr)
                {
                    dl_sinr = dlsinrCW0;
                    /* SPR Fix 15476 start */
                    if(RRM_UE_VICTIM_STATE != p_ue_context->rrm_ue_eicic_info.victim_ue)
                    {
                        /* SPR Fix 15476 end*/
                        p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_VICTIM_CANDIDATE;
                    }
                    /* SPR Fix 15476 start */
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "As the current state of UE is victim so not moving"
                                "state to RRM_UE_VICTIM_CANDIDATE");
                    }
                    /* SPR Fix 15476 end*/
                }

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        " dlsinrCW0 [%d] , dlsinrCW1[%d]", dlsinrCW0,dlsinrCW1);
                if(dlsinrCW0 > dlsinrCW1 )       
                {
                    dl_sinr = dlsinrCW0;
                    if(dlsinrCW0 < thresholdlowsinr)    
                    {
                        /* SPR Fix 15476 start */
                        if(RRM_UE_VICTIM_STATE != p_ue_context->rrm_ue_eicic_info.victim_ue)
                        {
                            /* SPR Fix 15476 end*/
                            /* Add UE into Victim List */
                            p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_VICTIM_CANDIDATE;
                        }
                        /* SPR Fix 15476 start */
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "As the current state of UE is victim so not moving"
                                    "state to RRM_UE_VICTIM_CANDIDATE");
                        }
                        /* SPR Fix 15476 end*/
                    }
                    else if(dlsinrCW0 > thresholdhighsinr)
                    {
                        p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
                    }
                }
                else if(dlsinrCW1 < thresholdlowsinr)
                {
                    dl_sinr = dlsinrCW1;
                    /* Add UE into Victim List */
                    /* SPR Fix 15476 start */
                    if(RRM_UE_VICTIM_STATE != p_ue_context->rrm_ue_eicic_info.victim_ue)
                    {
                        /* SPR Fix 15476 end*/
                        /* Add UE into Victim List */
                        p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_VICTIM_CANDIDATE;
                    }
                    /* SPR Fix 15476 start */
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "As the current state of UE is victim so not moving"
                                "state to RRM_UE_VICTIM_CANDIDATE");
                    }
                    /* SPR Fix 15476 end*/
                }        
                else if(dlsinrCW1 > thresholdhighsinr)
                {
                    p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
                }
            }
            /*SPR 15362 end*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_WARNING,
                    "dlsinrCW0[%d] and dlsinrCW1[%d] both the"
                    "average MAC stats received zero no need to calculate UE as victim",
                    dlsinrCW0,dlsinrCW1);
            p_ue_context->rrm_ue_eicic_info.victim_ue = RRM_UE_NO_VICTIM_STATE;
        }

    }
    /* updating victime ue list */
    /*SPR 20461 START*/
    rrm_update_victim_ue_list(p_ue_glbl_ctxt, dl_sinr,prev_ue_state);
    /*SPR 20461 END*/
    RRM_UT_TRACE_EXIT();
}

/*SPR 20461 START*/
/******************************************************************************
 *   FUNCTION NAME: rrm_update_victim_ue_list 
 *   DESCRIPTION:   This function updates the victime ue list
 *   INPUT:         p_ue_glbl_ctxt: ue context,dl_sinr,prev_ue_state      
 *   OUTPUT:        NONE
 *   RETURNS:       RRM_SUCCESS/RRM_FAILURE 
 ******************************************************************************/
/*SPR 20461 END*/
rrm_return_et 
rrm_update_victim_ue_list(
        rrm_ue_global_context_t *p_ue_glbl_ctxt,
        /*SPR 20461 START*/
        U32 dl_sinr,
        rrm_victim_state_et	prev_ue_state
        /*SPR 20461 END*/
        )
{
    RRM_UT_TRACE_ENTER();    

    rrm_cell_index_t cell_index = RRM_ZERO;
    rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
    /* cov_fix_69599 */
    rrm_return_et ret_val = RRM_FAILURE;
    /* cov_fix_69599 */
    rrm_bool_et x2_up_flag = RRM_FALSE;
    YLIST victim_ue_list;
    rrm_ue_index_t  ue_index_list[MAX_NUM_OF_UE]  = {RRM_ZERO};
    victim_ue_node_t *p_victim_node = RRM_PNULL;
    victim_ue_node_t *p_new_victim_node= RRM_PNULL;

    /*SPR Fix 15664 Start */
    rrm_meas_config_info_t *p_cell_meas_config_info =RRM_NULL;
    U8                  meas_gap_offset_stored = RRM_ZERO;
    U8                  final_changed_meas_gap_offset = RRM_ZERO;
    U8                  abs_pattern_bianry[RRM_FORTY] = {RRM_ZERO};
    U16                 transaction_id                 = RRM_ZERO;
    rrc_rrm_meas_config_req_t       *p_rrc_rrm_meas_config_req = RRM_PNULL;
    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*)
        rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t)); 
    if (RRM_PNULL == p_rrc_rrm_meas_config_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    /*SPR Fix 15664 End*/

    ylInit(&victim_ue_list);
    if(p_ue_glbl_ctxt->p_ue_context)
    {
        cell_index = p_ue_glbl_ctxt->p_ue_context->cell_index;
        victim_ue_list = p_ue_glbl_ctxt->victim_ue_info.
            rrm_victim_ue_on_cell[cell_index].victim_ue_list;

        p_cell_ctx=  rrm_cellm_get_cell_context(cell_index);
        if(RRM_PNULL == p_cell_ctx)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "Cell Context not found[%d]",cell_index);
            /* Coverity ID 87127 Starts */
            RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
            /* Coverity ID 87127 Ends */
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }

        /* We want to add new victim Ue into corresponding list */
        if(RRM_UE_VICTIM_CANDIDATE== p_ue_glbl_ctxt->p_ue_context->rrm_ue_eicic_info.victim_ue)
        {
            if (RRM_ZERO != ylCount(&victim_ue_list))
            {

                /* bug_13891_start */
                p_victim_node = (victim_ue_node_t *)ylFirst(&victim_ue_list);
                /* bug_13891_end */
                while(p_victim_node) 
                {    
                    if(p_victim_node->victim_ue_node_data.ue_index == p_ue_glbl_ctxt->p_ue_context->ue_index)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                                "[UE:%d] already present in victim list, No need to add", 
                                p_victim_node->victim_ue_node_data.ue_index);
                        /* Check if latest SINR needs to be updated */
                        /* Coverity ID 87127 Starts */
                        RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
                        /* Coverity ID 87127 Ends */
                        RRM_UT_TRACE_EXIT();    
                        return RRM_SUCCESS;
                    }
                    p_victim_node = (victim_ue_node_t *)ylNext(&(p_victim_node->node));
                }

                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                        "Adding new victim [UE:%d] in list", p_ue_glbl_ctxt->p_ue_context->ue_index);

                p_new_victim_node = (victim_ue_node_t *)rrm_mem_get(sizeof(victim_ue_node_t));
                if(RRM_PNULL != p_new_victim_node)
                {    
                    p_new_victim_node->victim_ue_node_data.ue_index = p_ue_glbl_ctxt->p_ue_context->ue_index;
                    p_new_victim_node->victim_ue_node_data.victim_state = RRM_UE_VICTIM_CANDIDATE;
                    p_new_victim_node->victim_ue_node_data.dl_sinr = dl_sinr;
                    ylPushTail(&victim_ue_list, &(p_new_victim_node->node));
                }


            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                        "Adding new victim [UE:%d] in list", p_ue_glbl_ctxt->p_ue_context->ue_index);
                /* List is empty so need to be created initially */ 
                p_new_victim_node = (victim_ue_node_t *)rrm_mem_get(sizeof(victim_ue_node_t));
                if(RRM_PNULL != p_new_victim_node)
                {    
                    p_new_victim_node->victim_ue_node_data.ue_index = p_ue_glbl_ctxt->p_ue_context->ue_index;
                    p_new_victim_node->victim_ue_node_data.victim_state = RRM_UE_VICTIM_CANDIDATE;
                    p_new_victim_node->victim_ue_node_data.dl_sinr = dl_sinr;
                    ylPushHead(&victim_ue_list, &(p_new_victim_node->node));  
                }    
            }
            /* bug_13875_start */
            p_ue_glbl_ctxt->victim_ue_info.
                rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;
            /* bug_13875_end */
            /* SPR14142start */ 
            /* SPR14157start */
            if ((RRMCM_RMIF_EICIC_INFO_PRESENT & p_cell_ctx->operator_info.bitmask) && 
                    (RRM_OAM_EICIC_DEACTIVATED != p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type))
            {
                x2_up_flag = rrm_check_for_x2_link_status(p_cell_ctx);
                /* SPR14157end*/
            }


            if(RRM_FALSE == x2_up_flag)
            {    
                if((RRM_FALSE == rrm_is_set_fgi_bit(p_ue_glbl_ctxt->p_ue_context, RRM_HUNDRED_FIFTEEN)) || 
                        (RRM_REL10 != p_ue_glbl_ctxt->p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                         eutra_radio_capability_info_def.access_stratum_release))

                {
                    /*review comment changes start*/
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "FGI BIT 115 is not set for victim UE"
                            "Sending directly UE reconfig to MAC");
                    /*review comment changes end*/
                    ue_index_list[RRM_ZERO] = p_ue_glbl_ctxt->p_ue_context->ue_index;
                    if(MAC_UE_RECONF_NOT_ONGOING  == (rrm_get_mac_ue_reconfig_mutex( cell_index )) )
                    {
                        /* Marking UE as victim at L2 */
                        ret_val= build_and_send_l2_ue_reconfig_req_for_victim(p_ue_glbl_ctxt->p_ue_context->cell_index,
                                ue_index_list, RRM_ONE, RRM_ONE);
                    }

                    if(RRM_SUCCESS == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "Successfully send [UE:%d] reconfig req to  MAC for victim UEs",
                                p_ue_glbl_ctxt->p_ue_context->ue_index);
                        rrm_set_mac_ue_reconfig_mutex(cell_index, W_FOR_MAC_UE_RECONF_CNF_FOR_EICIC);
                        /* SPR 14471 start */
                        p_ue_glbl_ctxt->p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM;
                        /* SPR 14471 end */
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                "Unable to send Mac UE reconfig request for [UE:%d]to L2",
                                p_ue_glbl_ctxt->p_ue_context->ue_index);
                    }


                }
                /* SPR14142end */

                else if(RRM_FAILURE == rrm_uem_send_rrc_ue_reconfig_for_victim_ue(p_ue_glbl_ctxt->p_ue_context,x2_up_flag, RRM_ONE ))
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                            "[UE:%d] reconfig failed while scheduling with ABS on RRC", 
                            p_ue_glbl_ctxt->p_ue_context->ue_index);
                    ret_val = RRM_FAILURE;
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,\
                            "[UE:%d] reconfig triggerred for victim ", 
                            p_ue_glbl_ctxt->p_ue_context->ue_index);
                    /* SPR 14471 start */
                    p_ue_glbl_ctxt->p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_VICTIM;
                    /* SPR 14471 end */
                    ret_val = RRM_SUCCESS;

                    /*SPR Fix 15664 Start */
                    /* MEAS GAP ALIGNMNET WITH eICIC*/
                    if (RRM_TRUE == p_ue_glbl_ctxt->p_ue_context->is_meas_gap_configured)
                    {
                        p_cell_meas_config_info = 
                            (rrm_meas_config_info_t*)rrm_cellm_get_meas_config_info(p_cell_ctx->cell_index);
                        if ((RRM_PNULL != p_cell_meas_config_info) && 
                                (p_cell_meas_config_info->bitmask & RRMCM_RMIF_MEAS_GAP_CONFIG_PRESENT) &&
                                (p_cell_meas_config_info->meas_gap_config.bitmask & RRMCM_RMIF_EUTRAN_GAP_OFFSET_TYPE_PRESENT )
                           )
                        {
                            rrm_uem_convert_abs_pattern_to_binary(
                                    p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied, abs_pattern_bianry);

                            /* UEM shall move the meas gap offset */
                            meas_gap_offset_stored = p_ue_glbl_ctxt->p_ue_context->meas_gap_offset;
                            final_changed_meas_gap_offset = rrm_uem_align_meas_offset_with_eicic(
                                    &p_ue_glbl_ctxt->p_ue_context->meas_gap_offset, abs_pattern_bianry, RRM_ONE);
                            if (meas_gap_offset_stored != final_changed_meas_gap_offset)
                            {
                                if(RRM_SUCCESS == rrm_ue_fill_meas_config_req_for_changed_gap_offset(p_rrc_rrm_meas_config_req,
                                            p_ue_glbl_ctxt->p_ue_context, final_changed_meas_gap_offset))
                                {
                                    transaction_id = rrm_generate_txn_id();
                                    if(RRM_SUCCESS == rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                                                RRM_MODULE_ID, RRC_MODULE_ID, transaction_id, p_ue_glbl_ctxt->p_ue_context->cell_index))
                                    {
                                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                                "Successfully send meas_config_req for changed meas_gap_offset");
                                    }
                                }
                            }
                            else
                            {
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                        "No change in meas_gap_offset[%u] So no need to send meas config",final_changed_meas_gap_offset);
                            }
                        }
                    }
                    /*SPR Fix 15664 End */
                }
            }
            else
            {
                /* Trigger A4 meas_config_request for Victim UE if applicable */
                /* SPR14165start */
                if((!(p_ue_glbl_ctxt->p_ue_context->rrm_ue_eicic_info.scheduled_on_abs)) && 
                        (RRM_UE_MEAS_CONFIG_REQ_ONGOING != p_ue_glbl_ctxt->p_ue_context->current_procedure.state ))
                    /* SPR14165end */
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                            "sending Meas conifg req for victim [UE:%d]", p_ue_glbl_ctxt->p_ue_context->ue_index);
                    if(RRM_FAILURE == rrm_build_and_send_meas_config_req(p_ue_glbl_ctxt->p_ue_context, MEAS_TYPE_FOR_VICTIM))
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                                "meas config req failed in A4 for victim [UE:%d]", p_ue_glbl_ctxt->p_ue_context->ue_index);
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                            "failed in sending Meas conifg req for victim [UE:%d]", p_ue_glbl_ctxt->p_ue_context->ue_index);
                }
            }
        }
        else if(RRM_UE_NO_VICTIM_STATE == p_ue_glbl_ctxt->p_ue_context->rrm_ue_eicic_info.victim_ue)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                    "process deletion of [UE:%d]", p_ue_glbl_ctxt->p_ue_context->ue_index);
            /* Want to delete if Ue is present in list for deletion */
            p_victim_node = (victim_ue_node_t *)ylFirst(&victim_ue_list);
            while(p_victim_node)
            {
                /*SPR 20461 START*/
                if((p_victim_node->victim_ue_node_data.ue_index == p_ue_glbl_ctxt->p_ue_context->ue_index)&&(RRM_UE_VICTIM_STATE == prev_ue_state))
                {
                    /*SPR 20461 END*/
                    /*SPR 22464 Fix Start*/
                    if((RRM_TRUE ==  rrm_is_set_fgi_bit(p_ue_glbl_ctxt->p_ue_context, RRM_HUNDRED_FIFTEEN)) && 
                            (RRM_REL10 <= p_ue_glbl_ctxt->p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                             eutra_radio_capability_info_def.access_stratum_release))
                        /*SPR 22464 Fix Stop*/
                    {

                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                                " sending RRC UE RECONFIG for [UE:%d] to make it non victim ", 
                                p_ue_glbl_ctxt->p_ue_context->ue_index);
                        ret_val = rrm_uem_send_rrc_ue_reconfig_for_victim_ue(p_ue_glbl_ctxt->p_ue_context,x2_up_flag, RRM_ZERO); 
                        if(RRM_FAILURE == ret_val)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                                    "[UE:%d] reconfig failed while scheduling with ABS on RRC", 
                                    p_victim_node->victim_ue_node_data.ue_index);
                        }
                        /* SPR 14471 start */
                        p_ue_glbl_ctxt->p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_NON_VICTIM;
                        /* SPR 14471 end */

                        /*SPR Fix 15664 Start */
                        /* MEAS GAP ALIGNMNET WITH eICIC*/

                        if(RRM_TRUE == p_ue_glbl_ctxt->p_ue_context->is_meas_gap_configured)
                        {
                            p_cell_meas_config_info = 
                                (rrm_meas_config_info_t*)rrm_cellm_get_meas_config_info(p_cell_ctx->cell_index);
                            if ((RRM_PNULL != p_cell_meas_config_info) && 
                                    (p_cell_meas_config_info->bitmask & RRMCM_RMIF_MEAS_GAP_CONFIG_PRESENT) &&
                                    (p_cell_meas_config_info->meas_gap_config.bitmask & RRMCM_RMIF_EUTRAN_GAP_OFFSET_TYPE_PRESENT )
                               )
                            {
                                rrm_uem_convert_abs_pattern_to_binary(
                                        p_cell_ctx->rrm_eicic_cell_info.usable_abs_pattern_applied, abs_pattern_bianry);

                                /* UEM shall move the meas gap offset */
                                meas_gap_offset_stored = p_ue_glbl_ctxt->p_ue_context->meas_gap_offset;
                                final_changed_meas_gap_offset = rrm_uem_align_meas_offset_with_eicic(
                                        &p_ue_glbl_ctxt->p_ue_context->meas_gap_offset, abs_pattern_bianry, RRM_ZERO);
                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                        "meas_gap_offset is [%d] after applying common ABS",final_changed_meas_gap_offset);

                                if (meas_gap_offset_stored != final_changed_meas_gap_offset)
                                {
                                    if(RRM_SUCCESS == rrm_ue_fill_meas_config_req_for_changed_gap_offset(p_rrc_rrm_meas_config_req,
                                                p_ue_glbl_ctxt->p_ue_context, final_changed_meas_gap_offset))
                                    {

                                        transaction_id = rrm_generate_txn_id();
                                        if(RRM_SUCCESS == rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                                                    RRM_MODULE_ID, RRC_MODULE_ID, transaction_id, 
                                                    p_ue_glbl_ctxt->p_ue_context->cell_index))
                                        {
                                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                                    "Successfully send meas_config_req for changed meas_gap_offset");
                                        }


                                    }
                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                            "No change in meas_gap_offset[%u] So no need to send meas config",final_changed_meas_gap_offset);

                                }
                            }
                        }
                        /*SPR Fix 15664 End */

                    }
                    else
                    {
                        ue_index_list[RRM_ZERO] = p_victim_node->victim_ue_node_data.ue_index;
                        if(MAC_UE_RECONF_NOT_ONGOING  == (rrm_get_mac_ue_reconfig_mutex( cell_index )) )
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                                    " sending MAC UE RECONFIG for [UE:%d] to make it non victim ", 
                                    p_ue_glbl_ctxt->p_ue_context->ue_index);
                            /* Marking UE as non victim at L2 */
                            ret_val= build_and_send_l2_ue_reconfig_req_for_victim(cell_index, ue_index_list, RRM_ONE, RRM_ZERO); 
                        }

                        if(RRM_SUCCESS == ret_val)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                    "Successfully send [UE:%d] reconfig req to  MAC for victim UEs", 
                                    p_ue_glbl_ctxt->p_ue_context->ue_index); 
                            rrm_set_mac_ue_reconfig_mutex(cell_index, W_FOR_MAC_UE_RECONF_CNF_FOR_EICIC);
                            /* SPR 14471 start */
                            p_ue_glbl_ctxt->p_ue_context->rrm_ue_eicic_info.victim_reconfig_flag = RRM_UE_RECONFIG_FOR_NON_VICTIM;
                            /* SPR 14471 end */
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                    "Unable to send Mac UE reconfig request for [UE:%d]to L2",
                                    p_ue_glbl_ctxt->p_ue_context->ue_index);
                        }
                    }

                    if(RRM_SUCCESS == ret_val)
                    {
                        ylDelete(&victim_ue_list, (YLNODE *)p_victim_node);
                        RRM_MEM_FREE(p_victim_node);
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                                "removing [UE:%d] from victim list", p_ue_glbl_ctxt->p_ue_context->ue_index);
                        /* bug_13875_start */
                        p_ue_glbl_ctxt->victim_ue_info.
                            rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;
                        /* bug_13875_end */
                        /* SPR 14247 start */
                        RRM_MEMSET(&(p_ue_glbl_ctxt->p_ue_context->eicic_meas_result), RRM_ZERO, sizeof(rrm_ue_eicic_meas_ind_t));
                        /* SPR 14247 end */

                        /* Coverity ID 87127 Starts */
                        RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
                        /* Coverity ID 87127 Ends */
                        RRM_UT_TRACE_EXIT();
                        return RRM_SUCCESS;
                    }
                }
                else
                {
                    p_victim_node = (victim_ue_node_t *)ylNext(&(p_victim_node->node));
                }
            }
            /* SPR 14610 start */
            p_ue_glbl_ctxt->victim_ue_info.
                rrm_victim_ue_on_cell[cell_index].victim_ue_list = victim_ue_list;
            /* SPR 14610 end */
            /* Coverity ID 87127 Starts */
            RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
            /* Coverity ID 87127 Ends */
            RRM_UT_TRACE_EXIT();    
            return ret_val;

        }
    }
    else
    {

        /*CID:71367 start*/
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                " NULL Ue context found ");
        /*CID:71367 end*/
    }

    /* Coverity ID 87127 Starts */
    RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
    /* Coverity ID 87127 Ends */
    RRM_UT_TRACE_EXIT();
    return ret_val;     
}

/* eICIC_PHASE_1_2_CHANGES_END */

/* Uplink power control end */
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_process_fsm
 *   DESCRIPTION:
 *       Process the all active ue release  ind from mif
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
    rrm_return_et
rrm_uem_process_fsm(rrm_ue_states_et ue_state,
        rrm_ue_events_et ue_event,
        rrm_ue_global_context_t *p_rrm_glb_ctxt)
{
    rrm_return_et      ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    /* SPR 19078: CID 107828 Fix Start */
    if(RRM_PNULL != p_rrm_glb_ctxt)
    {
        /* SPR 19078: CID 107828 Fix End */
        /* SPR 19221: CID 107859 Fix Start */
        if ( ( RRM_UE_MAX_STATE > ue_state ) &&
                ( RRM_UE_MAX_EVENT > ue_event ) )
        {
            /*SPR 19819 START*/
            /*SPR 19819 END*/
            /* SPR 19580: CID 107828 Fix Start */
            /*SPR 17890 Start*/
            if (RRM_PNULL != p_rrm_glb_ctxt->p_ue_context)
            {
                /*SPR 17890 End*/
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                        "#### UEFSM: Processing State %s Event %s, Current Procedure State %s ####",
                        UE_FSM_STATE[ue_state], UE_FSM_EVENT[ue_event],
                        rrm_get_ue_fsm_procedure_state_string(p_rrm_glb_ctxt->p_ue_context->current_procedure.state));

                /************ UEM FSM TRIGERRED **************************/
                ret_val = (rrmh_fsm[ue_state][ue_event]
                        (p_rrm_glb_ctxt));
                /*********** UEM FSM *************************************/

                /* SPR 19580: CID 107828 Fix End */

                /* SPR 20007 : CID 96889 Fix Start */
                if (RRM_PNULL != p_rrm_glb_ctxt->p_ue_context)
                {
                    if(RRM_FAILURE == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                "#### UEFSM: Failed while in State %s Event %s ####",
                                UE_FSM_STATE[ue_state], UE_FSM_EVENT[ue_event]);
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                "#### UEFSM: Processing Completed for Event %s ####",
                                UE_FSM_EVENT[ue_event]);
                    }

                }
                /* SPR 20007 : CID 96889 Fix End */
            }
            else
            {

                /*SPR 19819 START*/
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Not processed STATE [%d] and EVENT [%d]as UE context is null",ue_state,ue_event);
                /*SPR 19819 END*/
            }

        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                    "Error: Unexpected event or State [UE:%u] State: %d Event: %d",
                    p_rrm_glb_ctxt->p_ue_context->ue_index, ue_state, ue_event); 

            ret_val = RRM_FAILURE;

        }
        /* BUG_11943_FIX_START */
        if (RRM_PNULL != p_rrm_glb_ctxt->p_ue_context)
        {
            /* SPR 16257 FIX START */ 
            if( RRM_PNULL != p_rrm_glb_ctxt->p_ue_context->current_procedure.p_proc_data)
            {
                p_rrm_glb_ctxt->p_ue_context->current_procedure.p_proc_data  = RRM_NULL;
            }
            /* SPR 16257 FIX STOP */
        }
        /* SPR 19078: CID 107828 Fix Start */
    }
    else
    {
        ret_val = RRM_FAILURE;
        return ret_val;
    }
    /* SPR 19078: CID 107828 Fix End */
    /* SPR 19221: CID 107859 Fix End */
    /* BUG_11943_FIX_END */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*LTE_RRM_TM_SWITCH_END*/
/******************************************************************************
 *   FUNCTION NAME: rrm_backup_cqi_information
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
    rrm_return_et
rrm_backup_cqi_information( rrm_ue_context_t    *p_ue_context)
{

    RRM_UT_TRACE_ENTER();

    if( RRM_PNULL != p_ue_context )
    {
            /*SPR 22464 Fix Start*/
        if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.access_stratum_release)
            /*SPR 22464 Fix Stop*/
        {
            /* bitmask kept in UE conext to identify the reconfig for CQI R-10*/
            p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
                RRM_UE_RECONFIG_PHY_CQI_REPORTING_R10_ROLLBACK_PRESENT;

            p_ue_context->ue_phy_config_information.ue_backup_cqi_configured_info_r10=
                p_ue_context->ue_phy_config_information.ue_cqi_present_configured_info_r10;
        }
        else
        {
            /* bitmask kept in UE conext to identify the reconfig for CQI*/
            p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask |=
                RRM_UE_RECONFIG_PHY_CQI_REPORTING_ROLLBACK_PRESENT;

            p_ue_context->ue_phy_config_information.ue_backup_cqi_configured_info =
                p_ue_context->ue_phy_config_information.ue_cqi_present_configured_info;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "Null Pointer of UE Context, Function could not Create the Backup of CQI Params");
    }


    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/* R-10 Changes: Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_set_cqi_information_for_ue_r10
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_set_cqi_information_for_ue_r10( rrm_ue_context_t   *p_ue_context,
        rrc_cqi_report_config_r10_t 
        *p_ue_updated_cqi_info)
{

    RRM_UT_TRACE_ENTER();

    if( RRM_PNULL != p_ue_context)
    {
        p_ue_context->ue_phy_config_information.ue_cqi_present_configured_info_r10
            = *p_ue_updated_cqi_info;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "Null Pointer of UE Context, Function could not set the CQI Params in UE Context");
    }

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/* R-10 Changes: End */
/******************************************************************************
 *   FUNCTION NAME: rrm_set_cqi_information_for_ue
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_set_cqi_information_for_ue( rrm_ue_context_t   *p_ue_context,
        rrm_ue_phy_cqi_reporting_t
        *p_ue_updated_cqi_info)
{

    RRM_UT_TRACE_ENTER();

    if( RRM_PNULL != p_ue_context)
    {
        p_ue_context->ue_phy_config_information.ue_cqi_present_configured_info
            = *p_ue_updated_cqi_info;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "Null Pointer of UE Context, Function could not set the CQI Params in UE Context");
    }

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rollback_ue_cqi_information_r10
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
    rrm_return_et
rrm_rollback_ue_cqi_information_r10( rrm_ue_context_t   *p_ue_context )
{
    RRM_UT_TRACE_ENTER();

    if( RRM_PNULL != p_ue_context )
    {
        p_ue_context->ue_phy_config_information.ue_cqi_present_configured_info_r10 =
            p_ue_context->ue_phy_config_information.ue_backup_cqi_configured_info_r10;
        /* Toggles the bitmask RRM_UE_RECONFIG_PHY_CQI_REPORTING_R10_ROLLBACK_PRESENT if was set */
        p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask = ~( RRM_UE_RECONFIG_PHY_CQI_REPORTING_R10_ROLLBACK_PRESENT ) &
            (p_ue_context->ue_phy_config_information.ue_reconfig_rollback_bitmask);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "Null Pointer of UE Context, Function could not rollback the CQI Params r10 in UE Context");
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_rollback_ue_cqi_information
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
    rrm_return_et
rrm_rollback_ue_cqi_information( rrm_ue_context_t   *p_ue_context )
{
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();

    if( RRM_PNULL != p_ue_context )
    {
        p_ue_context->ue_phy_config_information.ue_cqi_present_configured_info =
            p_ue_context->ue_phy_config_information.ue_backup_cqi_configured_info;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "Null Pointer of UE Context, Function could not rollback the CQI Params in UE Context");
    }

    return RRM_SUCCESS;
}

/*Bug 497 Fix Start */
/******************************************************************************
 *  FUNCTION NAME: rrm_resolve_meas_gap_sr_index_conflict
 *  DESCRIPTION:
 *     This function resolves any conflict between gp_offset and sr_index
 *
 *  RETURNS:
 *     location of gp_offset
 ******************************************************************************/
    U8
rrm_resolve_meas_gap_sr_index_conflict(
        U8 location,
        U8 sr_index
        )
{
    RRM_UT_TRACE_ENTER();

    U8 gp_offset = RRM_ZERO;
    S8 sf_diff = RRM_ZERO;

    gp_offset = location * RRM_THREE;
    sf_diff = ( (sr_index - RRM_FIVE)%RRM_TEN ) - (gp_offset % RRM_TEN);

    if(sf_diff >= RRM_ZERO)
    {
        if(sf_diff < RRM_THREE)
        {
            location++ ;
        }
        else if(sf_diff < RRM_SIX)
        {
            location += RRM_TWO;
        }
    }
    return location;
}
/*Bug 497 Fix End */
/* CA Changes : Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_rollback_ue_scell_info_add_fail
 *   INPUT      : p_ue_context
 *   OUTPUT     : None
 *   DESCRIPTION: 
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
    rrm_return_et
rrm_rollback_ue_scell_info_add_fail(rrm_ue_context_t    *p_ue_context)
{
    U8 count = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    if( RRM_PNULL != p_ue_context )
    {
        ret_val = rrm_remove_scell_data_from_ue_context(p_ue_context, 
                p_ue_context->ue_scell_add_params.scell_bkp_count,
                (p_ue_context->ue_scell_add_params.scell_cell_index_add_bkp));
        if(ret_val == RRM_SUCCESS)
        {
            /* Reset the structure used for backup data */
            p_ue_context->ue_scell_add_params.bitmask = RRM_ZERO;
            p_ue_context->ue_scell_add_params.scell_bkp_count = RRM_ZERO;
            for(count = RRM_ZERO; count < RRM_MAX_SCELL; count++)
            {
                p_ue_context->ue_scell_add_params.scell_cell_index_add_bkp[count] = RRM_ZERO;
            }
        }
    }
    else
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "Null Pointer of UE Context, Function could not rollback UE scell info UE Context");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_reset_ue_scell_info_del_fail
 *   INPUT      : p_ue_context
 *   OUTPUT     : None
 *   DESCRIPTION: reset the scell structure when UE reconfig resp.
 *
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 *******************************************************************************/
    rrm_return_et
rrm_reset_ue_scell_info_del_fail(rrm_ue_context_t    *p_ue_context)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    if( RRM_PNULL != p_ue_context )
    {
        p_ue_context->ue_scell_add_params.bitmask = RRM_ZERO; /* CID: 61026 - Fix */
    }
    else
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "Null Pointer of UE Context, Function could not reset ue scell info!");
    }
    return ret_val;  
}
/* CA Changes : End */

/******************************************************************************
 *   FUNCTION NAME: rrm_get_num_of_layer_on_tx_mode_basis_for_2x2 
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_get_num_of_layer_on_tx_mode_basis_for_2x2( transmission_mode_ue_service_profile_et
        tx_mode,
        U8                  *num_of_layer )
{
    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
            "Input paramters received:  Tx_mode [%d]",tx_mode);

    switch( tx_mode )
    {
        case TRANSMISSION_MODE_TM1:
        case TRANSMISSION_MODE_TM2:
        case TRANSMISSION_MODE_TM6:
        case TRANSMISSION_MODE_TM7:
            {
                *num_of_layer = RRM_ONE;
                break;
            }
        case TRANSMISSION_MODE_TM3:
        case TRANSMISSION_MODE_TM4:
        case TRANSMISSION_MODE_TM8_V920:
            {
                *num_of_layer = RRM_TWO;
                break;
            }
        default:
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                        "Invalid Transmission mode[%d] is configured", tx_mode);
                ret_val = RRM_FAILURE;
            }

    }

    RRM_UT_TRACE_EXIT();

    return ret_val;

}


/******************************************************************************
 *   FUNCTION NAME: rrm_get_num_of_layer_on_tx_mode_and_ue_category_4xn
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_get_num_of_layer_on_tx_mode_and_ue_category_4xn( transmission_mode_ue_service_profile_et
        tx_mode,
        rrm_ue_category_et      ue_category, 
        U8                      *num_of_layer,
        rrm_antenna_mxn_et       mxn_support )
{

    rrm_return_et    ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
            "Input paramters received: Tx_mode [%d], UE Category [%d], antenna_mxn_support [%d]",
            tx_mode , ue_category , mxn_support );

    switch( tx_mode )
    {
        case TRANSMISSION_MODE_TM1:
        case TRANSMISSION_MODE_TM2:
        case TRANSMISSION_MODE_TM6:
        case TRANSMISSION_MODE_TM7:
            {
                *num_of_layer = RRM_ONE;
                break;
            }
        case TRANSMISSION_MODE_TM3:
        case TRANSMISSION_MODE_TM4:
            {
                if( ((ue_category >= UE_CATEGORY_5) &&  (ue_category <= UE_CATEGORY_8)) && (mxn_support == Anetnna_4x4)  )
                {
                    *num_of_layer = RRM_FOUR;

                }
                else
                {
                    *num_of_layer = RRM_TWO;
                }
                break;
            }
        case TRANSMISSION_MODE_TM8_V920:
            {
                *num_of_layer = RRM_TWO;
                break;
            }
        default:
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                        "Invalid Transmission mode[%d] is configured", tx_mode);
                ret_val = RRM_FAILURE;
            }

    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}


/******************************************************************************
 *   FUNCTION NAME: rrm_get_num_of_layer_for_ue_on_tx_mode_mxn 
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_get_num_of_layer_for_ue_on_tx_mode_mxn( rrm_antenna_mxn_et         mxn_support,
        transmission_mode_ue_service_profile_et
        transmission_mode,
        rrm_ue_category_et     ue_category,
        U8                     *num_of_layer )
{
    rrm_return_et    ret_val = RRM_SUCCESS;


    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
            "Present Anetnna M x N type [%d]",mxn_support); 

    switch( mxn_support )
    {
        case Anetnna_1x1:
            {
                *num_of_layer = RRM_ONE;
                break;
            }
        case Anetnna_2x2:
            {
                ret_val = rrm_get_num_of_layer_on_tx_mode_basis_for_2x2( transmission_mode ,
                        num_of_layer );
                break;
            }
        case Anetnna_4x2:
        case Anetnna_4x4:
            {
                ret_val = rrm_get_num_of_layer_on_tx_mode_and_ue_category_4xn( transmission_mode ,
                        ue_category,
                        num_of_layer,mxn_support );
                break;
            }
        default:
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                        "Wrong Anetnna mxn is selected");
                ret_val = RRM_FAILURE;
            }
    }


    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_get_ue_category 
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
    U8
rrm_get_ue_category(const rrm_ue_context_t *p_ue_context)
{

    U8 ue_category = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if(p_ue_context->ue_capability_params.bitmask & 
            RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
    {
        /* ue category */ /* R-10 Change : Start */
            /*SPR 22464 Fix Start*/
        if(RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.access_stratum_release)
            /*SPR 22464 Fix Stop*/
        {   /* In case UE is R-10 supported then extract ue category from here */
            if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask & RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT) &&
                    (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.\
                     bitmask & RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT) &&
                    (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.\
                     ue_eutra_capability_v940_ies.bitmask & RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT) &&
                    (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.\
                     ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask & RRM_UE_EUTRA_CAPABILITY_V1020_UE_CATEGORY_PRESENT))
            {
                ue_category = (rrm_ue_category_et)(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.\
                        ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.\
                        ue_eutra_capability_v1020_ies.ue_category_v1020);
            }
            else
            {
                ue_category = (rrm_ue_category_et)( p_ue_context->ue_capability_params.\
                        rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.ue_category );
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                        "R-10 UE category IE not present. Setting UE Category to earlier Rel. value.[%d]",
                        ue_category);
            }
        }
        else
        {
            ue_category = (rrm_ue_category_et)( p_ue_context->ue_capability_params.\
                    rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.ue_category );
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "UE Capability not yet received. So UE Category couldn't be decided");
    }
    RRM_UT_TRACE_EXIT();
    return ue_category;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_select_num_of_layer_for_ue 
 *   DESCRIPTION:

 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
    rrm_return_et
rrm_select_num_of_layer_for_ue( const rrm_ue_context_t *p_ue_context,
        U8                     *num_of_layer )
{
    rrm_return_et             ret_val = RRM_SUCCESS; 
    rrm_ue_category_et        ue_category = UE_CATEGORY_NONE;
    /* ue category */ /* R-10 Change : Start */
    ue_category = (rrm_ue_category_et)rrm_get_ue_category(p_ue_context);
    /* ue category */ /* R-10 Change : End */
    transmission_mode_ue_service_profile_et
        transmission_mode = TRANSMISSION_MODE_TM1;
    rrm_antenna_mxn_et        mxn_support = Anetnna_1x1 ; 

    RRM_UT_TRACE_ENTER();

    // getter function to return the mxn antenna type : this should be cellm fucntion
    ret_val = rrm_get_mxn_anetnna_support( p_ue_context->cell_index,&mxn_support ); 

    if( RRM_SUCCESS == ret_val )
    {
        /* SPR 11279 Fix: Start */
            /*SPR 22464 Fix Start*/
        if((p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT) &&
                (RRM_REL10 <= p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 eutra_radio_capability_info_def.access_stratum_release))
            /*SPR 22464 Fix Stop*/
        {
            transmission_mode = (transmission_mode_ue_service_profile_et)
                p_ue_context->ue_phy_config_information.ue_antenna_info_r10.
                transmission_mode;
        }
        else
        {
            transmission_mode = (transmission_mode_ue_service_profile_et)
                p_ue_context->ue_phy_config_information.ue_antenna_information.
                transmission_mode; 
        }
        /* SPR 11279 Fix: End */
 
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
        "Currently transmission mode [%d] is detected and Ue category [%d]",
         transmission_mode, ue_category );

        ret_val = rrm_get_num_of_layer_for_ue_on_tx_mode_mxn( mxn_support, 
                transmission_mode ,
                ue_category,
                num_of_layer );

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF, \
                "num of layer calculated [%d] for [UE:%d]", *num_of_layer,p_ue_context->ue_index );
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "antenna mxn support is not valid from fun rrm_get_mxn_anetnna_support()")
            ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/*SPR Fix 15664 Start*/
/******************************************************************************
 *  FUNCTION NAME:      rrm_uem_convert_abs_pattern_to_binary 
 *  DESCRIPTION:        This function changes Byte ABS Pattern into
 *                      binary format
 *  INPUT:              abs_pattten (in case of x2 up consider aggressor's
 *                      pattern else operator configured victim abs pattern)
 *                      *p_abs_binary_format
 *  RETURNS:            void
 ******************************************************************************/
rrm_void_t
    rrm_uem_convert_abs_pattern_to_binary
(
 U8     *abs_pattern, 
 U8     *p_abs_binary_format
 )
{
    U8             abs_binary_index = RRM_ZERO;
    U8             quotient = RRM_ZERO;
    U8             binary_pattern[RRM_EIGHT] = {RRM_ZERO};
    U8             bit_index = RRM_ZERO;
    U8             abs_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    for(abs_count = RRM_ZERO; 
            abs_count < MAX_SUBFRAME_PATTERN_FDD; 
            abs_count ++)
    {
        /** Converting ABS pattern to binary format */ 
        quotient = abs_pattern[abs_count];
        if(RRM_ZERO == quotient)
        {
            for(bit_index = RRM_ZERO;
                    bit_index < RRM_EIGHT;
                    bit_index++)
            {
                p_abs_binary_format[abs_binary_index++] = RRM_ZERO;
            }
        }
        else
        {
            while(quotient != RRM_ZERO)
            {
                binary_pattern[bit_index++] = quotient % RRM_TWO;
                quotient = quotient / RRM_TWO;
            }

            /** Storing the ABS pattern in binary format */
            for (bit_index = RRM_EIGHT; 
                    bit_index > RRM_ZERO; 
                    bit_index--)
            {
                p_abs_binary_format[abs_binary_index++] = binary_pattern[bit_index- RRM_ONE];
            }
        }
    }

    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *  FUNCTION NAME:      rrm_uem_calculate_meas_off_set
 *  DESCRIPTION:        This function moves the meas_gap offset according to 
 *                      ABS Pattern.
 *  INPUT:              *p_meas_gap_offset
 *                      *p_rrm_ue_context
 *  RETURNS:            RRM_SUCCESS
 *                      RRM_FAILURE 
 ******************************************************************************/
U8
    rrm_uem_calculate_meas_off_set
(
 U8                      *p_meas_gap_offset,
 rrm_ue_context_t        *p_rrm_ue_ctx
 )
{
    rrm_cell_context_t             *p_cell_ctx  = RRM_PNULL;
    rrm_bool_et                    x2_up_flag = RRM_FALSE;
    U8                             aggressor_abs_pattern[MAX_SUBFRAME_PATTERN_FDD] = {RRM_ZERO};
    U8                             final_changed_meas_gap_offset = RRM_ZERO;
    /* SPR 15664 fix start */
    U8                             abs_pattern_bianry[RRM_FORTY] = {RRM_ZERO};
    /* SPR 15664 fix end */
    U8                             sf_status = RRM_ZERO;
    U8                             new_meas_abs_pattern[RRM_MAX_PATTERN_BYTE];

    RRM_UT_TRACE_ENTER();

    /* SPR 16256 FIX START */
    RRM_MEMSET(aggressor_abs_pattern, RRM_ZERO, MAX_SUBFRAME_PATTERN_FDD);
    /*SPR 16256 FIX STOP*/
    /* Fecth the Cell context pointer to find x2 status */
    p_cell_ctx = rrm_cellm_get_cell_context(p_rrm_ue_ctx->cell_index);
    if (RRM_PNULL == p_cell_ctx)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        return *p_meas_gap_offset;
    }
    /* Get the X2 up flag */
    x2_up_flag = rrm_check_for_x2_link_status(p_cell_ctx);
    if( ( RRMCM_RMIF_EICIC_INFO_PRESENT & p_cell_ctx->operator_info.bitmask) &&
            ( RRMCM_RMIF_ABS_INFO_PRESENT & p_cell_ctx->operator_info.eicic_info.bitmask) &&
            ( RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT & p_cell_ctx->operator_info.eicic_info.abs_info.bitmask))
    {
        if(RRM_FALSE == x2_up_flag)
        {
            if (RRM_OAM_ACT_AS_VICTIM == p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type) 
            {
                if (RRM_CELLM_USABLE_ABS_PATTERN_PRESENT & 
                        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask)  
                {
                    if (RRM_UE_VICTIM_STATE == p_rrm_ue_ctx->rrm_ue_eicic_info.victim_ue)
                    {
                        sf_status = RRM_ONE;
                    }
                    else
                    {
                        sf_status = RRM_ZERO;
                    }
                    /* Convert ABS Pattern into binary */
                    /* SPR 15664 fix start */
                    rrm_uem_convert_abs_pattern_to_binary(p_cell_ctx->rrm_eicic_cell_info.\
                            usable_abs_pattern_applied, abs_pattern_bianry);
                    /* SPR 15664 fix end */
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                            "Usable ABS Pattern not present ");                                   
                    return *p_meas_gap_offset;
                }
            }
            else if (RRM_OAM_ACT_AS_AGGRESSOR == p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type)
            {
                if(RRM_SUCCESS == rrm_cellm_get_highest_load_abs(p_cell_ctx,new_meas_abs_pattern))
                {

                    /* To check there should be atleast one non ABS subframe*/
                    sf_status = RRM_ONE;
                    RRM_MEMCPY(aggressor_abs_pattern, new_meas_abs_pattern,
                            MAX_SUBFRAME_PATTERN_FDD);
                    /* Convert ABS Pattern into binary */
                    rrm_uem_convert_abs_pattern_to_binary(aggressor_abs_pattern, abs_pattern_bianry);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                            "Serving ABS Pattern not present ");                                   
                    return *p_meas_gap_offset;
                }
            }
        }
        else
        {
            if (RRM_OAM_ACT_AS_VICTIM == p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type) 
            {
                if (RRM_CELLM_USABLE_ABS_PATTERN_PRESENT & 
                        p_cell_ctx->operator_info.eicic_info.abs_info.abs_pattern.bitmask)  
                {
                    if (RRM_UE_VICTIM_STATE == p_rrm_ue_ctx->rrm_ue_eicic_info.victim_ue)
                    {
                        sf_status = RRM_ONE;
                    }
                    else
                    {
                        sf_status = RRM_ZERO;
                    }
                    /* Convert ABS Pattern into binary */
                    /* SPR 15664 fix start */
                    rrm_uem_convert_abs_pattern_to_binary(p_cell_ctx->rrm_eicic_cell_info.\
                            usable_abs_pattern_applied, abs_pattern_bianry);
                    /* SPR 15664 fix end */
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                            "Usable ABS Pattern not present ");                                   
                    return *p_meas_gap_offset;
                }

            }
            else if (RRM_OAM_ACT_AS_AGGRESSOR == p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type)
            {
                if(RRM_SUCCESS == rrm_cellm_get_highest_load_abs(p_cell_ctx,new_meas_abs_pattern))
                {
                    sf_status = RRM_ONE;
                    RRM_MEMCPY(aggressor_abs_pattern, new_meas_abs_pattern,
                            MAX_SUBFRAME_PATTERN_FDD);
                    /* Convert ABS Pattern into binary */
                    /* SPR 15664 fix start */
                    rrm_uem_convert_abs_pattern_to_binary(aggressor_abs_pattern, abs_pattern_bianry);
                    /* SPR 15664 fix end */
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                            "Serving ABS Pattern not present ");                                   
                    return *p_meas_gap_offset;
                }

            }
        }

        /* UEM shall move the meas gap offset */
        /* SPR 15664 fix start */
        final_changed_meas_gap_offset = rrm_uem_align_meas_offset_with_eicic(p_meas_gap_offset,
                abs_pattern_bianry,
                sf_status);
        /* SPR 15664 fix start */
    }
    else
    {
        final_changed_meas_gap_offset = *p_meas_gap_offset;
    }

    RRM_UT_TRACE_EXIT();
    return final_changed_meas_gap_offset;
}
/******************************************************************************
 *  FUNCTION NAME  :  rrm_uem_align_meas_offset_with_eicic` 
 *  DESCRIPTION    :  This function checks atleast one abs_subframe/Non Abs for 
 *                    Victim/Aggresor. If not found then meas_gap offset is 
 *                    moved.
 *  INPUT          :  *p_meas_gap_offset, 
 *                    *p_abs_binary_format
 *  RETURNS        :  *p_meas_gap_offset 
 ******************************************************************************/
U8
rrm_uem_align_meas_offset_with_eicic
( 
 U8      *p_meas_offset, 
 U8     *p_abs_binary_format,
 U8      sf_status
 )
{
    U8 abs_index            =   RRM_ZERO;
    U8 index                =   RRM_ZERO;
    U8 sf_boundry           =   RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /* if meas offset is greater than 35 loop start from starting */
    if ( *p_meas_offset >= RRM_THIRTY_FIVE)
    {
        /*Set index just after meas gap */
        index = (*p_meas_offset % RRM_FIVE) + RRM_ONE;
        sf_boundry = *p_meas_offset;
    }
    /* loop start from ZERO */
    else
    {
        index = RRM_ZERO;
        sf_boundry = *p_meas_offset + RRM_ONE;
    }

    /* Check ATLEAST ONE ABS SUFRAME excluding meas_gap */
    for( abs_index = index; abs_index < sf_boundry; abs_index++)
    {
        if(abs_index == *p_meas_offset)
        {
            abs_index = *p_meas_offset + RRM_SIX;
            sf_boundry = RRM_FORTY;
        }
        if( p_abs_binary_format[abs_index] == sf_status)
        {
            return *p_meas_offset;
        }
        else
        {
            continue;
        }
    }

    sf_boundry = (*p_meas_offset + RRM_SIX);

    for(abs_index = *p_meas_offset; abs_index < sf_boundry ; abs_index ++)
    {
        if( p_abs_binary_format[abs_index] == sf_status)
        {
            if( *p_meas_offset >= RRM_THIRTY_FIVE)
            {
                *p_meas_offset = (*p_meas_offset % RRM_FIVE) + RRM_ONE;
            }
            else
            {
                *p_meas_offset = * p_meas_offset + RRM_SIX;
                if(*p_meas_offset == RRM_FORTY)
                {
                    *p_meas_offset = RRM_ZERO;
                }
            }
            return *p_meas_offset;
        }
        else if( abs_index >= RRM_FORTY)
        {
            abs_index = RRM_ZERO;
            sf_boundry = (*p_meas_offset % RRM_FIVE) + RRM_ONE;
        }
        else
        {
            continue;
        }
    }
    RRM_UT_TRACE_EXIT();
    return *p_meas_offset;
}
/*SPR Fix 15664 end*/

/******************************************************************************
 *  FUNCTION NAME: rrm_ue_assign_gap_offset
 *  DESCRIPTION:
 *     This function assign gapoffset and increase count according to it and
 *     maintains offset repository as well
 *
 *  RETURNS:
 *     meas_gap_offset 
 ******************************************************************************/
U8
rrm_ue_assign_gap_offset(
        /*Bug 497 Fix Start */
        rrm_ue_context_t    *p_rrm_ue_context,
        U8                         gap_offset_type
        )
{
    RRM_UT_TRACE_ENTER();

    U8 gap_offset_count    = RRM_ZERO;
    U8 least_used_offset_index   = RRM_ZERO;
    U8 meas_gap_offset   = RRM_ZERO;
    U8 location   = RRM_ZERO;
    U8 sr_index   = RRM_ZERO;

    sr_index = p_rrm_ue_context->sr_params.sr_configuration_index;
    /*Bug 497 Fix End */
    if(RRM_MEAS_GAP_TYPE_0 == gap_offset_type) 
    {
        least_used_offset_index = rrm_gap_offset0_repository[RRM_ZERO].offset_count;

        for(gap_offset_count= RRM_ZERO; gap_offset_count < MAX_USABLE_GP0_OFFSET; gap_offset_count++)
        {
            if( rrm_gap_offset0_repository[gap_offset_count].offset_count <
                    least_used_offset_index)
            {
                least_used_offset_index = rrm_gap_offset0_repository[gap_offset_count].offset_count;
                location = gap_offset_count;
            }
        }
        /*Bug 497 Fix Start */

        location = rrm_resolve_meas_gap_sr_index_conflict(location, sr_index);

        if(location >= MAX_USABLE_GP0_OFFSET)
        {
            location = location - MAX_USABLE_GP0_OFFSET;
        }
        rrm_gap_offset0_repository[location].offset_count++;

        meas_gap_offset = location * RRM_THREE;
        /*Bug 497 Fix End */

        /*SPR Fix 15664 Start*/
        meas_gap_offset = rrm_uem_calculate_meas_off_set(&meas_gap_offset, 
                p_rrm_ue_context);
        /*SPR Fix 15664 End*/

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "Gap Offset before resolving the sr_index conflict [%d] for Gap Type [%d],sr_index = %d"
                "Assigned Gap Offset [%d] for this Gap Type offset used [%d] times ",
                location * RRM_THREE , gap_offset_type, sr_index,
                meas_gap_offset, rrm_gap_offset0_repository[location].offset_count);

    }
    else if(RRM_MEAS_GAP_TYPE_1 == gap_offset_type)
    {
        least_used_offset_index = rrm_gap_offset1_repository[RRM_ZERO].offset_count;
        for(gap_offset_count= RRM_ZERO; gap_offset_count < MAX_USABLE_GP1_OFFSET; gap_offset_count++)
        {
            if( rrm_gap_offset1_repository[gap_offset_count].offset_count <
                    least_used_offset_index)
            {
                least_used_offset_index = rrm_gap_offset1_repository[gap_offset_count].offset_count;
                location = gap_offset_count;
            }
        }
        /*Bug 497 Fix Start */
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Gap Offset before resolving the sr_index conflict [%d] for Gap Type [%d],sr_index = %d  ",
                location * RRM_THREE , gap_offset_type, sr_index);

        location = rrm_resolve_meas_gap_sr_index_conflict(location, sr_index);

        if(location >= MAX_USABLE_GP1_OFFSET)
        {
            location = location - MAX_USABLE_GP1_OFFSET;
        }
        rrm_gap_offset1_repository[location].offset_count++;

        meas_gap_offset = location * RRM_THREE;
        /*Bug 497 Fix End */
        /*spr_fix_15664_start*/
        /*spr_fix_15664_end*/

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Assigned Gap Offset [%d] for Gap Type [%d] offset used [%d] times ",
                meas_gap_offset, gap_offset_type, rrm_gap_offset1_repository[location].offset_count);

    }
/* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED
    else if(RRM_MEAS_GAP_TYPE_4 == gap_offset_type)
    {
        least_used_offset_index = rrm_gap_offset4_repository[RRM_ZERO].offset_count;
        for(gap_offset_count= RRM_ZERO; gap_offset_count < MAX_USABLE_GP4_OFFSET; gap_offset_count++)
        {
            if( rrm_gap_offset4_repository[gap_offset_count].offset_count <
                    least_used_offset_index)
            {
                least_used_offset_index = rrm_gap_offset4_repository[gap_offset_count].offset_count;
                location = gap_offset_count;
            }
        }
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Gap Offset before resolving the sr_index conflict [%d] for Gap Type [%d],sr_index = %d  ",
                location * RRM_THREE , gap_offset_type, sr_index);

        location = rrm_resolve_meas_gap_sr_index_conflict(location, sr_index);

        if(location >= MAX_USABLE_GP4_OFFSET)
        {
            location = location - MAX_USABLE_GP4_OFFSET;
        }
        /* coverity_279999_fix_start*/
        rrm_gap_offset4_repository[location].offset_count++;
        /* coverity_279999_fix_end*/

        meas_gap_offset = location * RRM_THREE;

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Assigned Gap Offset [%d] for Gap Type [%d] offset used [%d] times ",
                meas_gap_offset, gap_offset_type, rrm_gap_offset4_repository[location].offset_count);
    }
    else if(RRM_MEAS_GAP_TYPE_5 == gap_offset_type)
    {
        least_used_offset_index = rrm_gap_offset5_repository[RRM_ZERO].offset_count;
        for(gap_offset_count= RRM_ZERO; gap_offset_count < MAX_USABLE_GP5_OFFSET; gap_offset_count++)
        {
            if( rrm_gap_offset5_repository[gap_offset_count].offset_count <
                    least_used_offset_index)
            {
                least_used_offset_index = rrm_gap_offset5_repository[gap_offset_count].offset_count;
                location = gap_offset_count;
            }
        }
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Gap Offset before resolving the sr_index conflict [%d] for Gap Type [%d],sr_index = %d  ",
                location * RRM_THREE , gap_offset_type, sr_index);

        location = rrm_resolve_meas_gap_sr_index_conflict(location, sr_index);

        if(location >= MAX_USABLE_GP5_OFFSET)
        {
            location = location - MAX_USABLE_GP5_OFFSET;
        }
        rrm_gap_offset5_repository[location].offset_count++;

        meas_gap_offset = location * RRM_THREE;

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Assigned Gap Offset [%d] for Gap Type [%d] offset used [%d] times ",
                meas_gap_offset, gap_offset_type, rrm_gap_offset5_repository[location].offset_count);

    }
#endif
/* ENDC_MEAS_CHANGES_END */

    RRM_UT_TRACE_EXIT();   
    return meas_gap_offset;
}

/******************************************************************************
 *  FUNCTION NAME: rrm_ue_release_gap_offset
 *  DESCRIPTION:
 *     This function release gapoffset and decrease count according to it and
 *     maintains offset repository as well
 *
 *  RETURNS:
 *      None
 ******************************************************************************/
    rrm_void_t
rrm_ue_release_gap_offset(
        rrm_ue_context_t           *p_ue_context
        )
{  
    RRM_UT_TRACE_ENTER();
    U8 offset_index = RRM_ZERO;
    if(p_ue_context->meas_gap_offset > RRM_ZERO)
    {
        /*Bug 497 Fix Start*/
        offset_index = (p_ue_context->meas_gap_offset)/RRM_THREE;
        /*Bug 497 Fix End*/
        if(RRM_MEAS_GAP_TYPE_0 == p_ue_context->meas_gap_type)
        {
            rrm_gap_offset0_repository[offset_index].offset_count-- ;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Released offset  (%d) for meas gap type (%d)",
                    p_ue_context->meas_gap_offset, p_ue_context->meas_gap_type);
        }
        else if(RRM_MEAS_GAP_TYPE_1 == p_ue_context->meas_gap_type)
        {
            rrm_gap_offset1_repository[offset_index].offset_count-- ;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Released offset  (%d) for meas gap type (%d)",
                    p_ue_context->meas_gap_offset, p_ue_context->meas_gap_type);
        }
/* ENDC_MEAS_CHANGES_START */
#ifdef ENDC_ENABLED
        else if(RRM_MEAS_GAP_TYPE_4 == p_ue_context->meas_gap_type)
        {
            rrm_gap_offset4_repository[offset_index].offset_count-- ;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Released offset  (%d) for meas gap type (%d)",
                    p_ue_context->meas_gap_offset, p_ue_context->meas_gap_type);
        }
        else if(RRM_MEAS_GAP_TYPE_5 == p_ue_context->meas_gap_type)
        {
            rrm_gap_offset5_repository[offset_index].offset_count-- ;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Released offset  (%d) for meas gap type (%d)",
                    p_ue_context->meas_gap_offset, p_ue_context->meas_gap_type);
        }
#endif
/* ENDC_MEAS_CHANGES_END */
    }

    RRM_UT_TRACE_EXIT();   
}

    rrm_return_et
rrm_ue_resource_clean_up(
        rrm_ue_context_t    *p_ue_context
        )
{
    rrm_return_et               ret_val         = RRM_SUCCESS;
    rrm_ue_index_t              ue_index        = RRM_NULL;
    rrm_cell_index_t            cell_index      = RRM_NULL;
    /* SPR 21527 Start */
    U16                         num_active_ue   = RRM_NULL;
    /* SPR 21527 End */
    /* Soft Lock start - Global variable removal */
    rrm_cell_context_t    *p_cell_ctxt  = RRM_PNULL;
    /* Bug_944_Start */
    rrm_best_cell_for_ue_node_t         *p_best_cell    = RRM_PNULL;
    /* Bug_944_End */

    /*SPR 15994 Fix start*/
    YLNODE *p_node = RRM_PNULL;
    YLNODE *p_tmp_node = RRM_PNULL;
    /*SPR 15994 Fix stop*/
    /* SPR 18747 Fix Start */
    meas_report_info_node_t *p_cell_to_add_mode_node = RRM_PNULL;
    YLNODE *p_inner_node = RRM_PNULL;
    YLNODE *p_tmp_inner_node = RRM_PNULL;
    /* SPR 18747 Fix End */
    /* SPR 22491 Fix Start */
    rrm_ue_global_context_t   *p_ue_glb_ctxt = rrm_uem_get_ctxt(RRM_UEM_MODULE_ID);
    /* CID 118463 Fix Start */
    if(RRM_PNULL == p_ue_glb_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                "UE global context not found");
        return RRM_FAILURE;
    }
    /* CID 118463 Fix End */
    /* SPR 22491 Fix End */

    p_cell_ctxt =  rrm_cellm_get_cell_context(p_ue_context->cell_index);
    if (RRM_PNULL == p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                "Cell Context not found");
        return RRM_FAILURE;
    }
    /* Soft Lock end - Global variable removal */

    RRM_UT_TRACE_ENTER();

    ue_index = p_ue_context->ue_index;
    cell_index = p_ue_context->cell_index;
    /* Bug_944_Start */
    /* SPR_14041_change_start */
    /* SPR_14041_change_start */
    /* cleaning best cell for ue freq list */
    if(RRM_ZERO != ylCount(&p_ue_context->best_cell_for_ue))
    {
        while(RRM_PNULL != (p_best_cell = (rrm_best_cell_for_ue_node_t *)ylPopHead(&p_ue_context->best_cell_for_ue)))
        {
            RRM_MEM_FREE(p_best_cell);
        }
    }
    /* SPR_14041_change_stop */

    /* cleaning best cell for ue freq list */
    if(RRM_ZERO != ylCount(&p_ue_context->best_cell_for_ue))
    {
        while(RRM_PNULL != (p_best_cell = (rrm_best_cell_for_ue_node_t *)ylPopHead(&p_ue_context->best_cell_for_ue)))
        {
            RRM_MEM_FREE(p_best_cell);
        }
    }
    /* SPR_14041_change_stop */
    /* Bug_944_End */

    /**CLPC_MR_START*/
    rrm_de_allocate_tpc_rnti(
            p_ue_context->rrm_ue_clpc_params.tpc_rnti_pucch,
            p_ue_context->rrm_ue_clpc_params.tpc_rnti_pusch,
            p_ue_context->rrm_ue_clpc_params.
            tpc_rnti_index_pucch,
            p_ue_context->rrm_ue_clpc_params.
            tpc_rnti_index_pusch,
            cell_index);
    /**CLPC_MR_END**/
    /* SPR 21112 Fix Start */
	/*SPR_8372_CHANGES_START*/
	p_cell_ctxt->kpi_stat.kpi.num_of_erb_release_success +=
		p_ue_context->drb_configured.num_of_list;
	/*SPR_8372_CHANGES_END*/
	/* UE positioning */
	rrm_clean_ue_all_ecid_meas_related_info(p_ue_context);

	ret_val = rrm_ue_clean_esmlc_meas_queue(p_ue_context);   /* Delete ESMLC meas req queue */
	if(RRM_FAILURE == ret_val)
	{
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
				"UE_INDEX[%d], Failure in deleting ESMLC meas request queue on UE release",  
				ue_index);
	}
	/* UE positioning */

    /* SPR 21112 Fix Stop */
    /*csg start*/
    rrm_decrease_csg_non_csg_counter(p_ue_context);
    /*csg end*/
    /* Freq-Priority fix changes start  */
    rrm_ue_release_gap_offset(p_ue_context);
    rrm_ue_stop_ho_timers(p_ue_context);
    /* Freq-Priority fix changes end  */

    /* SPR 21112 Fix Start */
    if (RRM_PNULL != p_ue_context->csg_subscription_expiry_timer)
    {
    /* SPR-17852 END */
/* SPR 20636 Changes Start*/
		RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
				"Stoping CSG subscription expiry timer[0x%u] for ue_index = %u",
				(U32_U32Long_Bit)p_ue_context->csg_subscription_expiry_timer,ue_index);
/* SPR 20636 Changes End*/
		/* CSR-58333-fix start*/
		rrm_ue_stop_timer(p_ue_context->csg_subscription_expiry_timer);
		/* CSR-58333-fix end*/
		p_ue_context->csg_subscription_expiry_timer = RRM_PNULL;
	}

        if (RRM_PNULL != p_ue_context->carrier_redirect_ue)
        {
            /* SPR-17852 END */
		{
			/* CSR-58333-fix start*/
			rrm_ue_stop_timer(p_ue_context->carrier_redirect_ue);
			/* CSR-58333-fix end*/
			p_ue_context->carrier_redirect_ue = RRM_PNULL;
		}
		/*Free the list*/
		while(RRM_PNULL != (p_best_cell = (rrm_best_cell_for_ue_node_t *)ylPopHead(&p_ue_context->best_cell_for_ue)))
		{
			RRM_MEM_FREE(p_best_cell);	
		}
	}
    /* SPR 21112 Fix Stop */

    ret_val = rrm_ue_clean_proc_queue(p_ue_context);

    /* Deleting the ue entry from the UE piority List */
    /* SPR 17564 Fix Start */
    if (RRM_FALSE == rrm_is_ue_special_previledge(p_ue_context))
        /* SPR 17564 Fix End */
    {
        if(RRM_FAILURE == rrm_ue_delete_ue_from_priority_list(p_ue_context))
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "[UE:%d],Failure in Deletetion from priority List",
                    ue_index);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d],Deletion not required from priority List",
                ue_index);
    }
    /* Deleting All erbs for the released UE from erb priority list*/
    if(RRM_SUCCESS == rrm_ue_update_erb_priority_list(p_ue_context))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "All erbs deleted successfully");
    }

    /* SPR 21112 Fix Start */
	if( p_ue_context->ue_ho_current_state == RRM_HO_STATE_WAIT_FOR_REL )
	{
		rrm_raise_event_ho_out_exec_complete();/*SPR 17777 +-*/
	}

    /* SPR 21112 Fix Stop */

    /*bug 10104 Fix - Start */
    if(RRM_PNULL != p_ue_context->current_procedure.p_erb_success_list)
    {
        RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_success_list);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED," erb_success_list is empty ");
    }

    if(RRM_PNULL != p_ue_context->current_procedure.p_erb_failed_list)
    {
        RRM_MEM_FREE(p_ue_context->current_procedure.p_erb_failed_list);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"erb_failed_list is empty");
    }

    /* SPR 21112 Fix Start */
	/* SPR 16373 FIX START */
	/* Check and Decrement ANR Counter if any Anr is ongoing*/
	rrm_check_and_dec_num_anr_strong_cell_req_count(p_ue_context);
	/* SPR 16373 FIX END */
    /* SPR 21112 Fix Stop */


    /*SPR 15994 Fix start*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Before Cleanup:Meas Report List size:%u",ylCount(&(p_ue_context->meas_report_list)));
    p_node = ylFirst(&(p_ue_context->meas_report_list));
    while (RRM_PNULL !=  p_node)
    {
        /* SPR 18747 Fix Start */
        p_cell_to_add_mode_node = YMEMBEROF(meas_report_info_node_t, sNode, p_node);
        p_inner_node = ylFirst(&p_cell_to_add_mode_node->cells_to_add_mod_list);
        while(p_inner_node)
        {
            p_tmp_inner_node = p_inner_node;
            p_inner_node = ylNext(p_inner_node);
            ylDelete(&p_cell_to_add_mode_node->cells_to_add_mod_list,p_tmp_inner_node);
            RRM_MEM_FREE(p_tmp_inner_node);
        }
        /* SPR 18747 Fix End */
        p_tmp_node = p_node;
        p_node = ylNext(p_node);
        ylDelete(&(p_ue_context->meas_report_list),p_tmp_node);
        RRM_MEM_FREE(p_tmp_node);
    }
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "After Cleanup:Meas Report List size:%u",ylCount(&(p_ue_context->meas_report_list)));
    /*SPR 15994 Fix stop*/

    /* SPR 21496 Fix Start */
    rrm_ue_release_ue_capability_params(p_ue_context);
    /* SPR 21496 Fix End */

    /*SPR 17917 +-*/
    /* SPR 15441 start */
    /* code removed */
    /* SPR 15441 end */
    /*bug 10104 Fix - End */
    if(ret_val == RRM_SUCCESS)
    {
        ret_val = rrm_ue_delete_context(cell_index,ue_index);
        /* SPR 23640/SES-475 Fix +- */
    }

    /* Get Num Active UE count from Cell Context */
    /* SPR 21527 Start */
    num_active_ue = rrm_cellm_get_num_active_ue(cell_index);
    /* SPR 21527 End */

    if((RRM_SUCCESS == ret_val) && (RRM_ZERO == num_active_ue))
    {
        /*SPR 19819 START*/
        p_cell_ctxt->cell_resource_info.ul_allocated_gbr_prb = RRM_ZERO;
        p_cell_ctxt->cell_resource_info.dl_allocated_gbr_prb = RRM_ZERO;
        p_cell_ctxt->cell_resource_info.ul_allocated_ngbr_prb = RRM_ZERO;
        p_cell_ctxt->cell_resource_info.dl_allocated_ngbr_prb = RRM_ZERO;
        p_cell_ctxt->cell_resource_info.dl_gbr_prb_in_use = RRM_ZERO;
        p_cell_ctxt->cell_resource_info.ul_gbr_prb_in_use = RRM_ZERO;
        p_cell_ctxt->cell_resource_info.dl_ngbr_prb_in_use = RRM_ZERO;
        p_cell_ctxt->cell_resource_info.ul_ngbr_prb_in_use = RRM_ZERO;
        p_cell_ctxt->cell_resource_info.used_gbr_limit.used_dl_gbr_limit = RRM_ZERO;
        p_cell_ctxt->cell_resource_info.used_gbr_limit.used_ul_gbr_limit = RRM_ZERO;
        /*SPR 19819 END*/

       /*SPR 21640 Fix Start*/   
       /* SPR 21112 Fix Start */
       /* Code Remove */
       /* SPR 21112 Fix Stop */
       /*SPR 21640 Fix Stop*/

        if (p_cell_ctxt->administrative_procedure_ongoing)
        {
            /* SPR-17852 START */
            /* STOP GLOBAL TIMER and Wait for A4 report Timer (If running ) and Send Response success to MIF */
            /* SPR-20656 START */
            /* code deleted */
            /* SPR-20656 END */
            if (RRM_PNULL != g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_HO_TIMER])
            {
                rrm_ue_stop_timer (g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_HO_TIMER]);
                /* CSR-58333-fix end*/
                g_uem_gbl_proc.rrm_timer_id[RRM_UE_CELL_BLOCKED_W_FOR_HO_TIMER] = RRM_PNULL;
            }
            /* SPR-17852 END */

            /* Soft Lock start - Global variable removal */
            p_cell_ctxt->administrative_procedure_ongoing = RRM_FALSE;
            /* Soft Lock end - Global variable removal */

            ret_val = rrm_uem_send_rmif_non_emrgncy_active_calls_ho_resp (g_uem_gbl_proc.trans_id,
                    g_uem_gbl_proc.cell_index,
                    RRM_TRUE);
            if (RRM_SUCCESS == ret_val)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "UEM Successfully sent non_emrgncy_active_calls_ho_resp to MIF");
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                        "UEM Failed to Send non_emrgncy_active_calls_ho_resp to MIF");
            }
        }

        rrmuem_rmif_no_active_ue_ind_t *p_rrmuem_rmif_no_active_ue_ind = RRM_PNULL;
        /* BUG_11576_FIX_START */
        p_rrmuem_rmif_no_active_ue_ind = rrm_mem_get
            (sizeof(rrmuem_rmif_no_active_ue_ind_t));
        /* BUG_11576_FIX_END */

        if(RRM_PNULL == p_rrmuem_rmif_no_active_ue_ind)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
            return RRM_FAILURE;
        }

        RRM_MEMSET(p_rrmuem_rmif_no_active_ue_ind, RRM_ZERO,
                sizeof(rrmuem_rmif_no_active_ue_ind_t));

        p_rrmuem_rmif_no_active_ue_ind->cell_index = cell_index;
        if(RRM_FAILURE == rrm_uem_send_internal_msg(RRM_MIF_MODULE_ID,
                    RRMUEM_RMIF_NO_ACTIVE_UE_IND,
                    sizeof(rrmuem_rmif_no_active_ue_ind_t),
                    p_rrmuem_rmif_no_active_ue_ind))
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "Failed to send RRMUEM_RMIF_NO_ACTIVE_UE_IND to MIF"); /* Coverity: CID 29031 */
        }

        /* COVERITY : RESOURCE_LEAK : CID : 48270 start */
        /* BUG_11576_FIX_START */
        RRM_MEM_FREE(p_rrmuem_rmif_no_active_ue_ind);
        /* SPR_14041_change_start */
        p_rrmuem_rmif_no_active_ue_ind = RRM_PNULL;
        /* SPR_14041_change_stop */
        /* BUG_11576_FIX_END */
        /* COVERITY : RESOURCE_LEAK : CID : 48270 end */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPS related changes start */
/******************************************************************************
 *   FUNCTION NAME: rrm_ue_reset_sps_info
 *   DESCRIPTION:   This function resets the UE SPS inforamtion 
 ******************************************************************************/
void
rrm_ue_reset_sps_info
( 
 rrm_ue_context_t *p_ue_context 
 )
{
    RRM_UT_TRACE_ENTER();
    if(p_ue_context != RRM_PNULL)
    {
        p_ue_context->ue_sps_data.is_sps_erab_established = RRM_FALSE;
        p_ue_context->ue_sps_data.sps_erab_highest_arp_priority = RRM_ZERO;
        p_ue_context->ue_sps_data.sps_erab_highest_qci_priority= RRM_ZERO;
        p_ue_context->ue_sps_data.sps_erab_id = RRM_OUT_OF_RANGE;  //0xFF;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"NULL UE context");
    }
    RRM_UT_TRACE_EXIT();
}

#ifdef ENDC_ENABLED
/******************************************************************************
 * Function Name  : rrm_update_qci_pos_in_stats 
 * Inputs         : qci : qci value for which position is to be updated
 *                  rrm_qci_pos_in_stats: structure to update 
 * Description    : Updates qci position in pdcp stats
 * Outputs        : NONE
 ******************************************************************************/
rrm_void_t
rrm_update_qci_pos_in_stats
(
    rrm_ue_index_t ue_index,
    U8 qci,
    rrm_qci_data_in_stats_t *p_rrm_qci_data_in_stats,
    U16 *p_stats_idx
)
{
    U16 count = RRM_ZERO;
    U16 ue_position = 0xFF;

    RRM_UT_TRACE_ENTER();

        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
        "Check If UE[%d] is alerady isn stats table \n",ue_index);
    for( count = RRM_ZERO ;  count < p_rrm_qci_data_in_stats->ue_count; count++ )
    {
        if( ue_index == p_rrm_qci_data_in_stats->rrm_qci_pos[count].ue_index)
        {
            ue_position = count;
            break; 
        }
    }
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
    "ue_position in stats table is [%d] ",ue_position);
    if( 0xFF != ue_position)
    {
        p_rrm_qci_data_in_stats->rrm_qci_pos[ue_position].rrm_qci_pos_in_ue[qci - RRM_ONE].pos++;
    }
    else
    {
        ue_position =  p_rrm_qci_data_in_stats->ue_count;
        p_rrm_qci_data_in_stats->rrm_qci_pos[ue_position].ue_index=ue_index;
        p_rrm_qci_data_in_stats->rrm_qci_pos[ue_position].rrm_qci_pos_in_ue[qci - RRM_ONE].pos++;
        p_rrm_qci_data_in_stats->ue_count++;
    }

    *p_stats_idx = ue_position;
    RRM_UT_TRACE_EXIT();
}

rrm_void_t
rrm_swap_integers
(
   U8 *num1,
   U8 *num2
) 
{ 
    U8 temp =  RRM_ZERO;
    temp = *num1;
    *num1 = *num2; 
    *num2 = temp; 
} 
  
// A function to implement bubble sort 
rrm_void_t
sort_an_integer_list(U8 p_list[], U8 list_count) 
{
   U8 count1 = RRM_ZERO; 
   U8 count2 = RRM_ZERO; 
   for (count1 = RRM_ZERO; count1 < list_count-1; count1++)       
   {  
       // Last count1 elements are already in place    
       for (count2 = RRM_ZERO; count2 < list_count-count1 - RRM_ONE; count2++)
       { 
           if (p_list[count2] > p_list[count2 + RRM_ONE]) 
           {
               rrm_swap_integers(&p_list[count2], &p_list[count2 + RRM_ONE]); 
           }
       }
   }
} 

U8
get_lcid_for_qci_of_pdcp_stats
(
    rrm_ue_context_t *p_ue_context,
    U8 qci ,
    U8 pos_in_stats
)
{
    U8 sorted_lc_id[RRM_MAX_NUM_DRB_PER_UE];
    U8 sorted_lc_id_count = RRM_ZERO;
    U8 erab_count = RRM_ZERO;
    U8 lc_id = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    RRM_MEMSET(sorted_lc_id,RRM_ZERO,sizeof(U8) *RRM_MAX_NUM_DRB_PER_UE);

    for( erab_count = RRM_ZERO; erab_count < p_ue_context->drb_configured.num_of_list; erab_count++)
    {
        if(qci == p_ue_context->drb_configured.erab_item[erab_count].erab_level_qos_params.qci)
        {
            sorted_lc_id[sorted_lc_id_count] = p_ue_context->drb_configured.erab_item[erab_count].lc_id;
            sorted_lc_id_count++;
        }
    }

    /* sort the lc id array */
    sort_an_integer_list(sorted_lc_id,sorted_lc_id_count);
    lc_id = sorted_lc_id[pos_in_stats - RRM_ONE];

    RRM_UT_TRACE_EXIT();
    return lc_id;
}

/******************************************************************************
 * Function Name  : rrm_cellm_update_qci_thp_of_ue 
 * Inputs         : cell_index, ue_index 
 *                : max_dl_thp, max_ul_thp
 * Description    : Updates qci throughput of UE.
 * Outputs        : NONE
 ******************************************************************************/
rrm_void_t
rrm_cellm_update_qci_thp_of_ue
(
    rrm_cell_index_t cell_index,
    rrm_ue_index_t ue_index,
    U8  qci,
    U16 stats_idx,
    rrm_qci_data_in_stats_t *p_rrm_qci_data_in_stats,
    U64 pdcpSduBitUl,
    U64 pdcpSduBitDl
)
{
    rrm_ue_context_t             *p_ue_context = RRM_PNULL;
    rrm_cell_context_t  *p_cell_context = rrm_cellm_get_cell_context(cell_index);
    rrm_ue_throughput_reports_t *p_tem_ue_rep = RRM_PNULL;
    rrm_ue_throughput_reports_t *p_final_ue_rep = RRM_PNULL;
    U8     report_idx    = 0xFF;
    U8     report_count  = RRM_ZERO;
    U8     min_rep_count = RRM_ZERO;
    U8     lc_id = 0xFF;
    U8     drb_index     = RRM_ZERO;
    endc_eligible_erab_list_t erb_change_list[RRM_MAX_NUM_DRB_PER_UE] ;
    U8                      erb_change_list_count = RRM_ZERO;
    /* coverity_280111_fix_start */
    RRM_MEMSET(erb_change_list, RRM_ZERO, sizeof(endc_eligible_erab_list_t));
    /* coverity_280111_fix_end */
    RRM_UT_TRACE_ENTER();

    if (RRM_PNULL != p_cell_context)
    {
        p_ue_context = rrm_ue_find_context(ue_index,
                cell_index);

        if(p_ue_context != RRM_PNULL)
        {
            min_rep_count = p_cell_context->operator_info.endc_info.min_num_ue_thp_report;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Report count configured from OAM is [%d] \n",min_rep_count);

            p_tem_ue_rep = &(p_ue_context->rrm_endc_nr_data.rrm_ue_temp_reports.rrm_ue_throughput_reports);
            p_final_ue_rep = &(p_ue_context->rrm_endc_nr_data.rrm_ue_final_reports.rrm_ue_throughput_reports);

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Report [%d] recieved from PDCP \n",p_ue_context->rrm_endc_nr_data.bearer_thp_report_count + RRM_ONE);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Save the reports in UE context\n");
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "For UE[%d] and QCI [%d], RAB number is [%d] \n",
                         p_ue_context->ue_index,qci,p_rrm_qci_data_in_stats->\
                         rrm_qci_pos[stats_idx].\
                         rrm_qci_pos_in_ue[qci-RRM_ONE].pos);

                lc_id  = get_lcid_for_qci_of_pdcp_stats(p_ue_context,qci ,
                        p_rrm_qci_data_in_stats->\
                        rrm_qci_pos[stats_idx].\
                        rrm_qci_pos_in_ue[qci-RRM_ONE].\
                        pos);
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Check for qci[%d] and lcid [%d] in stats in UE context\n",
                        qci,lc_id);

                for(report_count = 0 ; report_count < p_tem_ue_rep->count; report_count++)
                { 
                    /* match qci and lc id*/
                    if( (qci == p_tem_ue_rep->rrm_ue_qci_reports[report_count].qci ) 
                            &&
                            ( lc_id ==  p_tem_ue_rep->rrm_ue_qci_reports[report_count].lc_id)                      )
                    {
                        report_idx = report_count;
                        break;
                    } 
                }

                if(0xFF == report_idx)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "New entry for report_idx [%d] qci[%d] and lcid [%d] in stats in UE context  pdcpSduBitDl [%llu] pdcpSduBitUl[%llu] \n",report_idx,
                        qci,lc_id,pdcpSduBitDl,pdcpSduBitUl);
                    report_idx = p_tem_ue_rep->count;
                    p_tem_ue_rep->rrm_ue_qci_reports[report_idx].dl_bitrate = pdcpSduBitDl;
                    p_tem_ue_rep->rrm_ue_qci_reports[report_idx].ul_bitrate = pdcpSduBitUl;
                    p_tem_ue_rep->rrm_ue_qci_reports[report_idx].qci = qci;
                    p_tem_ue_rep->rrm_ue_qci_reports[report_idx].lc_id = lc_id;
                    p_tem_ue_rep->count++;
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "update existing entry for report_idx[%d] qci[%d] and lcid [%d] in stats in UE context. pdcpSduBitDl [%llu] pdcpSduBitUl[%llu] \n",report_idx,
                        qci,lc_id,pdcpSduBitDl,pdcpSduBitUl);
                    p_tem_ue_rep->rrm_ue_qci_reports[report_idx].dl_bitrate += pdcpSduBitDl;
                    p_tem_ue_rep->rrm_ue_qci_reports[report_idx].ul_bitrate += pdcpSduBitUl;
                }


                p_ue_context->rrm_endc_nr_data.bearer_thp_report_count++;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Current num of bearer throuput rep [%d] \n",
                     p_ue_context->rrm_endc_nr_data.bearer_thp_report_count);

            if(p_ue_context->rrm_endc_nr_data.bearer_thp_report_count ==
                    min_rep_count)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Average the qci throughput reports in UE context\n");

                /* Average the stats */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "p_tem_ue_rep->count [%d] \n",p_tem_ue_rep->count);

                for(report_count = 0 ; report_count < p_tem_ue_rep->count; report_count++)
                { 
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "TEMP : dl stat [%llu] ul stat [%llu] \n",
                            p_tem_ue_rep->rrm_ue_qci_reports[report_count].dl_bitrate ,
                            p_tem_ue_rep->rrm_ue_qci_reports[report_count].ul_bitrate);
                    p_final_ue_rep->rrm_ue_qci_reports[report_count].qci =
                           p_tem_ue_rep->rrm_ue_qci_reports[report_count].qci;
                    p_final_ue_rep->rrm_ue_qci_reports[report_count].lc_id =
                          p_tem_ue_rep->rrm_ue_qci_reports[report_count].lc_id ;

                    p_final_ue_rep->rrm_ue_qci_reports[report_count].dl_bitrate = 
                        p_tem_ue_rep->rrm_ue_qci_reports[report_count].dl_bitrate / 
                        p_ue_context->rrm_endc_nr_data.bearer_thp_report_count;
                    p_final_ue_rep->rrm_ue_qci_reports[report_count].ul_bitrate = 
                        p_tem_ue_rep->rrm_ue_qci_reports[report_count].ul_bitrate / 
                        p_ue_context->rrm_endc_nr_data.bearer_thp_report_count;
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "Final: dl stat [%llu] ul stat [%llu] \n",
                            p_final_ue_rep->rrm_ue_qci_reports[report_count].dl_bitrate, 
                            p_final_ue_rep->rrm_ue_qci_reports[report_count].ul_bitrate); 

                }
                p_final_ue_rep->count = p_tem_ue_rep->count;
                p_ue_context->rrm_endc_nr_data.bearer_thp_report_count = RRM_ZERO;
                RRM_MEMSET(p_tem_ue_rep, RRM_ZERO, sizeof(rrm_ue_throughput_reports_t));

                /* Check for database assisted or meas assisted sgnb addition */
/* NR_BAND_FIX_START */
                if( RRM_TRUE ==
                        rrm_check_trigger_to_configure_nr_database(p_ue_context,\
                            TRIGGER_TYPE_ERAB_THROUGHPUT,0xFF))
                {
                    /* if here , trigger dc bearer change req */
                    rrm_build_list_of_selected_erabs(p_ue_context,erb_change_list,&erb_change_list_count);
/* NR_REP_CONFIG_FIX_START */
                    if ( (erb_change_list_count > RRM_ZERO ) && 
(RRM_SUCCESS == rrm_check_is_configured_peer_gnb_pci_valid(p_ue_context->cell_index)))
/* NR_REP_CONFIG_FIX_END */
                    {
                        if(RRM_FAILURE ==
                                rrm_build_and_send_dc_bearer_change_req(p_ue_context,\
                                    erb_change_list,erb_change_list_count,\
                                    RRM_NULL,RRM_NULL))
                        {
                            for(drb_index=0;drb_index<erb_change_list_count;drb_index++)
                            {
                                p_ue_context->drb_configured.\
                                    erab_item[erb_change_list[drb_index].drb_index].\
                                    new_lc_id = RRM_ZERO;
                                p_ue_context->drb_configured.\
                                    erab_item[erb_change_list[drb_index].drb_index].\
                                    new_drb_id = RRM_ZERO;
                            }
                        }
                    }
                }
                else if( RRM_TRUE == 
/* NR_BAND_FIX_END */
                        rrm_check_trigger_to_configure_nr_meas(p_ue_context,TRIGGER_TYPE_ERAB_THROUGHPUT))
                {
                    rrm_build_and_send_meas_config_req_for_endc(p_ue_context,MEAS_REP_EVENT_B1_NR);
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "No need to trigger sgnb addition or measurements ");
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_build_and_send_meas_config_req_for_endc 
 * Inputs         : p_ue_context     UE context
 *                  meas_rep_event   Meas report event
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Builds and sends meas config req for NR measurements.
 ****************************************************************************/
rrm_return_et 
rrm_build_and_send_meas_config_req_for_endc
(
 rrm_ue_context_t*            p_ue_context, 
 rrmc_meas_report_event_et    meas_rep_event
 )
{
    U16                         transaction_id            = RRM_NULL;
    rrm_return_et               ret_val                   = RRM_FAILURE;
    rrc_rrm_meas_config_req_t*  p_rrc_rrm_meas_config_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /* Allocate memory for meas config request */
    p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*)
                                 rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));

    if (RRM_PNULL == p_rrc_rrm_meas_config_req)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                  "Failed to Allocate Memory");
        return RRM_FAILURE;
    }

    RRM_MEMSET(p_rrc_rrm_meas_config_req, RRM_NULL, sizeof(rrc_rrm_meas_config_req_t));

    /* Set the UE index in meas config request */
    p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;

    /* Generate new transaction id for the request */
    transaction_id                      = rrm_generate_txn_id();

    if (meas_rep_event == MEAS_REP_EVENT_B1_NR)
    {
        if( RRM_SUCCESS == 
                fill_eutra_nr_meas_info(&(p_rrc_rrm_meas_config_req->meas_config),
                                        p_ue_context))
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Measurements are configured successfully \n");
            p_ue_context->rrm_endc_nr_data.rrm_endc_nr_meas_stats.\
                nr_meas_req_status = RRM_NR_MEAS_REQ_FILLED;

            /* Send meas config request to RRC */
            ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                    RRM_MODULE_ID, 
                    RRC_MODULE_ID, 
                    transaction_id,
                    p_ue_context->cell_index);

            if (ret_val == RRM_FAILURE)
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to send MEAS CONFIG REQUEST for UE_INDEX[%d]",
                        p_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Successfully sent MEAS CONFIG REQUEST for UE_INDEX[%d]",
                        p_ue_context->ue_index);

                p_ue_context->rrm_endc_nr_data.\
                  rrm_endc_nr_meas_stats.nr_meas_req_status = RRM_NR_MEAS_REQ_INITIATED;
                p_ue_context->meas_status             = RRM_MEAS_CONFIG_REQ_SENT;
                p_ue_context->current_procedure.state = RRM_UE_MEAS_CONFIG_REQ_ONGOING;
            }
        }
    }

    RRM_UT_TRACE_EXIT();
    /* coverity_280106_fix_start */
    RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
    /* coverity_280106_fix_end */
    return ret_val;
}
#endif

/* SPS related changes end */
/*LTE_RRM_CQI_CHANGE_END*/
/* MC,MR & HO END  */ 
/*ECN load start */
/******************************************************************************
 * Function Name  : rrm_cellm_update_thp_of_ue 
 * Inputs         :cell_index, ue_index 
 *                : max_dl_thp, max_ul_thp
 * Description    : Updates throughput of UE.
 * Outputs        : NONE
 ******************************************************************************/
    rrm_void_t
rrm_cellm_update_thp_of_ue (rrm_cell_index_t cell_index,
        rrm_ue_index_t ue_index,
        U64 max_dl_thp,
        U64 max_ul_thp)
{
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t             *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    rrm_scell_active_deactive_t scell_active_deactive_list = {RRM_ZERO};
    /* CA: SCell Selection start */
    U64  ca_threshold_bitrate = RRM_ZERO;
    U8   num_times_threshold_not_crossed = RRM_ZERO;
    rrm_cell_context_t  *p_cell_context = rrm_cellm_get_cell_context(cell_index);
    /* CA: SCell Selection end */
    RRM_UT_TRACE_ENTER();
    /*CID 65885:start*/
    if (RRM_PNULL != p_cell_context)
    {
        /*spr-6860 ue_index and cell_index were called in 
          wrong order.Passed the variables in the proper order*/
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(ue_index,
                cell_index);
        if(p_ue_context != RRM_PNULL)
        {
            p_ue_context->ue_ecn_list.max_dl_thp = max_dl_thp;
            p_ue_context->ue_ecn_list.max_ul_thp = max_ul_thp;
            /*store the minimum of both ul and dl in min thp*/
            /* SPR 10869 start */
            if (p_ue_context->ue_ecn_list.max_dl_thp <
                    p_ue_context->ue_ecn_list.max_ul_thp)
            {
                /* SPR 10869 end */
                p_ue_context->ue_ecn_list.max_thp =
                    p_ue_context->ue_ecn_list.max_ul_thp;
            }
            else
            {
                p_ue_context->ue_ecn_list.max_thp =
                    p_ue_context->ue_ecn_list.max_dl_thp;

            }
            if ((p_cell_context->operator_info.ca_config.bitmask & RRM_IS_CA_ELIGIBLE_INFO_PRESENT) &&
                    (RRM_TRUE == p_cell_context->operator_info.ca_config.is_ca_eligible) && 
                    (RRM_UE_STATE_HO_ONGOING != p_ue_context->ue_state))
            {
                /*Ca stage3: start*/ 
                rrm_check_active_scell(&(p_ue_context->ue_scell_add_params),&scell_active_deactive_list);
                /*Ca stage3: end*/ 
                if (RRM_ZERO != scell_active_deactive_list.scell_active_count)
                {
                    ca_threshold_bitrate = 
                        p_ue_context->ue_ecn_list.max_dl_thp/(scell_active_deactive_list.scell_active_count + RRM_ONE);
                }
                else
                {
                    ca_threshold_bitrate = p_cell_context->operator_info.ca_config.ca_applicable_bitrate_dl;
                }
                /* CA: SCell Selection start */
                if(p_ue_context->ue_ecn_list.max_dl_thp > ca_threshold_bitrate)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "PDCP report indicates that OAM-configured threshold is exceeded");

                    p_ue_context->ca_data.num_of_times_threshold_exceeded++;

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "[PDCP IND block]num_of_times_threshold_exceeded: %d for [UE:%d]", 
                            p_ue_context->ca_data.num_of_times_threshold_exceeded,
                            p_ue_context->ue_index);

                    if (p_cell_context->operator_info.ca_config.num_of_report <= p_ue_context->ca_data.num_of_times_threshold_exceeded)
                    {
                        /* Reports were contiguous */
                        if (RRM_SUCCESS == rrm_check_for_ca_preconditions(p_ue_context, p_cell_context))
                        {
                            p_ue_context->ca_data.num_of_times_threshold_exceeded = RRM_ZERO;
                        }
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "PDCP report indicates that OAM-configured threshold is not exceeded");

                    p_ue_context->ca_data.num_of_times_threshold_not_exceeded++;
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "[PDCP IND block]num_of_times_threshold_not_exceeded: %d for [UE:%d]", 
                            p_ue_context->ca_data.num_of_times_threshold_not_exceeded,
                            p_ue_context->ue_index);

                    /* The counters are reset if the 75% of the consecutive
                     ** reports are below the threshold value */
                    num_times_threshold_not_crossed = (RRM_THREE * p_cell_context->operator_info.ca_config.num_of_report)/RRM_FOUR;

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "CELL_CONTEXT[num_of_report]: %d and num_times_threshold_not_crossed: %d",
                            p_cell_context->operator_info.ca_config.num_of_report,
                            num_times_threshold_not_crossed);

                    if(num_times_threshold_not_crossed <= p_ue_context->ca_data.num_of_times_threshold_not_exceeded)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "Resetting num_times_threshold_not_crossed as %d reports received below threshold",
                                p_ue_context->ca_data.num_of_times_threshold_not_exceeded);
                        p_ue_context->ca_data.num_of_times_threshold_exceeded     = RRM_ZERO;
                        p_ue_context->ca_data.num_of_times_threshold_not_exceeded = RRM_ZERO;
                    }
                }
                /* CA: SCell Selection end */
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Either Cell is not ca_eligible[%d] or UE state is HO_ONGOING[%d]",
                        p_cell_context->operator_info.ca_config.is_ca_eligible, p_ue_context->ue_state);

            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                    "UE context not found");
        }
        /* SPR 20652 Fix End */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
    }
    /*CID 65885:end*/
    RRM_UT_TRACE_EXIT();
}

/* SPR 10869 start */
    void
rrm_cell_cal_need_for_ecn(rrm_cell_context_t *p_cell_ctx,
        rrm_cell_load_def_t *p_load_def,
        U8 dir)
{
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t             *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    U16 index = RRM_ZERO;
    rrm_bool_et valid_ecn_value = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    for(index = RRM_ZERO;index < p_cell_ctx->cell_resource_info.num_active_ue;index++)
    {
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(p_cell_ctx->max_thp.ue_index[index],
                p_cell_ctx->cell_index);
        if (p_ue_context != RRM_PNULL)
        {
            switch(dir)
            {
                case ECN_APPLIED_IN_UL:
                    {
                        if ((RRM_ZERO != p_ue_context->ue_ecn_list.max_ul_thp)&&
                                (RRM_ZERO != p_ue_context->ue_avg_stats.uplinkSINRValue))
                        {
                            p_ue_context->ue_ecn_list.ul_value_for_ecn_set =
                                p_ue_context->ue_ecn_list.max_ul_thp/p_ue_context->ue_avg_stats.uplinkSINRValue;
                            valid_ecn_value = RRM_TRUE;
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, "Not settting UL ECN for [UE:%u]"
                                    "as One of the value is zero, UL"
                                    "SINR[%u], MAX UL THP[%llu]",
                                    p_ue_context->ue_index,
                                    p_ue_context->ue_avg_stats.uplinkSINRValue,
                                    p_ue_context->ue_ecn_list.max_ul_thp);
                        }
                    }
                    break;

                case ECN_APPLIED_IN_DL:
                    {
                        if((RRM_ZERO != p_ue_context->ue_ecn_list.total_downlinkSINRValue) &&
                                (RRM_ZERO != p_ue_context->ue_ecn_list.max_dl_thp))
                        {
                            p_ue_context->ue_ecn_list.dl_value_for_ecn_set  =
                                p_ue_context->ue_ecn_list.max_dl_thp/p_ue_context->ue_ecn_list.total_downlinkSINRValue;
                            valid_ecn_value = RRM_TRUE;
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                                    "Not settting DL ECN for [UE:%d] as one of the value is zero, DL SINR[%u], MAX DL THP[%llu]",
                                    p_ue_context->ue_index,
                                    p_ue_context->ue_ecn_list.total_downlinkSINRValue,
                                    p_ue_context->ue_ecn_list.max_dl_thp);
                        }
                    }
                    break;

                case ECN_APPLIED_IN_BOTH_UL_DL: 
                    {
                        if((RRM_ZERO != p_ue_context->ue_ecn_list.total_downlinkSINRValue) &&
                                (RRM_ZERO != p_ue_context->ue_ecn_list.max_dl_thp)&&
                                (RRM_ZERO !=
                                 p_ue_context->ue_avg_stats.uplinkSINRValue)
                                &&
                                (RRM_ZERO !=
                                 p_ue_context->ue_ecn_list.max_ul_thp)
                                &&
                                (RRM_ZERO
                                 !=
                                 p_ue_context->ue_ecn_list.max_thp))
                        {
                            p_ue_context->ue_ecn_list.dl_value_for_ecn_set  =
                                p_ue_context->ue_ecn_list.total_downlinkSINRValue/p_ue_context->ue_ecn_list.max_dl_thp
                                ;
                            p_ue_context->ue_ecn_list.ul_value_for_ecn_set
                                =
                                p_ue_context->ue_ecn_list.max_ul_thp/p_ue_context->ue_avg_stats.uplinkSINRValue;
                            if(p_ue_context->ue_ecn_list.total_downlinkSINRValue
                                    > p_ue_context->ue_avg_stats.uplinkSINRValue)
                            {
                                p_ue_context->ue_ecn_list.bidir_value_for_ecn_set
                                    =
                                    p_ue_context->ue_ecn_list.max_thp/p_ue_context->ue_avg_stats.uplinkSINRValue;
                                valid_ecn_value
                                    =
                                    RRM_TRUE;
                            }
                            else
                            {
                                p_ue_context->ue_ecn_list.bidir_value_for_ecn_set
                                    =
                                    p_ue_context->ue_ecn_list.max_thp/p_ue_context->ue_ecn_list.total_downlinkSINRValue;
                                valid_ecn_value
                                    =
                                    RRM_TRUE;
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, 
                                    "Not settting BI-ECN for [UE:%u] as one of the value is zero,"
                                    " DL SINR[%u], DL MAX THP[%llu], DL SINR[%u], DL MAX THP[%llu], MAX THP[%llu]",
                                    p_ue_context->ue_index,
                                    p_ue_context->ue_ecn_list.total_downlinkSINRValue,
                                    p_ue_context->ue_ecn_list.max_dl_thp,
                                    p_ue_context->ue_avg_stats.uplinkSINRValue,
                                    p_ue_context->ue_ecn_list.max_ul_thp,
                                    p_ue_context->ue_ecn_list.max_thp);
                        }
                    }
                    break;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                    "UE context not found");
        }
    }
    /* SPR 20652 Fix End */
    if (RRM_TRUE == valid_ecn_value)
    {
        switch(dir)
        {

            case ECN_APPLIED_IN_UL:
                rrm_sorting_ue_for_ecn_ul(p_load_def->num_of_usr, p_cell_ctx->cell_index);
                p_cell_ctx->cell_load_action.u.comp_load_info.actn_status |= RRMCM_ACTN_RRM_ECN_UL_DIR;
                break;

            case ECN_APPLIED_IN_DL:
                rrm_sorting_ue_for_ecn_dl(p_load_def->num_of_usr, p_cell_ctx->cell_index);
                p_cell_ctx->cell_load_action.u.comp_load_info.actn_status |= RRMCM_ACTN_RRM_ECN_DL_DIR;
                break;

            case ECN_APPLIED_IN_BOTH_UL_DL: 
                rrm_sorting_for_bidir_ecn(p_load_def->num_of_usr, p_cell_ctx->cell_index);
                p_cell_ctx->cell_load_action.u.comp_load_info.actn_status |= RRMCM_ACTN_RRM_ECN_BI_DIR;
                break;
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 10869 end */
    rrm_return_et 
rrm_send_pdcp_ecn_bidir_req(rrm_ue_context_t *p_ue_ctxt, U8 dir, U8 congestion_status)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 num_drb_configured = RRM_ZERO;
    RrmPdcpDrbEcnCeReq          pdcp_drb_ecn_req = {RRM_ZERO};
    RRM_UT_TRACE_ENTER();    

    pdcp_drb_ecn_req.ueIndex = p_ue_ctxt->ue_index;
    for( num_drb_configured = 0;num_drb_configured< p_ue_ctxt->drb_configured.num_of_list ;num_drb_configured++ ) 
    {
        /* Find lc_id for configured drb*/
        pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].lcId= 
            p_ue_ctxt->drb_configured.erab_item[num_drb_configured].lc_id; 
        /* SPR 19580 Changes Start */
        pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].direction=rrm_fill_dir_of_congestion_ecn(dir);
        /* SPR 19580 Changes End */
        pdcp_drb_ecn_req.ceLc[pdcp_drb_ecn_req.numOfLc].congestionStatus= congestion_status;
        pdcp_drb_ecn_req.numOfLc++;        
    }
    if (congestion_status == RRM_TRUE)
    {
        switch(dir)
        {
            case ECN_APPLIED_IN_DL:
                p_ue_ctxt->ue_ecn_list.ecn_applied_dir |= RRM_ACTION_ECN_DL_SET;
                break;
            case ECN_APPLIED_IN_UL:
                p_ue_ctxt->ue_ecn_list.ecn_applied_dir |= RRM_ACTION_ECN_UL_SET;
                break;
            case ECN_APPLIED_IN_BOTH_UL_DL: 
                p_ue_ctxt->ue_ecn_list.ecn_applied_dir |= RRM_ACTION_ECN_DL_UL_SET;
                break;
            default:
                break;
        }
    }
    else if (congestion_status == RRM_FALSE)
    {
        switch(dir)
        {
            case ECN_APPLIED_IN_DL:
                p_ue_ctxt->ue_ecn_list.ecn_applied_dir = 
                    p_ue_ctxt->ue_ecn_list.ecn_applied_dir & (~RRM_ACTION_ECN_DL_SET);
                break;
            case ECN_APPLIED_IN_UL:
                p_ue_ctxt->ue_ecn_list.ecn_applied_dir = 
                    p_ue_ctxt->ue_ecn_list.ecn_applied_dir & (~RRM_ACTION_ECN_UL_SET);
                break;
            case ECN_APPLIED_IN_BOTH_UL_DL: 
                p_ue_ctxt->ue_ecn_list.ecn_applied_dir = 
                    p_ue_ctxt->ue_ecn_list.ecn_applied_dir & (~RRM_ACTION_ECN_DL_UL_SET);
                break;
            default:
                break;
        }

    }
    /*Send request to PDCP*/
    ret_val = rrm_ue_send_drb_ecn_ce_req (&pdcp_drb_ecn_req, RRM_MODULE_ID,RRM_ZERO, p_ue_ctxt->cell_index);   

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
    rrm_void_t
rrm_sorting_for_bidir_ecn(U8 num_of_usr, rrm_cell_index_t cell_index)
{

    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context       = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* SPR 20652 Fix End */
    ue_ho_lst_node_t    *p_ho_ue            = RRM_PNULL;
    ue_ho_lst_node_t    *p_ho_new_ue        = RRM_PNULL;
    U16                 ue_ho_cnt           = RRM_NULL;
    YLIST               ue_ho_list;

    RRM_UT_TRACE_ENTER();

    ylInit(&ue_ho_list);
    /* SPR 20652 Fix Start */
    rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);

    /* Creating the ascending order list of path loss */
    while (RRM_PNULL != p_ue_context)
    {
        /* Check if UE is not already identified for an action */
        if ((cell_index == p_ue_context->cell_index) &&            
                (RRM_NO_ACTN_ON_UE == p_ue_context->action_triggered))
        {
            if (RRM_ZERO != ylCount(&ue_ho_list))
            {
                p_ho_ue = (ue_ho_lst_node_t*)ylLast(&ue_ho_list);
                if (p_ue_context->ue_ecn_list.bidir_value_for_ecn_set>=
                        p_ho_ue->p_ue_context->ue_ecn_list.bidir_value_for_ecn_set)
                {
                    /* if the ECN BOTH DIR is greater than the end node path loss then directly
                     * add node in the end
                     */
                    p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                    if(RRM_PNULL != p_ho_new_ue)
                    {
                        p_ho_new_ue->p_ue_context = p_ue_context;
                        ylPushTail(&ue_ho_list, &p_ho_new_ue->node);
                    }
                    else
                    {
                        /* COVERITY : RESOURCE LEAK : CID : 54370 fix start */
                        while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                        {
                            RRM_MEM_FREE(p_ho_ue);
                        }
                        /* COVERITY : RESOURCE LEAK : CID : 54370 fix end */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                                "Failed to allocate memory to p_ho_new_ue"); /* Coverity: CID 29572 */
                        return ;
                    }
                }
                else if ((RRM_PNULL != p_ho_new_ue) &&
                        (p_ue_context->ue_ecn_list.bidir_value_for_ecn_set >=
                         p_ho_new_ue->p_ue_context->ue_ecn_list.bidir_value_for_ecn_set))
                {
                    /* if the ECN BOTH DIR is greater than the last added node the start from
                     * this node till the end
                     */
                    p_ho_ue = p_ho_new_ue;
                    while (RRM_PNULL != p_ho_ue)
                    {
                        if (p_ue_context->ue_ecn_list.bidir_value_for_ecn_set <=
                                p_ho_ue->p_ue_context->ue_ecn_list.bidir_value_for_ecn_set)
                        {
                            p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                            if(RRM_PNULL != p_ho_new_ue) /* Coverity: CID 29572 */
                            {
                                p_ho_new_ue->p_ue_context = (rrm_ue_context_t *)p_ue_context;
                                ylInsertBefore(&ue_ho_list, &p_ho_ue->node, &p_ho_new_ue->node);
                            }
                            else
                            {
                                /* COVERITY : RESOURCE LEAK : CID : 54370 fix start */
                                while (RRM_PNULL != (p_ho_new_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                                {
                                    RRM_MEM_FREE( p_ho_new_ue );
                                }
                                /* COVERITY : RESOURCE LEAK : CID : 54370 fix end */
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                        "Failed to allocate memory to p_ho_new_ue");
                                return ;
                            }
                        }
                        p_ho_ue = (ue_ho_lst_node_t*)(ylNext(&p_ho_ue->node));
                    }
                }
                else
                {
                    /* Start from the head of the list */
                    p_ho_ue = (ue_ho_lst_node_t*)ylFirst(&ue_ho_list);
                    while (RRM_PNULL != p_ho_ue)
                    {
                        if (p_ue_context->ue_ecn_list.bidir_value_for_ecn_set <=
                                p_ho_ue->p_ue_context->ue_ecn_list.bidir_value_for_ecn_set)
                        {
                            p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                            if(RRM_PNULL != p_ho_new_ue)
                            {
                                p_ho_new_ue->p_ue_context = p_ue_context;
                                ylInsertBefore(&ue_ho_list, &p_ho_ue->node, &p_ho_new_ue->node);
                            }
                            else
                            {
                                /* COVERITY : RESOURCE LEAK : CID : 54370 fix start */
                                while (RRM_PNULL != ( p_ho_new_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                                {
                                    RRM_MEM_FREE( p_ho_new_ue );
                                }
                                /* COVERITY : RESOURCE LEAK : CID : 54370 fix end */
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                        "Failed to allocate memory to p_ho_new_ue");
                                return ;
                            }
                        }
                        p_ho_ue = (ue_ho_lst_node_t*)(ylNext(&p_ho_ue->node));
                    }
                }
            }
            else
            {
                /* List was empty so put node on head */
                p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                if(RRM_PNULL != p_ho_new_ue)
                {
                    p_ho_new_ue->p_ue_context = p_ue_context;
                    ylPushHead(&ue_ho_list,&p_ho_new_ue->node);
                }
                else
                {
                    /* COVERITY : RESOURCE LEAK : CID : 54370 fix start */
                    while (RRM_PNULL != ( p_ho_new_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                    {
                        RRM_MEM_FREE( p_ho_new_ue );
                    }
                    /* COVERITY : RESOURCE LEAK : CID : 54370 fix end */
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                            "Failed to allocate memory to p_ho_new_ue");
                    return ;
                }
            }
        }
        ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
        /* SPR 20652 Fix End */
    }
    /* Identify the set of UE for which ECN BOTH DIR needs to be triggered */
    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
    {
        if (p_ho_ue->p_ue_context->action_triggered == RRM_NO_ACTN_ON_UE)
        {
            if (RRM_SUCCESS ==
                    rrm_send_pdcp_ecn_bidir_req (p_ho_ue->p_ue_context, ECN_APPLIED_IN_BOTH_UL_DL, RRM_TRUE))
            {
                p_ho_ue->p_ue_context->action_triggered = RRM_ECN_UL_DL_ON_UE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                        "Triggered ECN Bi-Direction for [UE:%u]", p_ho_ue->p_ue_context->ue_index);
                /* Checking number of UE to be affected for the action */
                ue_ho_cnt++;
                if (num_of_usr == ue_ho_cnt)
                {
                    break;
                }
            }
            RRM_MEM_FREE(p_ho_ue);
        }
    }
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Triggered ECN Bi-Direction for [%u] UEs", ue_ho_cnt);
    /* Releasing Remaining from the list if any */
    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
    {
        RRM_MEM_FREE(p_ho_ue);
    }

    RRM_UT_TRACE_EXIT();
}
    rrm_void_t
rrm_sorting_ue_for_ecn_dl(U8 num_of_user, rrm_cell_index_t cell_index)
{
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context       = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* SPR 20652 Fix End */
    ue_ho_lst_node_t    *p_ho_ue            = RRM_PNULL;
    ue_ho_lst_node_t    *p_ho_new_ue        = RRM_PNULL;
    U16                 ue_ho_cnt           = RRM_NULL;
    YLIST               ue_ho_list;

    RRM_UT_TRACE_ENTER();

    ylInit(&ue_ho_list);
    /* SPR 20652 Fix Start */
    rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);

    /* Creating the ascending order list of path loss */
    while (RRM_PNULL != p_ue_context)
    {
        /* Check if UE is not already identified for an action */
        if ((cell_index == p_ue_context->cell_index) &&
                (RRM_NO_ACTN_ON_UE == p_ue_context->action_triggered))
        {
            if (RRM_ZERO != ylCount(&ue_ho_list))
            {
                p_ho_ue = (ue_ho_lst_node_t*)ylLast(&ue_ho_list);
                if (p_ue_context->ue_ecn_list.dl_value_for_ecn_set >=
                        p_ho_ue->p_ue_context->ue_ecn_list.dl_value_for_ecn_set)
                {
                    /* if the ECN DL is greater than the end node path loss then directly
                     * add node in the end
                     */
                    p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                    if(RRM_PNULL != p_ho_new_ue)
                    {
                        p_ho_new_ue->p_ue_context = p_ue_context;
                        ylPushTail(&ue_ho_list, &p_ho_new_ue->node);
                    }
                    else
                    {
                        /* COVERITY : RESOURCE LEAK : CID : 54371 fix start */
                        while (RRM_PNULL != ( p_ho_new_ue  = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                        {
                            RRM_MEM_FREE( p_ho_new_ue );
                        }
                        /* COVERITY : RESOURCE LEAK : CID : 54371 fix end */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                "Failed to allocate memory to p_ho_new_ue");
                        return ;
                    }
                }
                else if ((RRM_PNULL != p_ho_new_ue)&&
                        (p_ue_context->ue_ecn_list.dl_value_for_ecn_set >=
                         p_ho_new_ue->p_ue_context->ue_ecn_list.dl_value_for_ecn_set))
                {
                    /* if the ECN DL is greater than the last added node the start from
                     * this node till the end
                     */
                    p_ho_ue = p_ho_new_ue;
                    while (RRM_PNULL != p_ho_ue)
                    {
                        if (p_ue_context->ue_ecn_list.dl_value_for_ecn_set <=
                                p_ho_ue->p_ue_context->ue_ecn_list.dl_value_for_ecn_set)
                        {
                            p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                            if(RRM_PNULL != p_ho_new_ue)
                            {
                                p_ho_new_ue->p_ue_context = p_ue_context;
                                ylInsertBefore(&ue_ho_list, &p_ho_ue->node, &p_ho_new_ue->node);
                            }
                            else
                            {
                                /* COVERITY : RESOURCE LEAK : CID : 54371 fix start */
                                while (RRM_PNULL != ( p_ho_new_ue  = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                                {
                                    RRM_MEM_FREE( p_ho_new_ue );
                                }
                                /* COVERITY : RESOURCE LEAK : CID : 54371 fix end */
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                        "Failed to allocate memory to p_ho_new_ue");
                                return ;
                            }
                        }
                        p_ho_ue = (ue_ho_lst_node_t *)(ylNext(&p_ho_ue->node));
                    }
                }
                else
                {
                    /* Start from the head of the list */
                    p_ho_ue = (ue_ho_lst_node_t*)ylFirst(&ue_ho_list);
                    while (RRM_PNULL != p_ho_ue)
                    {
                        if (p_ue_context->ue_ecn_list.dl_value_for_ecn_set <=
                                p_ho_ue->p_ue_context->ue_ecn_list.dl_value_for_ecn_set)
                        {
                            p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                            if(RRM_PNULL != p_ho_new_ue) /* Coverity: CID 29573 */
                            {
                                p_ho_new_ue->p_ue_context = p_ue_context;
                                ylInsertBefore(&ue_ho_list, &p_ho_ue->node, &p_ho_new_ue->node);
                            }
                            else
                            {
                                /* COVERITY : RESOURCE LEAK : CID : 54371 fix start */
                                while (RRM_PNULL != ( p_ho_new_ue  = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                                {
                                    RRM_MEM_FREE( p_ho_new_ue );
                                }
                                /* COVERITY : RESOURCE LEAK : CID : 54371 fix end */
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                        "Failed to allocate memory to p_ho_new_ue");
                                return ;
                            }
                        }
                        p_ho_ue = (ue_ho_lst_node_t *)(ylNext(&p_ho_ue->node));
                    }
                }
            }
            else
            {
                /* List was empty so put node on head */
                p_ho_new_ue =
                    (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                if(RRM_PNULL != p_ho_new_ue)
                {
                    p_ho_new_ue->p_ue_context = p_ue_context;
                    ylPushHead(&ue_ho_list,&p_ho_new_ue->node);
                }
                else
                {
                    /* COVERITY : RESOURCE LEAK : CID : 54371 fix start */
                    while (RRM_PNULL != ( p_ho_new_ue  = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                    {
                        RRM_MEM_FREE( p_ho_new_ue );
                    }
                    /* COVERITY : RESOURCE LEAK : CID : 54371 fix end */
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                            "Failed to allocate memory to p_ho_new_ue");
                    return ;
                }
            }
        }
        ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
        /* SPR 20652 Fix End */
    }
    /* Identify the set of UE for which ECN DL needs to be triggered */
    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
    {
        if(RRM_NO_ACTN_ON_UE == p_ho_ue->p_ue_context->action_triggered)
        {
            if (RRM_SUCCESS ==
                    rrm_send_pdcp_ecn_bidir_req(p_ho_ue->p_ue_context,ECN_APPLIED_IN_DL, RRM_TRUE))
            {
                p_ho_ue->p_ue_context->action_triggered = RRM_ECN_DL_ON_UE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                        "Triggered ECN DL for [UE:%u]", p_ho_ue->p_ue_context->ue_index);
                /* Checking number of UE to be affected for the action */
                ue_ho_cnt++;
                if (num_of_user == ue_ho_cnt)
                {
                    break;
                }
            }
            RRM_MEM_FREE(p_ho_ue);
        }
    }
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Triggered ECN DL for [%u] UE", ue_ho_cnt);
    /* Releasing Remaining from the list if any */
    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
    {
        RRM_MEM_FREE(p_ho_ue);
    }

    RRM_UT_TRACE_EXIT();
}
    rrm_void_t
rrm_sorting_ue_for_ecn_ul(U8 num_of_usr, rrm_cell_index_t cell_index)
{
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context       = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* SPR 20652 Fix End */
    ue_ho_lst_node_t    *p_ho_ue            = RRM_PNULL;
    ue_ho_lst_node_t    *p_ho_new_ue        = RRM_PNULL;
    U16                 ue_ho_cnt           = RRM_NULL;
    YLIST               ue_ho_list;

    RRM_UT_TRACE_ENTER();

    ylInit(&ue_ho_list);
    /* SPR 20652 Fix Start */
    rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);

    /* Creating the ascending order list for ECN ul */
    while (RRM_PNULL != p_ue_context)
    {
        /* Check if UE is not already identified for an action */
        if ((cell_index == p_ue_context->cell_index) &&
                (RRM_NO_ACTN_ON_UE == p_ue_context->action_triggered))
        {
            if (RRM_ZERO != ylCount(&ue_ho_list))
            {
                p_ho_ue = (ue_ho_lst_node_t*)ylLast(&ue_ho_list);
                if (p_ue_context->ue_ecn_list.ul_value_for_ecn_set >=
                        p_ho_ue->p_ue_context->ue_ecn_list.ul_value_for_ecn_set)
                {
                    /* if the ecn ul is greater than the end node path loss then directly
                     * add node in the end
                     */
                    p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                    if(RRM_PNULL != p_ho_new_ue)
                    {
                        p_ho_new_ue->p_ue_context = p_ue_context;
                        ylPushTail(&ue_ho_list, &p_ho_new_ue->node);
                    }
                    else
                    {
                        /* COVERITY : RESOURCE LEAK : CID : 54372 fix start */
                        while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                        {
                            RRM_MEM_FREE(p_ho_ue);
                        }
                        /* COVERITY : RESOURCE LEAK : CID : 54372 fix end */
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                                "Failed to allocate memory to p_ho_new_ue");
                        return ;
                    }
                }
                else if ((RRM_PNULL != p_ho_new_ue) &&
                        (p_ue_context->ue_ecn_list.ul_value_for_ecn_set >=
                         p_ho_new_ue->p_ue_context->ue_ecn_list.ul_value_for_ecn_set))
                {
                    /* if the ecn ul is greater than the last added node the start from
                     * this node till the end
                     */
                    p_ho_ue = p_ho_new_ue;
                    while (RRM_PNULL != p_ho_ue)
                    {
                        if (p_ue_context->ue_ecn_list.ul_value_for_ecn_set <=
                                p_ho_ue->p_ue_context->ue_ecn_list.ul_value_for_ecn_set)
                        {
                            p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                            if(RRM_PNULL != p_ho_new_ue)
                            {
                                p_ho_new_ue->p_ue_context = p_ue_context;
                                ylInsertBefore(&ue_ho_list, &p_ho_ue->node, &p_ho_new_ue->node);
                            }
                            else
                            {
                                /* COVERITY : RESOURCE LEAK : CID : 54372 fix start */
                                while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                                {
                                    RRM_MEM_FREE(p_ho_ue);
                                }
                                /* COVERITY : RESOURCE LEAK : CID : 54372 fix end */
                                /*Cov_fix_63561_start*/
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                                        "Failed to allocate memory to p_ho_new_ue");
                                /*Cov_fix_63561_end*/
                                return ;
                            }
                        }
                        p_ho_ue = (ue_ho_lst_node_t *)(ylNext(&p_ho_ue->node));
                    }
                }
                else
                {
                    /* Start from the head of the list */
                    p_ho_ue = (ue_ho_lst_node_t*)ylFirst(&ue_ho_list);
                    while (RRM_PNULL != p_ho_ue)
                    {
                        if (p_ue_context->ue_ecn_list.ul_value_for_ecn_set <=
                                p_ho_ue->p_ue_context->ue_ecn_list.ul_value_for_ecn_set)
                        {
                            p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                            if(RRM_PNULL != p_ho_new_ue)
                            {
                                p_ho_new_ue->p_ue_context = p_ue_context;
                                ylInsertBefore(&ue_ho_list, &p_ho_ue->node, &p_ho_new_ue->node);
                            }
                            else
                            {
                                /* COVERITY : RESOURCE LEAK : CID : 54372 fix start */
                                while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                                {
                                    RRM_MEM_FREE(p_ho_ue);
                                }
                                /* COVERITY : RESOURCE LEAK : CID : 54372 fix end */
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                                        "Failed to allocate memory to p_ho_new_ue");
                                return ;
                            }
                        }
                        p_ho_ue = (ue_ho_lst_node_t *)(ylNext(&p_ho_ue->node));
                    }
                }
            }
            else
            {
                /* List was empty so put node on head */
                p_ho_new_ue =
                    (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                if(RRM_PNULL != p_ho_new_ue)
                {
                    p_ho_new_ue->p_ue_context = p_ue_context;
                    ylPushHead(&ue_ho_list,&p_ho_new_ue->node);
                }
                else
                {
                    /* COVERITY : RESOURCE LEAK : CID : 54372 fix start */
                    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
                    {
                        RRM_MEM_FREE(p_ho_ue);
                    }
                    /* COVERITY : RESOURCE LEAK : CID : 54372 fix end */
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                            "Failed to allocate memory to p_ho_new_ue");
                    return ;
                }
            }
        }
        ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
        /* SPR 20652 Fix End */
    }
    /* Identify the set of UE for which ECN UL needs to be triggered */
    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
    {
        if(RRM_NO_ACTN_ON_UE == p_ho_ue->p_ue_context->action_triggered)
        {
            if (RRM_SUCCESS ==
                    rrm_send_pdcp_ecn_bidir_req(p_ho_ue->p_ue_context, ECN_APPLIED_IN_UL, RRM_TRUE))
            {
                p_ho_ue->p_ue_context->action_triggered = RRM_ECN_UL_ON_UE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                        "Triggered ECN UL for [UE:%u]", p_ho_ue->p_ue_context->ue_index);
                /* Checking number of UE to be affected for the action */
                ue_ho_cnt++;
                if (num_of_usr == ue_ho_cnt)
                {
                    break;
                }
            }
            RRM_MEM_FREE(p_ho_ue);
        }
    }
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Triggered  ECN UL for [%u] UEs", ue_ho_cnt);
    /* Releasing Remaining from the list if any */
    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&ue_ho_list)))
    {
        RRM_MEM_FREE(p_ho_ue);
    }
    RRM_UT_TRACE_EXIT();
}
    rrm_return_et
rrm_ue_unset_ecn_bit (rrm_cell_index_t cell_index)/* SPR 20652 Fix +- */ 
{
    rrm_return_et               ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t            *p_ue_context = RRM_PNULL;
   rrm_seq_data_info_t         ue_node;
    RRM_UT_TRACE_ENTER();
   rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
    if(RRM_PNULL == p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "UE context is NULL");
        ret_val = RRM_FAILURE;
    }
    else
    {
        while(p_ue_context != RRM_PNULL)
        {
            if (p_ue_context->ue_ecn_list.ecn_applied_dir & RRM_ACTION_ECN_DL_SET)
            {
                ret_val = rrm_send_pdcp_ecn_bidir_req(p_ue_context,ECN_APPLIED_IN_DL,RRM_FALSE); 
            }
            else if(p_ue_context->ue_ecn_list.ecn_applied_dir & RRM_ACTION_ECN_UL_SET)
            {
                ret_val = rrm_send_pdcp_ecn_bidir_req(p_ue_context,ECN_APPLIED_IN_UL,RRM_FALSE); 
            }
            else if(p_ue_context->ue_ecn_list.ecn_applied_dir & RRM_ACTION_ECN_DL_UL_SET)
            {
                ret_val = rrm_send_pdcp_ecn_bidir_req(p_ue_context,ECN_APPLIED_IN_BOTH_UL_DL,RRM_FALSE); 
            }
           ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
        }
    }
    /* SPR 20652 Fix End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


    rrm_return_et 
rrm_sort_ue_for_ho_send_meas_config(
        rrm_cell_index_t cell_index,
        rrm_cell_load_def_t *p_load_def
        )
{   
    rrm_return_et       ret_val             = RRM_SUCCESS;
    /* SPR 20652 Fix Start */ 
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context       = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* SPR 20652 Fix End */ 
    ue_ho_lst_node_t    *p_ho_ue            = RRM_PNULL;
    ue_ho_lst_node_t    *p_ho_new_ue        = RRM_PNULL;
    U16                 ue_ho_cnt           = RRM_NULL;
    YLIST               csg_ue_ho_list;
    YLIST               non_csg_ue_ho_list;
    YLIST               *p_ue_ho_list       = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_load_def);

    ylInit(&non_csg_ue_ho_list);
    ylInit(&csg_ue_ho_list);
    /* SPR 20652 Fix Start */ 
    rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);

    /* Creating the ascending order list of path loss */
    while (RRM_PNULL != p_ue_context)
    {
        /* Check if UE is not already identified for an action */
        if ((p_ue_context->cell_index == cell_index) &&
                (RRM_NO_ACTN_ON_UE == p_ue_context->action_triggered))
        {
            /* SPR 17564 Fix Start */
            if (RRM_FALSE == rrm_is_ue_special_previledge(p_ue_context))
                /* SPR 17564 Fix End */
            {
                if (RRM_MEMBER == p_ue_context->rrm_csg_membership.rrm_csg_membership_status)
                {
                    p_ue_ho_list = &csg_ue_ho_list;
                }
                else
                {
                    p_ue_ho_list = &non_csg_ue_ho_list;
                }

                if (RRM_ZERO != ylCount(p_ue_ho_list))
                {
                    p_ho_ue = (ue_ho_lst_node_t*)ylLast(p_ue_ho_list);
                    /*+ Coverity CID : 24971 +*/
                    p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                    if(RRM_PNULL == p_ho_new_ue)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Memory Allocation Failure");
                        /* Coverity fix 54369 */
                        /* Try next */
                        ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
                        continue;
                    }
                    /*+ Coverity CID : 24971 +*/
                    /*coverity_54420 ++*/
                    RRM_MEMSET(p_ho_new_ue,RRM_NULL,sizeof(ue_ho_lst_node_t));
                    /*coverity_54420 --*/

                    /* + SPR 20078 */
                    if (p_ue_context->ue_avg_stats.uplinkPathLossValue >=
                            p_ho_ue->p_ue_context->ue_avg_stats.uplinkPathLossValue)
                        /* - SPR 20078 */
                    {
                        /* if the pathloss is greater than the end node path loss then directly
                         * add node in the end
                         */
                        p_ho_new_ue->p_ue_context = p_ue_context;
                        ylPushTail(p_ue_ho_list, &p_ho_new_ue->node);
                    }
                    else 
                    {
                        /* if the path loss is greater than the last added node the start from
                         * this node till the end
                         */
                        while (RRM_PNULL != p_ho_ue)
                        {
                            /* + SPR 20078 */
                            if (p_ue_context->ue_avg_stats.uplinkPathLossValue >
                                    p_ho_ue->p_ue_context->ue_avg_stats.uplinkPathLossValue)
                                /* - SPR 20078 */
                            {
                                p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                                if(RRM_PNULL != p_ho_new_ue) /* Coverity: CID 29571 */
                                {
                                    p_ho_new_ue->p_ue_context = p_ue_context;
                                    ylInsertAfter(p_ue_ho_list, &p_ho_ue->node, &p_ho_new_ue->node);
                                    break;
                                }
                                else
                                {
                                    /*Cov_fix_start_64534*/
                                    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(p_ue_ho_list)))
                                    {
                                        RRM_MEM_FREE(p_ho_ue);
                                    }
                                    /*Cov_fix_end_64534*/
                                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                                            "Memory Allocation Failure");
                                    /*Coverity fix 54369 */
                                    ret_val = RRM_FAILURE ;
                                    return ret_val;
                                }
                            }
                            p_ho_ue = (ue_ho_lst_node_t *)(ylPrev(&p_ho_ue->node));
                        }
                        if (RRM_PNULL != p_ho_ue)
                        {
                            p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                            if(RRM_PNULL != p_ho_new_ue) /* Coverity: CID 29571 */
                            {
                                p_ho_new_ue->p_ue_context = p_ue_context;
                                ylPushHead(p_ue_ho_list, &p_ho_new_ue->node);
                            }
                            else
                            {
                                /*Cov_fix_start_64534*/
                                while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(p_ue_ho_list)))
                                {
                                    RRM_MEM_FREE(p_ho_ue);
                                }
                                /*Cov_fix_end_64534*/
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                        "Memory Allocation Failure");
                                ret_val = RRM_FAILURE ;
                                return ret_val;
                                /* Coverity fix 54369 */
                            }
                        }
                    }
                }
                else
                {
                    /* List was empty so put node on head */
                    p_ho_new_ue = (ue_ho_lst_node_t*)rrm_mem_get(sizeof(ue_ho_lst_node_t));
                    if(RRM_PNULL != p_ho_new_ue)
                    {
                        p_ho_new_ue->p_ue_context = p_ue_context;
                        ylPushHead(p_ue_ho_list, &p_ho_new_ue->node);
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                "Memory Allocation Failure");
                        /* Coverity fix 54369 */
                    }
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                        "Skipping [UE:%u] for HO as UE has special previledge ",
                        p_ue_context->ue_index,
                        p_ue_context->establishment_cause);
            }
        }
        /*Cov_fix_start_64534*/
        /*Cov_fix_end_64534*/
        ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
    }
    /* SPR 20652 Fix End */
    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&non_csg_ue_ho_list)))
    {
        /* SPR 16406 8SEP start */
        p_ho_ue->p_ue_context->meas_rep_event = MEAS_REP_EVENT_A2;
        /* SPR 16406 8SEP end */
        if (RRM_SUCCESS ==
                rrm_build_and_send_meas_config_req (p_ho_ue->p_ue_context, MEAS_TYPE_HO))
        {
            p_ho_ue->p_ue_context->action_triggered = RRM_HO_ACTN_ON_UE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                    "Triggered HO Measurement for NON-CSG [UE:%u]", p_ho_ue->p_ue_context->ue_index);
            /* Checking number of UE to be affected for the action */
            ue_ho_cnt++;
            if (p_load_def->num_of_usr == ue_ho_cnt)
            {
                break;
            }
        }
        /* SPR 15232 start */
        /* SPR 16406 8SEP start */
        p_ho_ue->p_ue_context->meas_rep_event = MEAS_REP_EVENT_NONE;
        /* SPR 16406 8SEP end */
        /* SPR 15232 end */
        RRM_MEM_FREE(p_ho_ue);
    }

    if (p_load_def->num_of_usr > ue_ho_cnt)
    {
        while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopTail(&csg_ue_ho_list)))
        {
            /* SPR 16406 8SEP start */
            p_ho_ue->p_ue_context->meas_rep_event = MEAS_REP_EVENT_A2;
            /* SPR 16406 8SEP end */
            if (RRM_SUCCESS ==
                    rrm_build_and_send_meas_config_req (p_ho_ue->p_ue_context, MEAS_TYPE_HO))
            {
                p_ho_ue->p_ue_context->action_triggered = RRM_HO_ACTN_ON_UE;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                        "Triggered HO Measurement for CSG [UE:%u]", p_ho_ue->p_ue_context->ue_index);
                /* Checking number of UE to be affected for the action */
                ue_ho_cnt++;
                if (p_load_def->num_of_usr == ue_ho_cnt)
                {
                    break;
                }
            }
            /* SPR 15232 start */
            /* SPR 16406 8SEP start */
            p_ho_ue->p_ue_context->meas_rep_event = MEAS_REP_EVENT_NONE;
            /* SPR 16406 8SEP end */
            /* SPR 15232 end */
            RRM_MEM_FREE(p_ho_ue);
        }
    }
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "No of UE Config for HO: %d HO Triggered For No. UE: %d", p_load_def->num_of_usr, ue_ho_cnt);
    /* Releasing Remaining from the list if any */
    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopHead(&csg_ue_ho_list)))
    {
        RRM_MEM_FREE(p_ho_ue);
    }
    /* Releasing Remaining from the list if any */
    while (RRM_PNULL != (p_ho_ue = (ue_ho_lst_node_t*)ylPopHead(&non_csg_ue_ho_list)))
    {
        RRM_MEM_FREE(p_ho_ue);
    }
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "Handover action impacted [%u] UE(s)", ue_ho_cnt);
    return ret_val;
}
/*ECN load end*/

/*******************************************************************************
 *   FUNCTION NAME: rrm_ue_ho_attempt_ind
 *   DESCRIPTION:
 *       Send the HO attempt msg to MIF msg handler
 *   RETURNS:
 *       RRM_SUCCESS if attempt ind sent to MIF successfully 
 *       RRM_FAILURE otherwise
 ******************************************************************************/
    rrm_return_et
rrm_ue_ho_attempt_ind(
        rrm_ue_context_t *p_ue_context)
{
    rrmuem_rmif_ho_attempt_ind_t    rrmuem_rmif_ho_attempt_ind;
    RRM_MEMSET(&rrmuem_rmif_ho_attempt_ind, RRM_ZERO, sizeof(rrmuem_rmif_ho_attempt_ind_t));
    rrm_return_et                   ret_val                    = RRM_SUCCESS;

    if(RRM_PNULL != p_ue_context)
    {
        /* SPR 9216:MRO enhancement start */
        p_ue_context->is_ho_failed = RRM_FALSE;
        /* SPR 9216:MRO enhancement end */
        /* Start :SPR 9309 */
        if ((RRM_TRUE == rrm_cellm_get_ho_attemt_ind_attr_status(p_ue_context->cell_index)))
            /* End :SPR 9309 */
        {	
            RRM_MEMCPY(&(rrmuem_rmif_ho_attempt_ind.src_cgi),
                    &(p_ue_context->ue_handover_report.src_cgi),
                    sizeof(rrm_oam_eutran_global_cell_id_t));

            if(RRM_INTRA_RAT_GLOBAL_CELL_ID_PRESENT & p_ue_context->ue_handover_report.trgt_cgi.bitmask)
            {
                RRM_MEMCPY(&(rrmuem_rmif_ho_attempt_ind.trgt_cgi),
                        &(p_ue_context->ue_handover_report.trgt_cgi.intra_rat_global_cell_id),
                        sizeof(rrm_oam_eutran_global_cell_id_t));

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "HO_attempt_ind:Intra cell target cell id is not present");
                ret_val= RRM_FAILURE;
            }
            rrmuem_rmif_ho_attempt_ind.attempt_count = RRM_ONE;
            if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                        RRMUEM_RMIF_HO_ATTEMPT_IND, sizeof(rrmuem_rmif_ho_attempt_ind_t),
                        (void *)(&rrmuem_rmif_ho_attempt_ind)))
            {
                p_ue_context->ho_params.ho_ue_attempt_ind_sent = RRM_TRUE;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "HO_attempt_ind: Sent Handover attempt indication for [UE:%d]",
                        p_ue_context->ue_index);


            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "HO_attempt_ind: Failed to send Handover attempt indication for [UE:%d]",
                        p_ue_context->ue_index);
                ret_val= RRM_FAILURE;
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "HO_attempt_ind: p_ue_context is NULL ");
        ret_val= RRM_FAILURE;
    }
    return ret_val;
}
/* MRO code changes start */
/*******************************************************************************
 *   FUNCTION NAME: rrm_ue_ho_failure_report
 *   DESCRIPTION:
 *       Send the HO failure report to MIF msg handler
 *   RETURNS:
 *       RRM_SUCCESS if HO failure report sent to MIF successfully
 *       RRM_FAILURE otherwise
 ******************************************************************************/
    rrm_return_et
rrm_ue_ho_failure_report (
        rrm_ue_context_t *p_ue_context,
        rrmuem_rmif_ho_cause_et   ho_cause,
        rrm_ue_proc_rlf_ind_t    *p_ue_rlf_ind
        )
{
    rrmuem_rmif_ho_failure_report_t rrmuem_rmif_ho_failure_report = {RRM_ZERO};
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrm_cell_context_t             *p_cell_context = RRM_PNULL;

    if((RRM_PNULL != p_ue_context) && (RRM_PNULL != p_ue_rlf_ind))
    {
        p_ue_context->is_ho_failed = RRM_TRUE;
        if (RRM_TRUE == rrm_cellm_get_ho_failure_report_attr_status(p_ue_context->cell_index))
        {
            /* Start :SPR 9309 */
            if( p_ue_context->ue_ho_current_state ==  RRM_HO_STATE_WAIT_FOR_REL)
            {
                /* End :SPR 9309 */
                /* SPR-13375-fix start */
                RRM_MEMCPY(&(rrmuem_rmif_ho_failure_report.src_cgi),
                        &(p_ue_context->ue_handover_report.src_cgi),
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                /* CSR-82583[SPR-12644]-fix start */
                RRM_MEMCPY(&(rrmuem_rmif_ho_failure_report.trgt_cgi),
                        &(p_ue_context->ue_handover_report.trgt_cgi.intra_rat_global_cell_id),
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                /* SPR-13375-fix end */
                /* CSR-82583[SPR-12644]-fix end */
            }
            else
            {
                p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
                if(p_cell_context != RRM_PNULL)
                {
                    RRM_MEMCPY(&(rrmuem_rmif_ho_failure_report.src_cgi),
                            &(p_cell_context->global_cell_id),
                            sizeof(rrm_oam_eutran_global_cell_id_t));
                    /* SPR-12923-fix start */
                    /* Code Deleted */
                    /* SPR-12923-fix end */
                }
                else
                {
                    RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name,
                            RRM_DETAILED, "Cell context is NULL");
                    return RRM_FAILURE;

                }

                /* SPR-12923-fix start */
                /*
                 ** In the case of TOO_LATE_CELL target CGI is fill from the RLF message,
                 ** And for the WRONG_CELL fill from the HO_PARAMS.
                 */
                if (ho_cause != RRMUEM_RMIF_HO_TO_WRONG_CELL)
                {
                    if(RRM_SUCCESS != rrm_x2ap_ecgi_to_eutran_global_cell_id(
                                p_ue_rlf_ind->re_est_cell_ecgi,
                                &(rrmuem_rmif_ho_failure_report.trgt_cgi)))
                    {
                        RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name,
                                RRM_WARNING, "rrm_ue_handle_rlf_ind re_est_cell_ecgi is incorrect");
                        return RRM_FAILURE;
                    }
                }
                else
                {
                    /* SPR-13375-fix start */
                    RRM_MEMCPY(&(rrmuem_rmif_ho_failure_report.trgt_cgi),
                            &(p_ue_context->ue_handover_report.trgt_cgi.intra_rat_global_cell_id),
                            sizeof(rrm_oam_eutran_global_cell_id_t));
                    /* SPR-13375-fix end */
                }
                /* Code Deleted */
                /* SPR-12923-fix end */

            }

            rrmuem_rmif_ho_failure_report.ho_cause = ho_cause;

            if (ho_cause == RRMUEM_RMIF_HO_TO_WRONG_CELL)
            {
                rrmuem_rmif_ho_failure_report.bitmask |= RRM_MIF_HO_FAILURE_REPORT_RE_EST_CGI_PRESENT;

                if(RRM_SUCCESS != rrm_x2ap_ecgi_to_eutran_global_cell_id(
                            p_ue_rlf_ind->re_est_cell_ecgi,
                            &(rrmuem_rmif_ho_failure_report.restablishment_cgi)))
                {
                    ret_val = RRM_FAILURE;
                }

            }
            if (RRM_SUCCESS == rrm_uem_send_internal_msg((U16)RRM_MIF_MODULE_ID,
                        RRMUEM_RMIF_HO_FAILURE_REPORT, sizeof(rrmuem_rmif_ho_failure_report_t),
                        (void *)(&rrmuem_rmif_ho_failure_report)))
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "HO_failure_report: Sent Handover failure reportr [UE:%d]",
                        p_ue_context->ue_index);

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "HO_failure_report: Failed to send Handover failure report for [UE:%d]",
                        p_ue_context->ue_index);
                ret_val= RRM_FAILURE;
            }
        }
    }
    else 
    {
        if(RRM_PNULL == p_ue_context)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "HO_failure_report: p_ue_context is NULL ");
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "HO_failure_report: p_ue_rlf_ind ls NULL ");
            ret_val = RRM_FAILURE;
        }

    }
    return ret_val;
}

/*******************************************************************************
 *   FUNCTION NAME: rrm_x2ap_ecgi_to_eutran_global_cell_id
 *   DESCRIPTION:
 *       Coverts x2ap_ecgi into eutran_global_cell_id
 *   RETURNS:
 *       RRM_SUCCESS If converted successfully.
 *       RRM_FAILURE otherwise
 ******************************************************************************/
    rrm_return_et
rrm_x2ap_ecgi_to_eutran_global_cell_id (
        rrm_x2ap_ecgi_t x2ap_ecgi,
        rrm_oam_eutran_global_cell_id_t *p_eutran_global_cell_id
        )
{
    U8 rrm_no_of_mcc_filled       = RRM_ZERO;
    U8 rrm_no_of_mnc_filled       = RRM_ZERO;
    U8 nibble[RRM_TWO]            = {RRM_ZERO};
    U8 rrm_no_of_mnc_filler_digit = RRM_ZERO;
    U8 index                      = RRM_ZERO;
    S8 nibble_index               = RRM_ZERO;

    /*+ Coverity CID : 28807 +*/
    if(RRM_NULL == p_eutran_global_cell_id)
        /*- Coverity CID : 28807 -*/
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_eutran_global_cell_id is NULL");
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_eutran_global_cell_id, RRM_ZERO,
            sizeof(rrm_oam_eutran_global_cell_id_t));
    /* Initialize num_mnc_digit by 3, if filler digit is found it will be filled with 2 */
    p_eutran_global_cell_id->primary_plmn_id.num_mnc_digit = RRM_THREE;
    for(index = RRM_ZERO; index < MAX_PLMN_ID_BYTES; index++)
    {
        for(nibble_index = RRM_ZERO; nibble_index <= RRM_ONE; nibble_index++)
        {
            /* Filling two nibbles out of one Octet */
            nibble[nibble_index] = (x2ap_ecgi.plmn_identity.plmn_id[index]) & (RRM_LOW_NIBBLE<<(nibble_index*RRM_FOUR));
            nibble[nibble_index] = nibble[nibble_index]>>nibble_index*RRM_FOUR;
            if(RRM_PLMN_FILLER_DIGIT == nibble[nibble_index])
            {
                /* Checking that whether the filler digit is present at mcc or not */
                if((rrm_no_of_mcc_filled < MAX_MCC_DIGITS) ||
                        (rrm_no_of_mnc_filler_digit == RRM_ONE) )
                {
                    /* Filling p_eutran_global_cell_id with zero to avoid courrpt data */
                    RRM_MEMSET(p_eutran_global_cell_id, RRM_ZERO,
                            sizeof(rrm_oam_eutran_global_cell_id_t));
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                            "Wrong x2ap_ecgi is received, PLMN ID Octect[RRM_ZERO] = %d"
                            "PLMN ID Octect[1] = %d PLMN ID Octect[RRM_TWO] = %d",
                            x2ap_ecgi.plmn_identity.plmn_id[RRM_ZERO], x2ap_ecgi.plmn_identity.\
                            plmn_id[RRM_ONE], x2ap_ecgi.plmn_identity.plmn_id[RRM_TWO]);
                    return RRM_FAILURE;
                }
                /*
                 ** If filler digit is present in mnc than fill num_mnc_digit by 2. Otherwise,
                 ** it is filled with 3.
                 */
                else
                {
                    p_eutran_global_cell_id->primary_plmn_id.num_mnc_digit = RRM_TWO;
                    rrm_no_of_mnc_filler_digit++;
                }
            }
            /* Fill all the mcc digits first */
            else if( rrm_no_of_mcc_filled < MAX_MCC_DIGITS)
            {
                p_eutran_global_cell_id->primary_plmn_id.mcc[rrm_no_of_mcc_filled] = nibble[nibble_index];
                rrm_no_of_mcc_filled++;
            }
            /* Fill mnc digits if mcc is filled */
            else
            {
                p_eutran_global_cell_id->primary_plmn_id.mnc[rrm_no_of_mnc_filled] = nibble[nibble_index];
                rrm_no_of_mnc_filled++;
            }
        }
    }
    RRM_MEMCPY(p_eutran_global_cell_id->cell_identity,
            x2ap_ecgi.eutran_cell_id,
            sizeof(U8)*HOME_ENB_ID_OCTET_SIZE);

    return RRM_SUCCESS;
}
/* MRO code changes end */
    rrm_void_t
rrm_update_ue_actn(rrm_ue_index_t ue_index, rrm_cell_index_t cell_index)
{
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t             *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    RRM_UT_TRACE_ENTER();
    p_ue_context = rrm_ue_find_context (ue_index, cell_index);
    if (RRM_PNULL != p_ue_context)
    {
        /* SPR 20652 Fix Start */
        p_ue_context->action_triggered = RRM_CARRIER_REDIRECT_ON_UE;
        /* SPR 20652 Fix End */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "UE context not found");
    }
    RRM_UT_TRACE_EXIT();
}

/* Bug_944_start */
/*******************************************************************************
 *   FUNCTION NAME: rrm_find_daho_cell_freq
 *   DESCRIPTION:
 *          This function find daho cell freq from cell context
 *   RETURNS:
 *          U16
 ******************************************************************************/
    U16
rrm_find_daho_cell_freq (
        rrm_daho_cell_config_info_t *p_daho_cell, 
        rrm_cell_context_t *p_cell_context)
{
    U8 inter_freq_cell_count                      = RRM_ZERO;
    U16 rrm_prfed_arfcn_for_redirect              = RRM_ZERO;
    U8 valid_inter_freqs_cell                     = RRM_ZERO;
    lte_ncl_t              *p_ncl_list            = RRM_PNULL;


    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_context);
    p_ncl_list = rrm_cellm_get_lte_ncl_info (
            p_cell_context->cell_index);

    if (RRM_PNULL != p_ncl_list)
    {
        /* coverity 57593 */
        valid_inter_freqs_cell = p_ncl_list->num_valid_inter_freq_cell;
        for (inter_freq_cell_count = RRM_ZERO; (inter_freq_cell_count < valid_inter_freqs_cell) &&
                (inter_freq_cell_count < MAX_INTER_FREQ_CELLS);inter_freq_cell_count++)
        {
            /* Matching phy cell id to find DAHO cell frequency */
            if(p_ncl_list->inter_freq_cells[inter_freq_cell_count].phy_cell_id ==
                    p_daho_cell-> eutran_daho_cell_config_info.phy_cell_id)
            {
                /* Checking for current UE frequency, Which should not be used to redirect */
                if (p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn !=
                        p_ncl_list->inter_freq_cells[inter_freq_cell_count].eutra_carrier_arfcn)
                {
                    rrm_prfed_arfcn_for_redirect = p_ncl_list->inter_freq_cells[inter_freq_cell_count].
                        eutra_carrier_arfcn;
                }
            }
        }     
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                "p_ncl_list or p_idle_mode_mobility_params is empty");
    }
    if (RRM_ZERO != rrm_prfed_arfcn_for_redirect)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Redirect the UE on highest reselection prioroty frequency is %d ",rrm_prfed_arfcn_for_redirect);
    }

    RRM_UT_TRACE_EXIT();
    return rrm_prfed_arfcn_for_redirect;
}
/*******************************************************************************
 *   FUNCTION NAME: rrm_find_load_threshold
 *   DESCRIPTION:
 *          This function calculate load threshold based on cell load information
 *   RETURNS:
 *          U8
 ******************************************************************************/
    U8
rrm_find_load_threshold (
        rrm_cell_context_t *p_cell_context)
{
    U8 load_threshold                             = RRM_ZERO;
    U8 load_value                                 = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_context);
    /* To check composite load information (RRM_ONE = comp_load_info present) */
    if (RRM_ONE == p_cell_context->cell_load_action.choice)
    {
        if ((RRM_CELLM_MIDLOAD_PRESENT & p_cell_context->cell_load_action.u.comp_load_info.bitmask) &&
                /* Checking either no_action is set or not, bit 1 set = No action */
                (!(RRM_ONE & p_cell_context->cell_load_action.u.comp_load_info.mid_load.action)))
        {
            load_value = p_cell_context->cell_load_action.u.comp_load_info.mid_load.percent;  
        }
        else if ((RRM_CELLM_HIGHLOAD_PRESENT & p_cell_context->cell_load_action.u.comp_load_info.bitmask) &&
                /* Checking either no_action is set or not, bit 1 set = No action */
                (!(RRM_ONE & p_cell_context->cell_load_action.u.comp_load_info.high_load.action)))
        {
            load_value = p_cell_context->cell_load_action.u.comp_load_info.high_load.percent;  
        }
        /* By default no action are never set for overload */
        else if (RRM_CELLM_OVERLOAD_PRESENT & p_cell_context->cell_load_action.u.comp_load_info.bitmask)
        {
            load_value = p_cell_context->cell_load_action.u.comp_load_info.over_load.percent;  
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    " None of composite(mid, high, over)load information is not present");
            load_value = RRM_DEFAULT_CAPACITY_THRESH;
        } 
        load_threshold = RRM_MAX_AVLB_CAPCTY - load_value;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Composite load information is not present so assigning default value 50");
        load_threshold = RRM_DEFAULT_CAPACITY_THRESH;
    } 

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "Calculated capacity threshold is %d",load_threshold);

    RRM_UT_TRACE_EXIT();

    return load_threshold;
}
/*******************************************************************************
 *   FUNCTION NAME: rrm_sort_freq_of_neighbour_cell_on_load
 *   DESCRIPTION:
 *          This function sorting the frequency according to the load 
 *          condition of neighbour cell.
 *   RETURNS:
 *              U16
 ******************************************************************************/
    U16
rrm_sort_freq_of_neighbour_cell_on_load (
        rrm_ue_context_t      *p_ue_context, 
        rrm_cell_context_t    *p_cell_context)
{
    U8 load_threshold                             = RRM_ZERO;
    U8 tgt_cell_capacity                          = RRM_ZERO;
    U8 tgt_cell_capacity_ul                       = RRM_ZERO;
    U8 tgt_cell_capacity_dl                       = RRM_ZERO;
    U16 no_of_cell_in_less_load                   = RRM_ZERO;
    U8 inter_freq_cell_count                      = RRM_ZERO;
    U8 valid_inter_freqs_cell                     = RRM_ZERO;
    U8 idle_inter_list                            = RRM_ZERO;
    U16 freq_with_less_load                       = RRM_ZERO;
    U16 total_cell_on_particular_freq             = RRM_ZERO;
    U16 rrm_eutra_freq_load_value                 = RRM_ZERO;
    U16 rrm_prfed_arfcn_for_redirect              = RRM_ZERO;
    lte_ncl_t              *p_ncl_list            = RRM_PNULL;
    idle_mode_mobility_params_t *p_idle_mode_mobility_params = RRM_PNULL;


    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_ue_context);
    RRM_ASSERT(RRM_PNULL != p_cell_context);

    p_idle_mode_mobility_params = rrm_cellm_get_idle_mode_params (
            p_cell_context->cell_index);
    p_ncl_list = rrm_cellm_get_lte_ncl_info (
            p_cell_context->cell_index);

    load_threshold = rrm_find_load_threshold (p_cell_context);
    if ((RRM_PNULL != p_ncl_list) && (RRM_PNULL != p_idle_mode_mobility_params))
    {
        /* coverity 57594 */
        valid_inter_freqs_cell = p_ncl_list->num_valid_inter_freq_cell;
        for (idle_inter_list = RRM_ZERO; ((idle_inter_list < p_idle_mode_mobility_params->num_valid_inter_freq_list)
                    && (idle_inter_list < MAX_NO_INTER_FREQ)); idle_inter_list++)
        {
            /* Checking wether frequency is supported by UE or not */
            if ((p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn !=
                        p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[idle_inter_list].eutra_carrier_arfcn) && 
                    /* SPR 12897 Start */
                    (RRM_ZERO != rrm_ue_is_ue_supported_eutra_frequency (
                                                                         /* SPR 12897 End */
                                                                         p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[idle_inter_list].eutra_carrier_arfcn,
                                                                         p_ue_context)))
            {
                total_cell_on_particular_freq = RRM_ZERO;
                no_of_cell_in_less_load = RRM_ZERO;

                for (inter_freq_cell_count = RRM_ZERO; (inter_freq_cell_count < valid_inter_freqs_cell) &&
                        (inter_freq_cell_count < MAX_INTER_FREQ_CELLS); inter_freq_cell_count++)
                {
                    if(p_ncl_list->inter_freq_cells[inter_freq_cell_count].eutra_carrier_arfcn ==
                            p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[idle_inter_list].
                            eutra_carrier_arfcn)
                    {
                        /*chk broadcasring is true. cell is not blacklisted. Cell access mode */
                        if(RRM_TRUE == rrm_inter_cell_valid_for_selection(p_ue_context->rrm_csg_membership.rrm_csg_membership_status,
                                    &p_ncl_list->inter_freq_cells[inter_freq_cell_count],RRM_FALSE))
                        {
                            total_cell_on_particular_freq++;

                            if(p_ncl_list->inter_freq_cells[inter_freq_cell_count].resrc_report.bitmask & 
                                    RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT)
                            {
                                tgt_cell_capacity_ul =  p_ncl_list->inter_freq_cells[inter_freq_cell_count].
                                    resrc_report.comp_avl_cap_grp.ul.cell_cap_val;
                                tgt_cell_capacity_dl =  p_ncl_list->inter_freq_cells[inter_freq_cell_count].
                                    resrc_report.comp_avl_cap_grp.dl.cell_cap_val;
                            }
                            else
                            {
                                tgt_cell_capacity_ul = RRM_MAX_AVLB_CAPCTY;
                                tgt_cell_capacity_dl = RRM_MAX_AVLB_CAPCTY;
                            }

                            tgt_cell_capacity = RRM_GET_MIN(tgt_cell_capacity_dl,tgt_cell_capacity_ul);
                            if (tgt_cell_capacity > load_threshold)
                            {
                                no_of_cell_in_less_load++;
                            }
                        }
                    }
                }
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                        "Total cell on frequency[%d] is %d and no. of cell in less loaded is %d",p_idle_mode_mobility_params-> \
                        idle_mode_mobility_inter_freq_params[idle_inter_list].eutra_carrier_arfcn, \
                        total_cell_on_particular_freq, no_of_cell_in_less_load);
                if ((total_cell_on_particular_freq > RRM_ZERO) && (no_of_cell_in_less_load > RRM_ZERO)) 
                {
                    /* Multiply to Hundred to solve fractional value as data type is unsigned int */ 
                    rrm_eutra_freq_load_value = RRM_HUNDRED * (no_of_cell_in_less_load/total_cell_on_particular_freq);

                    if (rrm_eutra_freq_load_value > freq_with_less_load)
                    {
                        freq_with_less_load = rrm_eutra_freq_load_value;
                        rrm_prfed_arfcn_for_redirect = p_idle_mode_mobility_params->
                            idle_mode_mobility_inter_freq_params[idle_inter_list].eutra_carrier_arfcn;
                    }
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                "p_ncl_list or p_idle_mode_mobility_params is empty");
        RRM_UT_TRACE_EXIT();
        return rrm_prfed_arfcn_for_redirect;
    }
    if (rrm_prfed_arfcn_for_redirect == RRM_ZERO)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "None of freq found in NCL list to redirect ");
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Redirect the UE on frequency which has less load is %d ",rrm_prfed_arfcn_for_redirect);
    }

    RRM_UT_TRACE_EXIT();

    return rrm_prfed_arfcn_for_redirect;

}

/*******************************************************************************
 *   FUNCTION NAME: rrm_fnd_highst_frq_frm_idle_mode_prms
 *   DESCRIPTION:
 *          This function find highest priority frequency
 *           from idle mode mobility params 
 *   RETURNS:
 *               U16
 ******************************************************************************/
    U16
rrm_fnd_highst_frq_frm_idle_mode_prms (
        rrm_ue_context_t      *p_ue_context,    
        rrm_cell_context_t    *p_cell_context)
{
    idle_mode_mobility_params_t *p_idle_mode_mobility_params = RRM_PNULL;
    U8 idle_inter_list                                       = RRM_ZERO;
    U16 rrm_prfed_arfcn_for_redirect                         = RRM_ZERO;
    U8  highest_arfcn_priority                               = RRM_ZERO;

    /* Fill idle mode mobility params */
    p_idle_mode_mobility_params = rrm_cellm_get_idle_mode_params (
            p_cell_context->cell_index);
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_cell_context);

    if (RRM_PNULL != p_idle_mode_mobility_params)
    {
        for (idle_inter_list = RRM_ZERO; ((idle_inter_list < p_idle_mode_mobility_params->num_valid_inter_freq_list)
                    && (idle_inter_list < MAX_NO_INTER_FREQ)); idle_inter_list++)
        {
            /* Checking for current UE frequency, Which should not be used to redirect */
            if (p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn !=
                    p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[idle_inter_list].eutra_carrier_arfcn)
            {
                /* Checking wether frequency is supported by UE or not */
                /* SPR 12897 Start */
                if(RRM_ZERO != rrm_ue_is_ue_supported_eutra_frequency (
                            /* SPR 12897 End */
                            p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[idle_inter_list].\
                            eutra_carrier_arfcn, p_ue_context))
                {
                    if (RRM_ZERO != idle_inter_list)
                    {
                        if (highest_arfcn_priority < p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[idle_inter_list].\
                                cell_reselection_priority)
                        {
                            rrm_prfed_arfcn_for_redirect = p_idle_mode_mobility_params-> \
                                                           idle_mode_mobility_inter_freq_params[idle_inter_list].eutra_carrier_arfcn;
                            highest_arfcn_priority = p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[idle_inter_list].\
                                                     cell_reselection_priority;

                        }
                    }
                    else
                    {
                        highest_arfcn_priority = p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[RRM_ZERO].\
                                                 cell_reselection_priority;
                        rrm_prfed_arfcn_for_redirect = p_idle_mode_mobility_params->idle_mode_mobility_inter_freq_params[RRM_ZERO].\
                                                       eutra_carrier_arfcn;
                    }
                }
            }
        }
        if (RRM_ZERO != rrm_prfed_arfcn_for_redirect)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Selected highest reselection frequency is %u", rrm_prfed_arfcn_for_redirect);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Idle mode mobility params are not found at cell index[%d]",p_cell_context->cell_index );
    }

    RRM_UT_TRACE_EXIT();
    return rrm_prfed_arfcn_for_redirect;
}
/*******************************************************************************
 *   FUNCTION NAME: rrm_redirect_ue_with_release
 *   DESCRIPTION:
 *          This function handle the redirection of UE on Load based.  
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
/* Bug_944_end */
    rrm_return_et 
rrm_redirect_ue_with_release (rrmuem_cm_redirect_rel_ind_t *p_rrm_redirect_ue)
{
    rrm_return_et           ret_val                    = RRM_SUCCESS;
    rrm_ue_timer_buf_t timer_buff;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    /* Bug_944_start */
    rrm_daho_cell_config_info_t         *p_daho_cell    = RRM_PNULL;
    rrm_cell_context_t                  *p_cell_context = RRM_PNULL;
    U16 rrm_prfed_arfcn_for_redirect                    = RRM_ZERO;
    U32         timer_duration                          = RRM_ZERO;  
    rrm_bool_et rrm_need_find_freq_frm_idle_mode        = RRM_TRUE;
    /* Bug_944_end */
    rrm_ue_context_t *p_ue_context = RRM_PNULL; 

    RRM_UT_TRACE_ENTER();
    /*Find lowest priority non csg UE for redirection*/
    /* If no neighbour cell is present for cell. release the low priority Ue*/
    p_cell_context =  rrm_cellm_get_cell_context(p_rrm_redirect_ue->cell_index);
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                "Cell context is NULL at cell_index [%d]",p_rrm_redirect_ue->cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;

    }
    /* SPR 20652 Fix Start */
    p_ue_context = rrm_ue_find_context (p_rrm_redirect_ue->ue_index, p_rrm_redirect_ue->cell_index);
    if (RRM_PNULL == p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "UE context not found for [UE:%d]",p_rrm_redirect_ue->ue_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;

    }
    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "Redirection applied on [UE:%d]",p_ue_context->ue_index);
    /* SPR 20652 Fix End */
    /* Bug_944_start */

    if ((RRMUEM_CM_MARD_INFO_PRESENT & p_rrm_redirect_ue->bitmask) && 
            (RRMUEM_CM_MARD_PRESENT & p_rrm_redirect_ue->mard_info.bitmask) && 
            (RRM_ONE == p_rrm_redirect_ue->mard_info.mard_present))
    {
        /* Bug_944_end */
        ret_val = rrm_verify_ue_for_inter_freq_meas(p_ue_context, RRM_FALSE);
        /*Start timer if timer expire before reciving measurement ind. 
          Release the UE*/
        if(RRM_SUCCESS == ret_val)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Meas request send for [UE:%d] action[%d]",
                    p_ue_context->ue_index,p_ue_context->action_triggered);
            RRM_MEMSET (&timer_buff, RRM_ZERO, sizeof(rrm_ue_timer_buf_t));
            timer_buff.timer_type = RRM_UE_W_FOR_MLB_REDIRECT_MEAS_IND;
            timer_buff.trans_id = RRM_ONE;
            timer_buff.cell_index = p_ue_context->cell_index;
            timer_buff.ue_index = p_ue_context->ue_index;
            /* Bug_944_start */
            /* If timer duration is not present then default value is 10 sec */
            if (RRMUEM_CM_MEAS_BASED_RWR_TIMER_PRESENT & p_rrm_redirect_ue->mard_info.bitmask)
            {
                timer_duration = p_rrm_redirect_ue->mard_info.rwr_timer ;
            }
            else
            {
                timer_duration = RRM_TEN ;
            }
            /* Bug_944_end */
            /* CSR-58333-fix start*/
            p_ue_context->carrier_redirect_ue= rrm_ue_start_timer (
                    (timer_duration * RRM_SEC_TO_MILLI_SEC_CONV /*1000*/),
                    &timer_buff, sizeof(rrm_ue_timer_buf_t), RRM_FALSE);
            /* CSR-58333-fix end*/
        }
        /* Bug_944_start */
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "MARD information is not present");
        if (RRMCM_RMIF_LTE_NCL_PRESENT & p_cell_context->ran_info.ncl_params.bitmask) 
        {
            rrm_prfed_arfcn_for_redirect = rrm_sort_freq_of_neighbour_cell_on_load
                (p_ue_context, p_cell_context);

            /* (rrm_prfed_arfcn_for_redirect == RRM_ZERO) indicates all reported cells are in high load */
            if (rrm_prfed_arfcn_for_redirect != RRM_ZERO)
            {
                if (RRM_SUCCESS != (ret_val = rrm_build_and_send_ue_connection_release_ind_carrier_redir
                            (p_ue_context->ue_index,
                             p_ue_context->cell_index,
                             rrm_prfed_arfcn_for_redirect, RADIO_NETWORK_LAYER_TYPE,
                             REDUCE_LOAD_IN_SERVING_CELL,
                             RRM_ZERO)))
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "Failed to send Carrier redirection UE connection release indication for [UE:%d]",p_ue_context->ue_index);
                    ret_val = RRM_FAILURE;
                }
                /*SPR-668 Fix Starts*/
                if (RRM_SUCCESS == ret_val)
                {
                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                    {
                        RRM_TRACE(g_uem_log_on_off,
                                p_g_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "ue_connection_release_ind sent, \
                                Failed to clean up ue resources");
                        ret_val = RRM_FAILURE;
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,
                                p_g_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "successfully cleaned up resources for the [UE:%d]",
                                p_ue_context->ue_index);
                    }
                }
                /*SPR-668 Fix Ends*/
                rrm_need_find_freq_frm_idle_mode = RRM_FALSE;
            }
            /* Redirect the UE on DAHO Frequency */
            else
            {
                p_daho_cell = rrm_cellm_get_daho_cell_config_info_params(p_rrm_redirect_ue->cell_index);
                /* SPR 14336 Fix - Bitmask check corrected for inter frequency */
                if((RRM_PNULL != p_daho_cell) && (EUTRA_INTER_FREQ_DAHO_CELL_PRESENT & p_daho_cell->bitmask))
                {
                    rrm_prfed_arfcn_for_redirect = rrm_find_daho_cell_freq (p_daho_cell, p_cell_context);

                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "DAHO Cell is configured: Redirect [UE:%d] to DAHO CELL ",p_ue_context->ue_index);
                    /* (rrm_prfed_arfcn_for_redirect == RRM_ZERO) indicates DAHO cells is not found */
                    if (RRM_ZERO != rrm_prfed_arfcn_for_redirect)
                    {
                        if (RRM_SUCCESS != (ret_val = rrm_build_and_send_ue_connection_release_ind_carrier_redir
                                    (p_ue_context->ue_index,
                                     p_ue_context->cell_index,
                                     rrm_prfed_arfcn_for_redirect, RADIO_NETWORK_LAYER_TYPE,
                                     REDUCE_LOAD_IN_SERVING_CELL,
                                     RRM_ZERO)))
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                                    "Failed to send Carrier redirection UE connection release indication \
                                    for [UE:%d]",p_ue_context->ue_index);
                            ret_val = RRM_FAILURE;
                        }
                        rrm_need_find_freq_frm_idle_mode = RRM_FALSE;
                    }
                    /* If DAHO cell freq not found then find freq from idle mode params */
                    else
                    {
                        rrm_need_find_freq_frm_idle_mode = RRM_TRUE;
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "DAHO Cell is not configured for [UE:%d]",p_ue_context->ue_index);
                    rrm_need_find_freq_frm_idle_mode = RRM_TRUE;
                }
            }
        }
        /* if NCL is present and all cell in list are on high load else DAHO is not configured
           then find freq from idle mode */
        if (RRM_TRUE == rrm_need_find_freq_frm_idle_mode)
        {
            rrm_prfed_arfcn_for_redirect = rrm_fnd_highst_frq_frm_idle_mode_prms(p_ue_context, p_cell_context);
            if (RRM_ZERO != rrm_prfed_arfcn_for_redirect)
            {
                if (RRM_SUCCESS != (ret_val = rrm_build_and_send_ue_connection_release_ind_carrier_redir
                            (p_ue_context->ue_index,
                             p_ue_context->cell_index,
                             rrm_prfed_arfcn_for_redirect, RADIO_NETWORK_LAYER_TYPE,
                             REDUCE_LOAD_IN_SERVING_CELL,
                             RRM_ZERO)))
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                            "Failed to send Carrier redirection UE connection release indication for [UE:%d]",p_ue_context->ue_index);    
                        ret_val = RRM_FAILURE;    
                }

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                        "Best frequency for UE redirection is not found for  [UE:%d]",p_ue_context->ue_index);
                ret_val = RRM_FAILURE;
            }
        }    
    }
    if (RRM_SUCCESS != ret_val)
    {
        /*release the ue. No inter freq cell found for this UE */
        if (RRM_SUCCESS == (ret_val = rrm_build_and_send_ue_connection_release_ind
                    (p_ue_context->ue_index,
                     RADIO_NETWORK_LAYER_TYPE,
                     REDUCE_LOAD_IN_SERVING_CELL, 
                     RRM_ONE,
                     RRM_PNULL,
                     /* SPR_10729_fix */
                     p_ue_context->cell_index)))
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "ue_connection_release_ind sent ");
            if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off,
                        p_g_rrm_uem_facility_name,
                        RRM_ERROR,
                        "Failed to clean up ue resources for the [UE:%d]",
                        p_rrm_redirect_ue->ue_index);
                ret_val = RRM_FAILURE;

            }
            else
            {
                RRM_TRACE(g_uem_log_on_off,
                        p_g_rrm_uem_facility_name,
                        RRM_DETAILED,
                        "successfully cleaned up resources for the [UE:%d]",
                        p_rrm_redirect_ue->ue_index);
            } 
        }

    }
    /* Bug_944_end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*  DYNAMIC ICIC CHANGES START  */
/****************************************************************************
 * Function Name  : rrm_uem_handle_cm_update_ue_info_req 
 * Inputs    	  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 *                : rrm_void_t *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes update UE info req from cellm 
 ****************************************************************************/

rrm_return_et
rrm_uem_handle_cm_update_ue_info_req(
        rrm_ue_global_context_t     *p_rrm_glb_ctxt,
        rrm_void_t *p_api /*Input Api buffer*/
        /*SPR 17777 +-*/
        )
{
    rrm_return_et                  ret_val = RRM_FAILURE;
    rrmuem_cm_update_ue_info_req_t *p_update_ue_info_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_update_ue_info_req = (rrmuem_cm_update_ue_info_req_t *)p_api;
    RRM_ASSERT(RRM_PNULL != p_update_ue_info_req);

    SET_CELL_INDEX(p_update_ue_info_req->cell_index);
    
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_UPDATE_UE_INFO_REQ");
    /* initialize the Gloabl Data structure */
    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested = RRM_ZERO;
    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_performed = RRM_ZERO;
    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp = RRM_FAILURE;
    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_olpc_reduce_power_action_resp = RRM_FAILURE;
    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.cell_index = p_update_ue_info_req->cell_index;
    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.transaction_id = p_update_ue_info_req->transaction_id;
    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.num_of_requests_triggered = RRM_ZERO;
    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.confirmation_status = RRM_FAILURE;

    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.ue_location_update_action = 
        p_update_ue_info_req->ue_location_update_action;

    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.ue_reduce_power_action = 
        p_update_ue_info_req->ue_reduce_power_action;

    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.location_update_percentage = 
        p_update_ue_info_req->location_update_percentage;
    /*
     ** Update the location of all the UE's as per the request
     ** and trigger the RRM_MAC_UE_RECONFIG_REQ towards L2
     ** 
     */
    if(p_update_ue_info_req->bitmask & RRMUEM_CM_UE_LOCATION_UPDATE_ACTION_PRESENT )
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "UE_LOCATION_UPDATE_ACTION_PRESENT received for cell id[%d] ", 
                p_update_ue_info_req->cell_index); 
        p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested |= 
            UE_LOCATION_UPDATE_ACTION_PRESENT;
    }

    /*
     ** Reduce the UL Tx power of all the CC UE's as per the request.
     */ 
    if(p_update_ue_info_req->bitmask & RRMUEM_CM_CC_UE_OLPC_REDUCE_POWER_ACTION_PRESENT)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                "UE_OLPC_REDUCE_POWER_ACTION received for cell id[%d] ", 
                p_update_ue_info_req->cell_index); 
        p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested |= 
            UE_OLPC_REDUCE_POWER_ACTION;
    }
    /* This function will take the appropriate action */
    uem_action_on_icic_reports_in_requested_cell(p_rrm_glb_ctxt); 

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* eICIC_PHASE_1_2_CHANGES_START */
/****************************************************************************
 * Function Name  : rrm_uem_handle_cm_get_aggressor_req 
 * Inputs    	  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 *                : rrm_void_t *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes get aggressor info req from cellm 
 ****************************************************************************/
    rrm_return_et
rrm_uem_handle_cm_get_aggressor_req(
        rrm_ue_global_context_t     *p_rrm_glb_ctxt,
        rrm_void_t *p_api 
        )
{
    RRM_UT_TRACE_ENTER();

    rrm_return_et       ret_val = RRM_SUCCESS;
    rrm_cell_index_t cell_index = RRM_ZERO;
    U16 trans_id = RRM_NULL;
    /*SPR Fix 15230 Fix start */
    aggressor_node_t* p_aggressor_node = RRM_PNULL;
    /*SPR Fix 15230 Fix start */

    YLIST aggressor_node_list;

    ylInit(&aggressor_node_list);

    cell_index = ((rrmuem_cm_get_aggressor_req_t *)p_api)->cell_index;
    SET_CELL_INDEX(cell_index);

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->UEM:RRMUEM_CM_GET_AGGRESSOR_REQ");
    
    trans_id = ((rrmuem_cm_get_aggressor_req_t *)p_api)->transaction_id;

    aggressor_node_list = p_rrm_glb_ctxt->aggressor_node_info.
        rrm_aggressor_on_cell[cell_index].aggressor_node_list;

    if(RRM_FAILURE == rrm_uem_send_aggressor_node_list_to_cellm(
                &aggressor_node_list, trans_id, cell_index))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Failed to Send Aggressor Node List CellM ");

        ret_val = RRM_FAILURE;
    }  
    else
    {
        /*SPR Fix 15230 Fix start */
        /*Flushing The Aggresor node List as the data is sent to Cellm */
        while (RRM_PNULL != (p_aggressor_node = (aggressor_node_t *)ylPopTail
                    (&(aggressor_node_list))))
        {
            RRM_MEM_FREE(p_aggressor_node);
        }
        /*SPR Fix 15230 Fix end */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Aggressor Node List Sent to CellM Successfully");
        ret_val = RRM_SUCCESS;
    }

    /* SPR_14046_START */
    p_rrm_glb_ctxt->aggressor_node_info.
        rrm_aggressor_on_cell[cell_index].aggressor_node_list = aggressor_node_list;
    /* SPR_14046_END */


    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_uem_send_aggressor_node_list_to_cellm 
 * Inputs    	  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 * Outputs        : NONE
 * Returns        : NONE
 * Description    : Perform action based on the inputs received from Cell M 
 ****************************************************************************/
rrm_return_et
    rrm_uem_send_aggressor_node_list_to_cellm
(
 YLIST *aggressor_node_list,
 UInt16 trans_id,
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();

    rrm_return_et       ret_val = RRM_SUCCESS;
    UInt8               index   = RRM_ZERO;
    YLNODE             *next_node = RRM_NULL;
    rrmuem_cm_get_aggressor_resp_t *p_resp = RRM_NULL; 
    aggressor_node_data_t aggressor_data  = {RRM_ZERO};

    p_resp = rrm_mem_get(sizeof(rrmuem_cm_get_aggressor_resp_t));
    if( RRM_PNULL == p_resp)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Memory Allocation Failure");
        return RRM_FAILURE;
    }

    RRM_MEMSET(p_resp, RRM_ZERO, sizeof(rrmuem_cm_get_aggressor_resp_t));

    p_resp->transaction_id = trans_id;
    p_resp->cell_index = cell_index;

    if (RRM_ZERO != ylCount(aggressor_node_list))
    {
        /* Sort Aggressor Node List By Num of Occurrence */
        ylSort(aggressor_node_list ,
                rrm_uem_count_key_of_aggressor_node_list,
                rrm_uem_aggressor_list_compare_count);

        next_node = ylFirst(aggressor_node_list);

        for(index = RRM_ZERO ; ((index < ylCount(aggressor_node_list))&& 
                    (index < RRM_MAX_AGGRESSOR_CNT));index++)
        {
            /* SPR 15237 fix start */
            if (RRM_PNULL == next_node)
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_WARNING,
                        "No Aggressor Node found in aggressor list");
                /* Coverity ID 69263 Fix Start */
                RRM_MEM_FREE(p_resp); 
                /* Coverity ID 69263 Fix End */
                return RRM_FAILURE;
            }
            /* SPR 15237 fix end */
            else
            {
                aggressor_data = ((aggressor_node_t *)next_node)->aggressor_node_data;
                p_resp->phy_cell_id[index] = aggressor_data.pci;
                p_resp->num_of_aggressor++;
                next_node = ylNext( next_node );
            }
        }

        p_resp->response = RRM_SUCCESS;
    }
    else
    {
        /* sending failure resp as no aggressor node is found */
        p_resp->response = RRM_FAILURE;

    }

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
            "[%d]Num Of Aggressor Node Found for cell index :[%d]",
            p_resp->num_of_aggressor,cell_index);

    if (RRM_FAILURE == rrm_uem_send_internal_msg(
                RRM_CM_MODULE_ID,
                RRMUEM_CM_GET_AGGRESSOR_RESP,
                sizeof(rrmuem_cm_get_aggressor_resp_t),
                (rrm_void_t *)p_resp))
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, 
                "RRM send to MIF Failed");
        ret_val = RRM_FAILURE;
    }


    RRM_MEM_FREE(p_resp); /* Cov 69263 */

    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/*****************************************************************************
 * Function Name  : rrm_uem_count_key_of_aggressor_node_list 
 * Inputs         : p_node - anchor field of the record
 * Outputs        : None
 * Returns        : Pointer to count as void pointer
 * Description    : This function determines the key in Aggressor Node 
 *                  list. Here count value to be used 
 *                  as the key field of the list.
 ******************************************************************************/
const rrm_void_t *
    rrm_uem_count_key_of_aggressor_node_list
(
 const YLNODE *p_node
 )
{
    RRM_UT_TRACE_ENTER();
    aggressor_node_t *p_data = RRM_NULL;
    UInt16 *p_occurence_count= RRM_NULL;
    RRM_UT_TRACE_ENTER();

    if (RRM_NULL == p_node)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Aggressor Node List : pointer to node is NULL\n");
    }
    else
    {
        p_data = YMEMBEROF(aggressor_node_t, node, p_node);
        p_occurence_count = &(p_data->aggressor_node_data.occurence_count);
    }
    RRM_UT_TRACE_EXIT();
    return (rrm_void_t *)p_occurence_count;
} 

/*****************************************************************************
 * Function Name  : rrm_uem_aggressor_list_compare_count
 * Inputs         : p_val_1     Pointer to the PCI value as void pointer
 *                : p_val_2     Pointer to the PCI value as void pointer
 * Outputs        : None
 * Returns        : Zero -  If matches
 *                  Non Zero - If not matches
 * Description    : This function compares the PCI values
 ******************************************************************************/
SInt32
    rrm_uem_aggressor_list_compare_count
(
 const rrm_void_t *p_val_1,
 const rrm_void_t *p_val_2
 )
{
    SInt32 ret_value = 1;
    RRM_UT_TRACE_ENTER();

    if (RRM_PNULL == p_val_1 || RRM_PNULL == p_val_2)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "rrm_uem_aggressor_list_compare_count : Pointer to the Count is NULL");
    }
    else
    {
        if(*(UInt16 *)p_val_1 > *(UInt16 *)p_val_2)
        {
            ret_value = -1;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_value;
} 

/* eICIC_PHASE_1_2_CHANGES_END */

/****************************************************************************
 * Function Name  : uem_action_on_icic_reports_in_requested_cell 
 * Inputs    	  : rrm_ue_global_context_t *p_rrm_glb_ctxt : global context
 * Outputs        : NONE
 * Returns        : NONE
 * Description    : Perform action based on the inputs received from Cell M 
 ****************************************************************************/
rrm_void_t
    uem_action_on_icic_reports_in_requested_cell
(
 rrm_ue_global_context_t     *p_rrm_glb_ctxt
 )
{
    rrm_return_et       ret_val = RRM_FAILURE;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t    *p_ue_context           = RRM_PNULL;
    rrm_seq_data_info_t ue_node;
    /* SPR 20652 Fix End */
    rrm_ue_index_t      ue_index_list[MAX_NUM_OF_UE]  = {RRM_ZERO};   
    U32                 ue_update_count                = RRM_ZERO;
    rrm_cell_index_t     cell_index = RRM_OUT_OF_RANGE;   //0xFF;				/*!< Cell index for UE context		*/
    rrm_location_update_action_et            ue_location_update_action = INVALID_REASON; 
    rrm_olpc_reduce_power_action_et          ue_reduce_power_action  = UE_OLPC_INVALID_POWER_ACTION; 
    rrmuem_cm_update_ue_info_resp_t          *p_resp = RRM_PNULL;
    rrm_ue_list_for_icic_action_t            *p_ue_list_for_icic_data_for_all_ues = RRM_PNULL;
    rrm_ue_list_for_icic_action_t            *p_ue_list_start = RRM_PNULL;
    rrm_ue_list_for_icic_action_t            *p_ue_list_last = RRM_PNULL;
    rrm_ue_list_for_icic_action_t            *p_ue_list_temp = RRM_PNULL;
    rrm_ue_position_et                       ue_position = RRM_UE_POSITION_AT_CELL_EDGE;
    U16                                      cc_ue_count = RRM_ZERO;
    rrm_ue_index_t                           temp_ue_id = RRM_ZERO;
    rrm_cell_index_t                         temp_cell_id = RRM_ZERO;
    U32                                      temp_pl_value = RRM_ZERO;
    U16                                      count_of_ue_to_be_reconf = RRM_ZERO;
    U16                                      counter = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_rrm_glb_ctxt);

    cell_index =  p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.
        cell_index;

    ue_location_update_action = p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.ue_location_update_action;
    ue_reduce_power_action = p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
        rrm_ue_loc_update_action_info.ue_reduce_power_action;
    if((p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested &
                UE_LOCATION_UPDATE_ACTION_PRESENT) &&
            !(p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_performed & UE_LOCATION_UPDATE_ACTION_PRESENT))
    {
        switch(ue_location_update_action)
        {
            case UE_LOCATION_UPDATE_CE_TO_CC:
                ue_position = RRM_UE_POSITION_AT_CELL_EDGE;
                break;
            case UE_LOCATION_UPDATE_CC_TO_CE: 
                ue_position = RRM_UE_POSITION_AT_CELL_CENTER;
                break;
            default:
                ue_position = RRM_UE_POSITION_AT_CELL_CENTER;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        " Invalid update loction action[%d] is recieved!! ", ue_location_update_action); 
        }
        /* Find the UEs associated with the Cell Index specified */
        /* SPR 20652 Fix Start */
        rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
        while(RRM_PNULL != p_ue_context)
        {
            /* If a UE is found with the specified cell index && UE sub state is RRM_UE_ERB_NULL*/
            if((cell_index == p_ue_context->cell_index) &&
                    (RRM_UE_ERB_NULL == p_ue_context->current_procedure.state))
            {
                if(ue_position == p_ue_context->dynamic_icic_info.
                        rrm_ue_dynamic_icic_present_data.ue_present_position)
                {
                    if (RRM_PNULL == p_ue_list_start)
                    {
                        p_ue_list_for_icic_data_for_all_ues = rrm_mem_get(sizeof(rrm_ue_list_for_icic_action_t));
                        if ( p_ue_list_for_icic_data_for_all_ues == RRM_PNULL)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                    "Memory allocation to p_ue_list_for_icic_data_for_all_ues failed" );
                            RRM_UT_TRACE_EXIT();
                            return ;
                        }
                        p_ue_list_for_icic_data_for_all_ues->cell_index = p_ue_context->cell_index;
                        p_ue_list_for_icic_data_for_all_ues->ue_id = p_ue_context->ue_index;
                        /* + SPR 20078 */
                        p_ue_list_for_icic_data_for_all_ues->avg_ul_path_loss_value = 
                            p_ue_context->ue_avg_stats.uplinkPathLossValue;
                        /* - SPR 20078 */
                        p_ue_list_for_icic_data_for_all_ues->p_ue_context = p_ue_context;
                        p_ue_list_for_icic_data_for_all_ues->p_next = RRM_PNULL;
                        p_ue_list_start = p_ue_list_last = p_ue_list_for_icic_data_for_all_ues;
                    }
                    else
                    {
                        p_ue_list_for_icic_data_for_all_ues = rrm_mem_get(sizeof(rrm_ue_list_for_icic_action_t));
                        if (p_ue_list_for_icic_data_for_all_ues == RRM_PNULL)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                    "Memory allocation to p_ue_list_for_icic_data_for_all_ues failed" );
                            /* CID:54382 Fix Start */
                            while (RRM_PNULL != p_ue_list_start)
                            {
                                p_ue_list_temp = p_ue_list_start;
                                p_ue_list_start = p_ue_list_start->p_next;
                                RRM_MEM_FREE(p_ue_list_temp);
                            }
                            /* CID:54382 Fix End */
                            RRM_UT_TRACE_EXIT();
                            return ;
                        }

                        p_ue_list_for_icic_data_for_all_ues->cell_index = p_ue_context->cell_index;
                        p_ue_list_for_icic_data_for_all_ues->ue_id = p_ue_context->ue_index;
                        /* + SPR 20078 */
                        p_ue_list_for_icic_data_for_all_ues->avg_ul_path_loss_value = 
                            p_ue_context->ue_avg_stats.uplinkPathLossValue;
                        /* - SPR 20078 */
                        p_ue_list_for_icic_data_for_all_ues->p_ue_context = p_ue_context;
                        p_ue_list_for_icic_data_for_all_ues->p_next = RRM_PNULL;
                        p_ue_list_last->p_next = p_ue_list_for_icic_data_for_all_ues;
                        p_ue_list_last = p_ue_list_for_icic_data_for_all_ues;
                    }
                    cc_ue_count++;
                }
            }
            ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
            /* SPR 20652 Fix End */
        }
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Total Cell Center UE found is [%d]", cc_ue_count); 
        count_of_ue_to_be_reconf =  ((float )p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
                rrm_ue_loc_update_action_info.location_update_percentage / (float)RRM_PERCENTAGE) * cc_ue_count;
        if (RRM_ZERO != count_of_ue_to_be_reconf)
        {

            /* Re arrange all the UEs in decreasing order of their UL pathloss
             * threshold.
             */ 
            p_ue_list_last = p_ue_list_start;
            for(; p_ue_list_last != RRM_NULL && p_ue_list_last->p_next != RRM_PNULL; p_ue_list_last = p_ue_list_last->p_next)
            {
                for(p_ue_list_temp = p_ue_list_last->p_next; p_ue_list_temp !=RRM_PNULL; p_ue_list_temp = p_ue_list_temp->p_next)
                {
                    if(p_ue_list_last->avg_ul_path_loss_value > p_ue_list_temp->avg_ul_path_loss_value)
                    {
                        temp_cell_id = p_ue_list_last->cell_index;
                        temp_ue_id = p_ue_list_last->ue_id;
                        temp_pl_value = p_ue_list_last->avg_ul_path_loss_value;

                        p_ue_list_last->cell_index = p_ue_list_temp->cell_index;
                        p_ue_list_last->ue_id = p_ue_list_temp->ue_id;
                        p_ue_list_last->avg_ul_path_loss_value = p_ue_list_temp->avg_ul_path_loss_value;

                        p_ue_list_temp->cell_index = temp_cell_id;
                        p_ue_list_temp->ue_id = temp_ue_id;
                        p_ue_list_temp->avg_ul_path_loss_value = temp_pl_value;
                    }
                }
            }
            p_ue_list_last = p_ue_list_start;

            /* SPR 10356 fix start */
            if(MAC_UE_RECONF_NOT_ONGOING  == (rrm_get_mac_ue_reconfig_mutex( cell_index )) )
            {
                /* SPR 10356 fix end */
                while ((RRM_PNULL != p_ue_list_last) &&
                        (counter < count_of_ue_to_be_reconf))
                {
                    /* Update the loction of UE as Cell Edge and notify MAC */
                    /* SPR 10356 fix start*/
                    /* this check is safe guard for array out of bound which can be caught by static 
                       analyzer tool. this array  out of bound for ue count is also ensured
                       by the below  if(ue_update_count % MAX_NUM_OF_UE). but for avoiding the
                       tool warnings, this check is introduced  */
                    if( ue_update_count < MAX_NUM_OF_UE )
                    {
                        /* SPR 10356 fix end */
                        ue_index_list[ue_update_count] = p_ue_list_last->ue_id; 
                        /* SPr 10356 fix start*/
                        ue_update_count++;
                        /* SPR 10356 fix end */
                    }
                    p_ue_list_last->p_ue_context->current_procedure.state = RRM_UE_ICIC_UPDATE_INFO_ONGOING;

                    if((ue_update_count % MAX_NUM_OF_UE) == RRM_ZERO)
                    {
                        /*SPR 7892 FIX START*/

                        /* prepare_the mac  ue reconfig request */
                        ret_val = build_and_send_l2_ue_reconfig_req(cell_index,ue_index_list, ue_update_count, ue_location_update_action);
                        if(RRM_SUCCESS == ret_val)
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                    "Successfully send a batch of 25 UEs to MAC for location update"); 
                            p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
                                rrm_ue_loc_update_action_info.num_of_requests_triggered++;
                            p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_performed |=
                                UE_LOCATION_UPDATE_ACTION_PRESENT;
                            /*SPR 7892 FIX START*/
                            rrm_set_mac_ue_reconfig_mutex(cell_index,W_FOR_MAC_UE_RECONF_CNF_FOR_ICIC);
                            /*SPR 7892 FIX END*/

                            /* SPR 10499 FIX START */
                            counter += ue_update_count;
                            /* SPR 10499 FIX END */
                            /* SPR 10356 fix start*/
                            ue_update_count = RRM_ZERO;
                            /* SPr 10356 fix end */
                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                    "Unable to send the batch for 25 UEs Mac UE reconfig request to L2"); 
                        }
                        /* SPR 10356 fix start*/
                        /* SPR 10499 FIX START */
                        //break;
                        /* SPR 10499 FIX END */
                        /* spr 10356 fix end */
                        /*SPR 7892 FIX END*/
                    }
                    p_ue_list_last = p_ue_list_last->p_next;
                }
            }
            /* if no UE found */
            if(  ue_update_count == RRM_ZERO ) 
            {
                /* SPR 10356 fix start*/
                if ( W_FOR_MAC_UE_RECONF_CNF_FOR_ICIC != rrm_get_mac_ue_reconfig_mutex( cell_index ))
                    /* SPR 10356 fix end */
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            " No UE is found for ther requested cell[%d] ", cell_index); 
                    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
                        rrm_ue_loc_update_action_info.num_of_requests_triggered = RRM_ZERO;
                    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
                        rrm_ue_loc_update_action_info.confirmation_status = RRM_SUCCESS;
                    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_performed |=
                        UE_LOCATION_UPDATE_ACTION_PRESENT;
                    p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp = RRM_SUCCESS;
                }
            }
            else
            {
                /* prepare_the mac  ue reconfig request */
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "Location is updated for [%d] UE's in cell [%d] ", ue_update_count,cell_index);
                /*SPR 7892 FIX START*/
                if(MAC_UE_RECONF_NOT_ONGOING  == (rrm_get_mac_ue_reconfig_mutex( cell_index )) )
                {
                    /* prepare_the mac  ue reconfig request */
                    ret_val = build_and_send_l2_ue_reconfig_req( cell_index, ue_index_list, ue_update_count, ue_location_update_action);
                    if(RRM_SUCCESS == ret_val)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "Successfully send a batch of [%d] UEs to MAC for location update", ue_update_count); 
                        p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
                            rrm_ue_loc_update_action_info.num_of_requests_triggered++;
                        p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_performed |=
                            UE_LOCATION_UPDATE_ACTION_PRESENT;
                        rrm_set_mac_ue_reconfig_mutex(cell_index,W_FOR_MAC_UE_RECONF_CNF_FOR_ICIC);
                        /* SPR 20613 Fix Start */
                        p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp = RRM_SUCCESS;
                        /* SPR 20613 Fix End */
                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "Unable to send the batch for [%d] UEs Mac UE reconfig request to L2", ue_update_count); 
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,RRM_BRIEF,
                            "MAC UE reconfig request is already sent for this cell index[%d]",cell_index);
                }
                /*SPR 7892 FIX END*/
            }
        }
        else
        {
            p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_performed |=
                UE_LOCATION_UPDATE_ACTION_PRESENT;
            p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp = RRM_SUCCESS;
        }
        /* CID 54382 Fix Start */
        while (RRM_PNULL != p_ue_list_start)
        {
            p_ue_list_temp = p_ue_list_start;
            p_ue_list_start = p_ue_list_start->p_next;
            RRM_MEM_FREE(p_ue_list_temp);
        }
        /* CID 54382 Fix End */
    } 
    else
        if((p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested &
                    UE_OLPC_REDUCE_POWER_ACTION_PRESENT) &&
                !(p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_performed &
                    UE_OLPC_REDUCE_POWER_ACTION_PRESENT))
        {
            /* Find the UEs associated with the Cell Index specified */
            /* SPR 20652 Fix Start */
            rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
            while(RRM_PNULL != p_ue_context)
            {
                /* If a UE is found with the specified cell index && UE sub state is RRM_UE_ERB_NULL*/
                if((cell_index == p_ue_context->cell_index) &&
                        (RRM_UE_ERB_NULL == p_ue_context->current_procedure.state))
                {
                    switch(ue_reduce_power_action)
                    {
                        case UE_OLPC_REDUCE_POWER_ACTION:
                            if(RRM_UE_POSITION_AT_CELL_CENTER == p_ue_context->dynamic_icic_info.
                                    rrm_ue_dynamic_icic_present_data.ue_present_position)
                            {
                                /* Update the state of UE FSM */
                                p_ue_context->current_procedure.state = RRM_UE_RECONFIG_ONGOING;
                                /* prepare_the mac  ue reconfig request */
                                ret_val = rrm_build_and_send_ue_reconfig_req_for_icic_action(p_ue_context);
                                if(RRM_SUCCESS == ret_val)
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                            "Successfully send reconfig req for [UE:%d]to decrease power ",
                                            p_ue_context->ue_index); 
                                }
                                else
                                {
                                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                            "Unable to send the reconfig req for UE"); 
                                }
                            }
                            break;
                        default:
                            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                    " Invalid power action[%d] for olpc is recieved!! ", ue_reduce_power_action); 
                    }
                }
                ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
                /* SPR 20652 Fix End */
            }
            p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_performed |= UE_OLPC_REDUCE_POWER_ACTION_PRESENT;
        }
    if ( RRM_ZERO == ((p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested) ^
                (p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_performed)))
    {
        /* BUG_11576_FIX_START */
        p_resp = rrm_mem_get(sizeof(rrmuem_cm_update_ue_info_resp_t));
        if (RRM_PNULL != p_resp)
        { 
            /* BUG_11576_FIX_END */
            p_resp->cell_index = p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.rrm_ue_loc_update_action_info.cell_index;
            p_resp->transaction_id = p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.rrm_ue_loc_update_action_info.transaction_id;

            if((p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested & UE_OLPC_REDUCE_POWER_ACTION_PRESENT)
                    && !(p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested & UE_LOCATION_UPDATE_ACTION_PRESENT))
            {  
                p_resp->response = UE_OLPC_REDUCE_POWER_ACTION_SUCCESS;
            }

            else if(!(p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested & UE_OLPC_REDUCE_POWER_ACTION_PRESENT)
                    && (p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.action_requested & UE_LOCATION_UPDATE_ACTION_PRESENT))
            {  
                if(RRM_SUCCESS == p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp) 
                {
                    p_resp->response = UE_LOCATION_INFO_ACTION_SUCCESS;
                }
                else
                {
                    p_resp->response = UE_LOCATION_INFO_ACTION_FAILURE;
                }
            }
            else
            {
                if(RRM_SUCCESS == p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp)
                {
                    p_resp->response = UE_COMBINED_ACTION_SUCCESS;
                }
                else
                {
                    p_resp->response = UE_PARTIAL_SUCCESS_WITH_LOCATION_INFO_ACTION_FAILED;
                }
            }

            if (RRM_FAILURE == rrm_uem_send_internal_msg(
                        RRM_CM_MODULE_ID,
                        RRMUEM_CM_UPDATE_UE_INFO_RESP,
                        sizeof(rrmuem_cm_update_ue_info_resp_t),
                        (rrm_void_t *)p_resp))
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "RRM send to MIF Failed");
            }
            /* COVERITY : RESOURCE LEAK : CID : 48274 fix start*/
            /* BUG_11576_FIX_START */
            /*Cov_fix_start_64289*/
            RRM_MEM_FREE(p_resp);
            /*Cov_fix_end_64289*/
            /* COVERITY : RESOURCE LEAK : CID : 48274 fix end*/
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, "Unable to aalocate memory for p_resp");
        }
        /* BUG_11576_FIX_END */
    }
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrm_mac_process_ue_reconfig_cnf_event 
 * Inputs         : p_ue_reconf_cnf,p_rrm_glb_ctxt 
 * Outputs        : none
 * Returns        : NONE
 * Description    : This function processes the UE Reconfig Cnf 
 ****************************************************************************/
    rrm_void_t
rrm_mac_process_ue_reconfig_cnf_event(RrmMacUEReConfigCnf  *p_ue_reconf_cnf,
        rrm_ue_global_context_t    *p_rrm_glb_ctxt,
        rrm_cell_index_t             cell_index)
{
    rrm_ue_loc_update_action_info_t        *p_rrm_glb_ctxt_icic_data = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t                        *p_ue_context           = RRM_PNULL;
    rrm_seq_data_info_t                     ue_node;
    /* SPR 20652 Fix End */
    rrm_location_update_action_et           ue_location_update_action = INVALID_REASON; 
    /*Location update fix in UE RECONFIG*/
    rrm_cell_context_t   *p_cell_context = RRM_PNULL;
    rrm_ue_context_t              *p_rrm_ue_ctxt = RRM_PNULL;
    /*Location update fix in UE RECONFIG*/
/* SPR 8315 FIX START*/

    YLNODE *p_ylnode = RRM_PNULL;
    /*PR 8315 FIX END*/

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_ue_reconf_cnf);
    RRM_ASSERT(RRM_PNULL != p_rrm_glb_ctxt);

/*Location update fix in UE RECONFIG*/
    p_cell_context =  rrm_cellm_get_cell_context(cell_index);
    /*CID 65783:start*/
    if((RRM_PNULL != p_cell_context) && (RRM_TRUE == p_cell_context->dynamic_icic_data.mac_loc_update_triggrd_aftr_ue_reconfig))
        /*CID 65783:end*/
    {
        /* SPR 8315 FIX START*/
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                "Loc Update is triggered for some UE's of this Cell");
        if(RRM_ZERO != p_rrm_glb_ctxt->mac_ue_reconfig_sequence_list.count)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                    "MAC UE RECONFIG SEQ UE LIST is not empty");

            p_ylnode = ylPopHead(&(p_rrm_glb_ctxt->mac_ue_reconfig_sequence_list)); 

            /* SPR:757- Coverity fix start */
            /* COVERITY ID 58743 FIX */
            if(RRM_PNULL != p_ylnode)
            {
                p_rrm_ue_ctxt =  ((mac_ue_reconfig_sequence_node_t* )p_ylnode)->mac_ue_reconf_seq_node_data.p_ue_context;


                if(RRM_PNULL != p_rrm_ue_ctxt)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF, 
                            "MAC UE RECONFIG CNF is recieved for [UE:%d], "
                            "remaining UE count in MAC UE RECONFIG SEQ UE LIST is %d",
                            p_rrm_ue_ctxt->ue_index, p_rrm_glb_ctxt->mac_ue_reconfig_sequence_list.count);

                    /* SPR:757- Coverity fix end */
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, \
                            "MAC CNF RESPONS [%d] for [UE:%d].",p_ue_reconf_cnf->responseCode,p_rrm_ue_ctxt->ue_index);
                    if (p_ue_reconf_cnf->responseCode != RRM_FAILURE)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "SUCCESS is received UE reconf CONF from L2 ,Commit the new location");
                        /*SPR 7972 FIX START*/
                        p_rrm_ue_ctxt->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position =
                            p_rrm_ue_ctxt->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position;
                        /*SPR 7972 FIX END*/
                        p_rrm_ue_ctxt->dynamic_icic_info.rrm_ue_dynamic_icic_past_data =
                            p_rrm_ue_ctxt->dynamic_icic_info.rrm_ue_dynamic_icic_present_data;

                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                "FAILURE received UE reconf CONF from L2 , after P_A is reconfigured");
                        /* BUG_876_CHANGES_START */
                        if (RRM_UE_POSITION_AT_CELL_CENTER == p_rrm_ue_ctxt->dynamic_icic_info.
                                rrm_ue_dynamic_icic_present_data.ue_present_position)
                        {
                            rrm_cellm_increment_dynamic_icic_counter_in_cell(p_rrm_ue_ctxt->cell_index,
                                    RRM_CELLM_DYNAMIC_ICIC_CELL_EDGE_UES);
                            rrm_cellm_decrement_dynamic_icic_counter_in_cell(p_rrm_ue_ctxt->cell_index,
                                    RRM_CELLM_DYNAMIC_ICIC_CELL_CENTER_UES);
                        }                    
                        else if (RRM_UE_POSITION_AT_CELL_EDGE == p_rrm_ue_ctxt->dynamic_icic_info.
                                rrm_ue_dynamic_icic_present_data.ue_present_position)
                        {            
                            rrm_cellm_increment_dynamic_icic_counter_in_cell(p_rrm_ue_ctxt->cell_index,
                                    RRM_CELLM_DYNAMIC_ICIC_CELL_CENTER_UES);
                            rrm_cellm_decrement_dynamic_icic_counter_in_cell(p_rrm_ue_ctxt->cell_index,
                                    RRM_CELLM_DYNAMIC_ICIC_CELL_EDGE_UES);
                        }                        
                        /* BUG_876_CHANGES_END */

                        p_rrm_ue_ctxt->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_past_position =
                            p_rrm_ue_ctxt->dynamic_icic_info.rrm_ue_dynamic_icic_past_data.ue_past_position ;
                        p_rrm_ue_ctxt->dynamic_icic_info.rrm_ue_dynamic_icic_present_data.ue_present_position =
                            p_rrm_ue_ctxt->dynamic_icic_info.rrm_ue_dynamic_icic_past_data.ue_present_position ;

                    }
                    p_rrm_ue_ctxt->dynamic_icic_info.location_update_req_for_ue_reconfig = RRM_FALSE;
                }
                if( RRM_ZERO == p_rrm_glb_ctxt->mac_ue_reconfig_sequence_list.count)
                {
                    p_cell_context->dynamic_icic_data.mac_loc_update_triggrd_aftr_ue_reconfig = RRM_FALSE;   
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, 
                        "NODE in MAC UE RECONFIG SEQ UE LIST is NULL.Either invalid MAC CNF is recieved OR"
                        "LIST is not updated at the time of triggering MAC UE RECONFIG request");
            }
            /* COVERITY ID 58743 FIX */
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, 
                    "MAC UE RECONFIG SEQ UE LIST is EMPTY.Invalid MAC CNF is recieved");
        }
        /* SPR 8315 FIX END*/
    }
/*Location update fix in UE RECONFIG*/
    else
    {
        p_rrm_glb_ctxt_icic_data = &(p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.rrm_ue_loc_update_action_info);
        RRM_ASSERT(RRM_PNULL != p_rrm_glb_ctxt_icic_data);

        ue_location_update_action = p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.
            rrm_ue_loc_update_action_info.ue_location_update_action;

        (p_rrm_glb_ctxt_icic_data->num_of_requests_triggered)--;
        /* SPR 8315 FIX START*/
        if (p_ue_reconf_cnf->responseCode != RRM_FAILURE)
            /* SPR 8315 FIX END*/
        {
            if(RRM_ZERO != p_rrm_glb_ctxt_icic_data->num_of_requests_triggered)
            {
                /* 
                   Still initalize the Action Resp with FAILURE as
                   more responses from L2 are expected. RRM knowx that this is success
                   but still assigning the response code with failure so that success
                   can only be set when last response is received as further action
                   to decrease the UL tx power OR a response to CellM depends on this last
                   response.
                   */
                p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp = RRM_FAILURE;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "SUCCESS received and Still response expected is [%d]",
                        p_rrm_glb_ctxt_icic_data->num_of_requests_triggered); 
            }
            else
            {
                p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp = RRM_SUCCESS;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                        "SUCCESS received and this is the last response");
            }
        }
        else
        {
            p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp = RRM_FAILURE;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                    "FAILURE received and Still response expected is [%d]",
                    p_rrm_glb_ctxt_icic_data->num_of_requests_triggered); 
        }

        if(RRM_ZERO == p_rrm_glb_ctxt_icic_data->num_of_requests_triggered)
        {
            /* SPR 20613 Changes Start */
            /* Code Deleted */
            /* SPR 20613 Changes End */
            /* Commit the position for all the UEs as per the action requested from CellM
               During the preocessing of UE REconfig the new position has not been commited in
               Ue context but success  has been received from L2 for all request so need to commit the 
               position to the requested one from Cell M.
               */
            /* SPR 20652 Fix Start */
                rrm_ue_get_first_node_ctxt(&ue_node, &p_ue_context, cell_index);
            while(RRM_PNULL != p_ue_context)
            {
                /* SPR 20613 Changes Start */
                if(RRM_SUCCESS == p_rrm_glb_ctxt->rrm_cellm_uem_ue_update_data.ue_loc_update_action_resp)
                    /* SPR 20613 Changes End */
                {
                    /* If a UE is found with the specified cell index && UE sub state is RRM_UE_ERB_NULL*/
                    if((cell_index == p_ue_context->cell_index) &&
                            (RRM_UE_ICIC_UPDATE_INFO_ONGOING == p_ue_context->current_procedure.state))
                    {
                        switch(ue_location_update_action)
                        {
                            case UE_LOCATION_UPDATE_CE_TO_CC:
                                if(RRM_UE_POSITION_AT_CELL_EDGE == p_ue_context->dynamic_icic_info.
                                        rrm_ue_dynamic_icic_present_data.ue_present_position)
                                {
                                    /* Update the loction of UE as Cell Center */
                                    p_ue_context->dynamic_icic_info.
                                        rrm_ue_dynamic_icic_present_data.ue_present_position = RRM_UE_POSITION_AT_CELL_CENTER;
                                }
                                break;
                            case UE_LOCATION_UPDATE_CC_TO_CE: 
                                if(RRM_UE_POSITION_AT_CELL_CENTER == p_ue_context->dynamic_icic_info.
                                        rrm_ue_dynamic_icic_present_data.ue_present_position)
                                {
                                    /* Update the loction of UE as Cell Center */
                                    p_ue_context->dynamic_icic_info.
                                        rrm_ue_dynamic_icic_present_data.ue_present_position = RRM_UE_POSITION_AT_CELL_EDGE;
                                }
                                break;
                            default:
                                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                                        " Invalid update loction action[%d] is recieved!! ", ue_location_update_action); 
                        }
                    }
                    /* SPR 20613 Changes Start */
                    /* Code Deleted */
                    /* SPR 20613 Changes End */
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,
                            "Failure received so no action on position of UEs");
                }
                /* SPR 20613 Fix START */
                p_ue_context->current_procedure.state = RRM_UE_ERB_NULL;
                /* SPR 20613 Fix END */
                ue_node = rrm_ue_get_next_node_ctxt(&ue_node, &p_ue_context, cell_index);
                /* SPR 20652 Fix End */
            }
            /* SPR 20613 +- */
            uem_action_on_icic_reports_in_requested_cell(p_rrm_glb_ctxt);
        }
    }
    /* SPR 10857 Fix Start */
    /* Code deleted */
    /* SPR 10857 Fix End */
    /*SPR 7892 FIX START*/
    rrm_set_mac_ue_reconfig_mutex(cell_index,MAC_UE_RECONF_NOT_ONGOING);
    /*SPR 7892 FIX END*/

    RRM_UT_TRACE_EXIT();
}
/*  DYNAMIC ICIC CHANGES END  */

/*  UE Positioning coede changes start */
/*******************************************************************************
 *   FUNCTION NAME: rrm_convert_rrm_ecgi_into_rrc_ecgi
 *   DESCRIPTION:
 *       Coverts rrm_convert_rrm_ecgi_into_rrc_ecgi
 *   RETURNS:
 *       RRM_SUCCESS If converted successfully.
 *       RRM_FAILURE otherwise
 ******************************************************************************/
    rrm_return_et
rrm_convert_rrm_ecgi_into_rrc_ecgi (
        rrm_global_cell_id_t            rrm_ecgi,
        lppa_ecgi_t                     *p_rrc_ecgi
        )
{
    rrm_return_et                 ret_val             = RRM_SUCCESS; 
    rrm_bool_et                   filler_digit        = RRM_FALSE;
    rrm_bool_et                   fill_ecgi_continue  = RRM_TRUE;
    U8                            rrm_no_of_mcc_filled       = RRM_ZERO;
    U8                            rrm_no_of_mnc_filled       = RRM_ZERO;
    U8                            index                      = RRM_ZERO;
    U8                            nibble_index               = RRM_ZERO;

    RRM_UT_TRACE_ENTER();


    if(RRM_NULL == p_rrc_ecgi)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_rrc_ecgi is NULL");
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_rrc_ecgi, RRM_ZERO, sizeof(lppa_ecgi_t));

    for(index = RRM_ZERO; (index < MAX_PLMN_ID_BYTES) && (fill_ecgi_continue == RRM_TRUE) ; index++)
    {
        for(nibble_index = RRM_ZERO; nibble_index < RRM_TWO; nibble_index++)
        {
            if( rrm_no_of_mcc_filled < MAX_MCC_DIGITS)
            {
                p_rrc_ecgi->plmn_identity.plmn_id[index] =  (p_rrc_ecgi->plmn_identity.plmn_id[index]) | 
                    (rrm_ecgi.primary_plmn_id.mcc[rrm_no_of_mcc_filled] << (nibble_index*4));
                rrm_no_of_mcc_filled++;
            }
            /* Fill mnc digits if mcc is filled */
            else
            {
                if(rrm_ecgi.primary_plmn_id.num_mnc_digit == RRM_ZERO)
                {
                    RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_BRIEF, 
                            "No mnc_digit in CELL ECGI ");
                    fill_ecgi_continue = RRM_FALSE;
                    break;
                }
                else if(rrm_ecgi.primary_plmn_id.num_mnc_digit == RRM_ONE)
                {
                    RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_BRIEF, 
                            "ONE  mnc_digit in CELL ECGI wrong case ");
                    fill_ecgi_continue = RRM_FALSE;
                    ret_val = RRM_FAILURE;
                    break;
                }
                else
                {
                    if(rrm_ecgi.primary_plmn_id.num_mnc_digit == RRM_TWO && filler_digit == RRM_FALSE)
                    {
                        p_rrc_ecgi->plmn_identity.plmn_id[index] =  p_rrc_ecgi->plmn_identity.plmn_id[index] | (RRM_PLMN_FILLER_DIGIT <<(nibble_index*RRM_FOUR));
                        filler_digit = RRM_TRUE;
                    }
                    else
                    {
                        p_rrc_ecgi->plmn_identity.plmn_id[index] =  (p_rrc_ecgi->plmn_identity.plmn_id[index]) |
                            (rrm_ecgi.primary_plmn_id.mnc[rrm_no_of_mnc_filled] <<(nibble_index*RRM_FOUR));
                        rrm_no_of_mnc_filled++;
                    }
                }
            }
        }
    }
    if( RRM_SUCCESS == ret_val)
    {
        RRM_MEMCPY(p_rrc_ecgi->eutran_cell_id,
                rrm_ecgi.cell_identity,
                sizeof(U8)*MAX_CELL_IDENTITY_OCTETS);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_fill_serv_cell_ecid_info
 * Inputs         : p_ue_context
 : ecid_meas_report
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This funcion fill the serving cell ECGI and TAC info 
 ****************************************************************************/
rrm_return_et
rrm_fill_serv_cell_ecid_info( 
        rrm_cell_index_t                     cell_index,
        lppa_e_cid_meas_result_t             *p_lppa_ecid_meas_result
        )
{
    rrm_return_et        ret_val = RRM_SUCCESS;
    rrm_cell_context_t   *p_cell_context = RRM_PNULL;
    U8                   index=RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if( RRM_PNULL != p_lppa_ecid_meas_result)
    {
        p_cell_context =  rrm_cellm_get_cell_context(cell_index);
        if(RRM_PNULL != p_cell_context )
        {
            ret_val = rrm_convert_rrm_ecgi_into_rrc_ecgi(p_cell_context->global_cell_id,&(p_lppa_ecid_meas_result->serving_cell_id));
            if(ret_val == RRM_SUCCESS)
            {
                if( p_cell_context->epc_info.epc_params.bitmask & RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT)
                {
                    for(index=RRM_ZERO; index < MAX_TAC_SIZE ; index ++ )
                    {
                        p_lppa_ecid_meas_result->serving_cell_tac[index] = p_cell_context->epc_info.epc_params.general_epc_params.tac[index];
                    }
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR, 
                "either p_ue_context or p_lppa_ecid_meas_resulte is NULL");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_fill_lppa_meas_result
 * Inputs         : p_ue_context
 : p_ecid_meas_result
 : p_ue_meas_results
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This funcion fill the serving cell ECGI and TAC info 
 ****************************************************************************/
    rrm_return_et
rrm_fill_lppa_rsrp_meas_result(rrm_cell_index_t               cell_index,
        lppa_measured_res_t                 *p_ecid_meas_result,
        rrm_ue_measurment_results_ind_t     *p_ue_meas_results)
{
    rrm_return_et                          ret_val = RRM_SUCCESS;
    rrm_cell_context_t                     *p_cell_ctxt = RRM_PNULL;
    U8                                     index=RRM_ZERO;
    U8                                     intra_cell_index = RRM_ZERO;
    lte_ncl_t                              *p_lte_ncl      = rrm_cellm_get_lte_ncl_info(cell_index);
    U8                                     meas_rsrp_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_ecid_meas_result &&
            RRM_PNULL != p_ue_meas_results &&
            RRM_PNULL != p_lte_ncl) /* Coverity: CID 30919 */
    {
        p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);

        /* SPR 8771: neighbour cell count check removed */
        /*CID 65778,65779:start*/
        if (RRM_PNULL != p_cell_ctxt)
        {
            p_ecid_meas_result->bitmask |= LPPA_MEAS_RESULT_RESULT_RSRP_PRESENT;
            rrm_fill_lppa_rsrp_meas_result_for_serving_cell(p_cell_ctxt, p_ecid_meas_result, p_ue_meas_results);
            meas_rsrp_count++;
            for(index =RRM_ZERO;index< p_ue_meas_results->eutran_count ; index++)
            {
                for(intra_cell_index = RRM_ZERO; intra_cell_index < p_lte_ncl->num_valid_intra_freq_cell; intra_cell_index++)
                {
                    if(p_ue_meas_results->eutran_neighbor_list[index].pci == p_lte_ncl->intra_freq_cells[intra_cell_index].phy_cell_id) 
                    {
                        p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].pci = p_ue_meas_results->eutran_neighbor_list[index].pci;
                        p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].earfcn = p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
                        p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].value_rsrp= p_ue_meas_results->eutran_neighbor_list[index].rsrp;
                        if(p_lte_ncl->intra_freq_cells[intra_cell_index].bitmask & RRMCM_RMIF_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT)
                        {
                            p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].bitmask |= LPPA_RESULT_RSRP_ECGI_PRESENT;
                            rrm_convert_rrm_ecgi_into_rrc_ecgi( p_lte_ncl->intra_freq_cells[intra_cell_index].cell_id,
                                    &(p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].ecgi));
                        }
                        p_ecid_meas_result->meas_result_rsrp.rsrp_count++;
                        meas_rsrp_count++;
                        break;
                    }
                }
            }
            if(meas_rsrp_count  == RRM_ZERO)
            {
                RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR, 
                        "PCI of cells obtained in meas results do not match with any of the cells in the NCL");
                ret_val = RRM_FAILURE;
            }
        }
        /*CID 65778,65779:end*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR, 
                "either p_ecid_meas_result or p_ue_meas_results or NCL list is NULL");

        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_fill_lppa_rsrq_meas_result
 * Inputs         : p_ue_context
 : p_ecid_meas_result
 : p_ue_meas_results
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This funcion fill the serving cell ECGI and TAC info 
 ****************************************************************************/
    rrm_return_et
rrm_fill_lppa_rsrq_meas_result(rrm_cell_index_t               cell_index,
        lppa_measured_res_t                 *p_ecid_meas_result,
        rrm_ue_measurment_results_ind_t     *p_ue_meas_results)
{

    rrm_return_et                          ret_val = RRM_SUCCESS;
    rrm_cell_context_t                     *p_cell_ctxt = RRM_PNULL;
    U8                                     index=RRM_ZERO;
    U8                                     intra_cell_index = RRM_ZERO;
    lte_ncl_t                              *p_lte_ncl      = rrm_cellm_get_lte_ncl_info(cell_index);
    U8                                     meas_rsrq_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_ecid_meas_result &&
            RRM_PNULL != p_ue_meas_results &&
            RRM_PNULL != p_lte_ncl) /* Coverity: CID 30920 */
    {
        p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);
        /*CID 65779:start*/    
        if (RRM_PNULL != p_cell_ctxt)
        {
            p_ecid_meas_result->bitmask |= LPPA_MEAS_RESULT_RESULT_RSRQ_PRESENT;
            /* SPR 8771: neighbour cell count check removed */
            rrm_fill_lppa_rsrq_meas_result_for_serving_cell(p_cell_ctxt, p_ecid_meas_result, p_ue_meas_results);
            meas_rsrq_count++;
            for(index =RRM_ZERO;index< p_ue_meas_results->eutran_count ; index++)
            {
                for(intra_cell_index =RRM_ZERO; intra_cell_index < p_lte_ncl->num_valid_intra_freq_cell  ;intra_cell_index++)
                {
                    if(p_ue_meas_results->eutran_neighbor_list[index].pci == p_lte_ncl->intra_freq_cells[intra_cell_index].phy_cell_id) 
                    {
                        p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].pci = p_ue_meas_results->eutran_neighbor_list[index].pci;
                        p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].earfcn = p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
                        p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].value_rsrq= p_ue_meas_results->eutran_neighbor_list[index].rsrq;
                        if(p_lte_ncl->intra_freq_cells[intra_cell_index].bitmask & RRMCM_RMIF_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT)
                        {
                            p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].bitmask |= LPPA_RESULT_RSRQ_ECGI_PRESENT;
                            rrm_convert_rrm_ecgi_into_rrc_ecgi( p_lte_ncl->intra_freq_cells[intra_cell_index].cell_id,
                                    &(p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].ecgi));
                        }
                        p_ecid_meas_result->meas_result_rsrq.rsrq_count++;
                        meas_rsrq_count++;
                        break;
                    }
                }
            }
            if(meas_rsrq_count  == RRM_ZERO)
            {
                RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR, 
                        "PCI of cells obtained in meas results do not match with any of the cells in the NCL");
                ret_val = RRM_FAILURE;
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;

        }
        /*CID 65779:end*/    
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR, 
                "either p_ecid_meas_result or p_ue_meas_results or NCL list is NULL");
        ret_val= RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_clean_ue_ecid_meas_related_info
 * Inputs         : p_ue_context
 : esmlc_meas_id
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This funcion release requested ue_meas_config_fill and reset the ecid meas info from UE 
 ****************************************************************************/
    rrm_return_et
rrm_clean_ue_ecid_meas_related_info(
        rrm_ue_context_t       *p_ue_context,
        U8                    eslmc_meas_id
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    U8                              counter = RRM_ZERO;
    /*
       rrc_rrm_meas_config_req_t      *p_rrc_rrm_meas_config_req = RRM_PNULL;
       U16                             transaction_id = RRM_ZERO;
       */
    /*SPR_8004:fix_start */
    U8                              index = RRM_ZERO;
    /*SPR_8004:fix_end */

    RRM_UT_TRACE_ENTER();

    if((p_ue_context != RRM_PNULL) &&
            (eslmc_meas_id < RRM_MAX_ESMLC_MEAS_ID))
    {

        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_req_received= RRM_FALSE;
        /*SPR_8004:fix_start */
        for(index = RRM_ZERO; index < MAX_ALLOCATED_ID_FOR_ECID; index ++)
        {
            p_ue_context->p_ue_positioing_data[eslmc_meas_id].meas_id_and_meas_obj_id[index].\
                meas_id = RRM_ZERO;
            p_ue_context->p_ue_positioing_data[eslmc_meas_id].meas_id_and_meas_obj_id[index].\
                meas_object_id = RRM_ZERO;
            p_ue_context->p_ue_positioing_data[eslmc_meas_id].meas_id_and_meas_obj_id[index].\
                report_config_id = RRM_ZERO;

        }
        /*SPR_8004:fix_end */
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].mme_id = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].routing_id = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].e_smlc_ue_meas_id= RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].enb_ue_meas_id = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].report_type = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].num_meas_quantifier = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ue_mac_meas_status = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ue_meas_send_for_rem =  RRM_FALSE;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ta1_ta2_aoa_req =  RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_report_sent =  RRM_FALSE;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].timer_expire_count =  RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ue_meas_id_allocate =  RRM_FALSE;

        /* Re-setting the params for MAC meas, in UE context to ZERO */
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_mac_data.sfn_for_enb_rxtx_diff_type1 = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_mac_data.enb_rxtx_diff_type1 = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_mac_data.sfn_for_enb_rxtx_diff_type2 = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_mac_data.enb_rxtx_diff_type2 = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_mac_data.sfn_for_AoA = RRM_ZERO;
        for(counter = RRM_ZERO; counter<MAX_NUM_ANTENNA; counter++)
        {
            p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_mac_data.AoA[counter] = RRM_ZERO;
        }

        /* Re-setting the params for UE meas, in UE context to ZERO */
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_ue_data.meas_result_serv_cell.rsrp_result = RRM_ZERO;
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_ue_data.meas_result_serv_cell.rsrq_result = RRM_ZERO;

        for(counter = RRM_ZERO; counter<(p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_ue_data.eutran_count); counter++)
        {
            p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_ue_data.eutran_neighbor_list[counter].pci = RRM_ZERO;
            p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_ue_data.eutran_neighbor_list[counter].rsrp = RRM_ZERO;
            p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_ue_data.eutran_neighbor_list[counter].rsrq = RRM_ZERO;
        }
        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_ue_data.eutran_count = RRM_ZERO;

        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_ue_data.meas_result_ecid_r9.ue_rxtx_time_diff = RRM_ZERO;
        for(counter=RRM_ZERO; counter<ECID_CURRENT_SFN_OCTET_SIZE; counter++)
        {
            p_ue_context->p_ue_positioing_data[eslmc_meas_id].ecid_meas_ue_data.meas_result_ecid_r9.current_sfn_r9[counter] = RRM_ZERO;
        }

        p_ue_context->p_ue_positioing_data[eslmc_meas_id].ue_mac_meas_status = RRM_ZERO;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"Either p_ue_context is NULL or eslmc_meas_id[%u] >= 15 "
                ,eslmc_meas_id);

    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_clean_ue_all_ecid_meas_related_info
 * Inputs         : p_ue_context
 : esmlc_meas_id
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This funcion release requested ue_meas_config_fill and reset the ecid meas info from UE 
 ****************************************************************************/
    void 
rrm_clean_ue_all_ecid_meas_related_info(
        rrm_ue_context_t       *p_ue_context
        )
{
    U8 index=RRM_ZERO;
    /*SPR_8004:fix_start */
    U8 meas_index = RRM_ZERO;
    /*SPR_8004:fix_end */

    RRM_UT_TRACE_ENTER();
    if(p_ue_context !=  RRM_PNULL)
    {
        if (RRM_PNULL != p_ue_context->p_ue_positioing_data)
        {
          for(index=RRM_ZERO; index < RRM_MAX_ESMLC_MEAS_ID; index ++)
          {
            if(p_ue_context->p_ue_positioing_data[index].ecid_meas_req_received)
            {
              if(p_ue_context->p_ue_positioing_data[index].ue_meas_id_allocate)
              {
                /*SPR_8004:fix_start */
                for(meas_index = RRM_ZERO; meas_index < MAX_ALLOCATED_ID_FOR_ECID; meas_index ++)
                {
                  rrm_uem_deallocate_meas_user_id_for_ue_positioing(p_ue_context,
                      p_ue_context->p_ue_positioing_data[index].meas_id_and_meas_obj_id[meas_index].\
                      meas_id, p_ue_context->p_ue_positioing_data[index].\
                      meas_id_and_meas_obj_id[meas_index].report_config_id);
                }
                /*SPR_8004:fix_end */
              }
              rrm_clean_ue_ecid_meas_related_info (p_ue_context,index);
              if( p_ue_context->p_ue_positioing_data[index].ue_pos_timer &&
                  p_ue_context->p_ue_positioing_data[index].ue_meas_send_for_rem == RRM_FALSE )
              {
                /* Stop UE positioing timer for waiting for UE meas_config_req */
                RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE POsitioing timer");
                /* CSR-58333-fix start*/
                rrm_ue_stop_timer( p_ue_context->p_ue_positioing_data[index].ue_pos_timer);
                /* CSR-58333-fix end*/
                p_ue_context->p_ue_positioing_data[index].ue_pos_timer = RRM_PNULL;
              }
              RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,"Reset the ESMLC_MEAS_REQ[%d] info for [UE:%d]",
                  index,p_ue_context->ue_index);
            }
          }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "UE context is NULL");
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_ue_delete_meas_id_info_for_ecid_meas
 * Inputs         : p_ue_context
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This funcion release meas_id_info for the ecid meas req of UE 
 ****************************************************************************/
    void 
rrm_ue_delete_meas_id_info_for_ecid_meas(
        rrm_ue_context_t          *p_rrm_ue_ctx,
        U8                         ecid_meas_index
        )
{
    meas_report_info_node_t* p_meas_report_node = RRM_PNULL;
    /*SPR_8004:fix_start*/
    U8                       meas_index         = RRM_ZERO;
    /*SPR_8004:fix_end*/

    YLNODE *p_node = RRM_PNULL;
    YLNODE *p_tmp_node = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_ctx !=  RRM_PNULL)
    {
        if(p_rrm_ue_ctx->p_ue_positioing_data[ecid_meas_index].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD)
        {
            if(p_rrm_ue_ctx->p_ue_positioing_data[ecid_meas_index].ue_meas_id_allocate)
            {
                /*SPR_8004:fix_start*/

                for(meas_index = RRM_ZERO ;meas_index < MAX_ALLOCATED_ID_FOR_ECID ; meas_index ++)
                {
                    rrm_uem_deallocate_meas_user_id_for_ue_positioing(p_rrm_ue_ctx,
                            p_rrm_ue_ctx->p_ue_positioing_data[ecid_meas_index].\
                            meas_id_and_meas_obj_id[meas_index].meas_id, 
                            p_rrm_ue_ctx->p_ue_positioing_data[ecid_meas_index].\
                            meas_id_and_meas_obj_id[meas_index].report_config_id);
                }

                /*SPR_8004:fix_end*/
            }
            p_node = ylFirst(&(p_rrm_ue_ctx->meas_report_list));
            while (p_node)
            {
                p_tmp_node = p_node;
                p_meas_report_node = (meas_report_info_node_t*)p_node;

                p_node = ylNext(p_node);
                if((MEAS_TYPE_ECID  == p_meas_report_node->meas_type)) 
                {    
                    /*SPR_8004:fix_start*/
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,"meas_info[meas_id=%d] \
                            for esmlc_meas =%d is deleted",
                            p_meas_report_node->meas_id,
                            p_rrm_ue_ctx->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id);

                    ylDelete(&(p_rrm_ue_ctx->meas_report_list),p_tmp_node);
                    RRM_MEM_FREE(p_tmp_node);
                    break;

                    /*SPR_8004:fix_end */
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"UE context is null");
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_fill_eutran_access_point
 * Inputs         : rrm_cell_context_t *p_cell_ctx.
 * Outputs        : lppa_e_utran_access_point_pos_t *e_utran_access_point_pos.
 * Returns        : 
 * Description    : fill e-utran access point params for UE Positioing.
 ****************************************************************************/
    rrm_void_t
rrm_fill_eutran_access_point(
        rrm_cell_index_t cell_index,
        lppa_e_cid_meas_result_t *p_ecid_meas_result)
{
    rrm_cell_context_t                       *p_cell_ctx = RRM_PNULL;

    if(RRM_PNULL != p_ecid_meas_result)
    {
        p_cell_ctx = rrm_cellm_get_cell_context(cell_index);

        RRM_UT_TRACE_ENTER();
        if(RRM_PNULL == p_cell_ctx )
        {
            RRM_TRACE(g_uem_log_on_off,
                    p_g_rrm_uem_facility_name, RRM_WARNING,
                    "Cell Context not found at [UE:%d]",cell_index);
        }
        else if (RRMCM_RMIF_EUTRAN_ACCESS_POINT_POS_PRESENT & p_cell_ctx->operator_info.bitmask)
        {
            p_ecid_meas_result->e_utran_access_point_pos.latitude_sign = p_cell_ctx->operator_info.eutran_access_point_pos.latitude_sign;
            p_ecid_meas_result->e_utran_access_point_pos.deg_of_latitude = p_cell_ctx->operator_info.eutran_access_point_pos.deg_of_latitude;
            p_ecid_meas_result->e_utran_access_point_pos.deg_of_longitude = p_cell_ctx->operator_info.eutran_access_point_pos.deg_of_longitude;
            p_ecid_meas_result->e_utran_access_point_pos.deg_of_altitude = p_cell_ctx->operator_info.eutran_access_point_pos.dir_of_altitude;
            p_ecid_meas_result->e_utran_access_point_pos.altitude = p_cell_ctx->operator_info.eutran_access_point_pos.altitude;
            p_ecid_meas_result->e_utran_access_point_pos.uncertainty_semi_major = p_cell_ctx->operator_info.eutran_access_point_pos.uncertainty_semi_major;
            p_ecid_meas_result->e_utran_access_point_pos.uncertainty_semi_minor = p_cell_ctx->operator_info.eutran_access_point_pos.uncertainty_semi_minor;
            p_ecid_meas_result->e_utran_access_point_pos.orientation_of_major_axis = p_cell_ctx->operator_info.eutran_access_point_pos.orientation_of_major_axis;
            p_ecid_meas_result->e_utran_access_point_pos.uncertainty_altitude = p_cell_ctx->operator_info.eutran_access_point_pos.uncertainty_altitude;
            p_ecid_meas_result->e_utran_access_point_pos.confidence = p_cell_ctx->operator_info.eutran_access_point_pos.confidence;
            p_ecid_meas_result->bitmask |= LPPA_E_UTRAN_ACCESS_POINT_POSITION_PRESENT;
        }
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_ue_is_valid_ecid_meas_request
 * Inputs         : rrm_global_context_t *p_rrm_glb_ctxt RRM Global Context.
 * Outputs        : None.
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : fill e-utran access point params for UE Positioing.
 ****************************************************************************/
    rrm_bool_et
rrm_ue_is_valid_ecid_meas_request (
        rrm_ue_context_t *p_ue_context,
        rrm_ue_lppa_ecid_meas_init_req_t *p_rrm_lppa_ecid_meas_init_req)
{
    rrm_bool_et                     ret_val = RRM_TRUE;
    U8                              rrm_esmlc_cnt = RRM_ZERO;
    U8                              meas_cnt = RRM_ZERO;
    U8                              meas_cnt_of_req = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    for (rrm_esmlc_cnt = RRM_ZERO; rrm_esmlc_cnt < RRM_MAX_ESMLC_MEAS_ID; rrm_esmlc_cnt++)
    {
        if (RRM_TRUE == p_ue_context->p_ue_positioing_data[rrm_esmlc_cnt].ecid_meas_req_received)
        {
            for (meas_cnt = RRM_ZERO; meas_cnt < p_ue_context->p_ue_positioing_data[rrm_esmlc_cnt].
                    num_meas_quantifier; meas_cnt++)
            {
                if(p_rrm_lppa_ecid_meas_init_req->num_meas_quantifier)
                {
                    for (meas_cnt_of_req = RRM_ZERO ;meas_cnt_of_req < p_rrm_lppa_ecid_meas_init_req->num_meas_quantifier; meas_cnt_of_req++)
                    {
                        if (p_ue_context->p_ue_positioing_data[rrm_esmlc_cnt].meas_quantifier[meas_cnt] ==
                                p_rrm_lppa_ecid_meas_init_req->meas_quantifier[meas_cnt_of_req].meas_quantity_item)
                        {
                            if (p_ue_context->p_ue_positioing_data[rrm_esmlc_cnt].report_type ==
                                    p_rrm_lppa_ecid_meas_init_req->report_char)
                            {
                                RRM_TRACE(g_uem_log_on_off,
                                        p_g_rrm_uem_facility_name, RRM_WARNING,
                                        "Already recieved similar report type ");
                                ret_val = RRM_FALSE;
                                RRM_UT_TRACE_EXIT();
                                return ret_val;
                            }
                        }
                        else if(((p_rrm_lppa_ecid_meas_init_req->meas_quantifier[meas_cnt_of_req].meas_quantity_item == RRM_LPPA_ANGLEOFARRIVAL) ||
                                    (p_rrm_lppa_ecid_meas_init_req->meas_quantifier[meas_cnt_of_req].meas_quantity_item == RRM_LPPA_TIMINGADVANCETYPE1) ||
                                    (p_rrm_lppa_ecid_meas_init_req->meas_quantifier[meas_cnt_of_req].meas_quantity_item == RRM_LPPA_TIMINGADVANCETYPE2)) &&
                                p_ue_context->p_ue_positioing_data[rrm_esmlc_cnt].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD)
                        {
                            RRM_TRACE(g_uem_log_on_off,
                                    p_g_rrm_uem_facility_name, RRM_WARNING,
                                    "Only support one esmlc_meas_init for AOA/TA1/TA2 there is already one esmlc_meas_init_req=%d for AOA/TA1/TA2",
                                    p_ue_context->p_ue_positioing_data[rrm_esmlc_cnt].e_smlc_ue_meas_id);
                            ret_val = RRM_FALSE;
                            RRM_UT_TRACE_EXIT();
                            return ret_val;
                        }
                    }
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_fill_lppa_rsrp_meas_result_for_serving_cell
 * Inputs         : p_cell_ctxt
 : p_ecid_meas_result
 : p_ue_meas_results
 * Outputs        : NONE
 * Returns        : NONE
 * Description    : This funcion fill the serving cell RSRP info for ECID meas results
 ****************************************************************************/
    rrm_void_t
rrm_fill_lppa_rsrp_meas_result_for_serving_cell(
        rrm_cell_context_t                  *p_cell_ctxt,
        lppa_measured_res_t                 *p_ecid_meas_result,
        rrm_ue_measurment_results_ind_t     *p_ue_meas_results
        )
{
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_ecid_meas_result &&
            RRM_PNULL != p_ue_meas_results &&
            RRM_PNULL != p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Populating RSRP meas result for the serving cell");
        p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].pci = 
            p_cell_ctxt->ran_info.rf_params.rf_configurations.phy_cell_id;
        p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].earfcn = 
            p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
        p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].value_rsrp = 
            p_ue_meas_results->meas_result_serv_cell.rsrp_result;

        p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].bitmask |= LPPA_RESULT_RSRP_ECGI_PRESENT;
        p_ecid_meas_result->meas_result_rsrp.rsrp_count++;
        rrm_convert_rrm_ecgi_into_rrc_ecgi(p_cell_ctxt->global_cell_id,
                &(p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].ecgi));
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ecid_meas_result or p_ue_meas_results or p_cell_ctxt is NULL");
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_fill_lppa_rsrq_meas_result_for_serving_cell
 * Inputs         : p_cell_ctxt
 : p_ecid_meas_result
 : p_ue_meas_results
 * Outputs        : NONE
 * Returns        : NONE
 * Description    : This funcion fills the serving cell RSRQ info for ECID meas results
 ****************************************************************************/
    rrm_void_t
rrm_fill_lppa_rsrq_meas_result_for_serving_cell(
        rrm_cell_context_t                  *p_cell_ctxt,
        lppa_measured_res_t                 *p_ecid_meas_result,
        rrm_ue_measurment_results_ind_t     *p_ue_meas_results
        )
{
    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_ecid_meas_result &&
            RRM_PNULL != p_ue_meas_results &&
            RRM_PNULL != p_cell_ctxt)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Populating RSRQ meas result for the serving cell");
        p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].pci =
            p_cell_ctxt->ran_info.rf_params.rf_configurations.phy_cell_id;
        p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].earfcn =
            p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
        p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].value_rsrq =
            p_ue_meas_results->meas_result_serv_cell.rsrq_result;

        p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].bitmask |= LPPA_RESULT_RSRQ_ECGI_PRESENT;
        p_ecid_meas_result->meas_result_rsrq.rsrq_count++;
        rrm_convert_rrm_ecgi_into_rrc_ecgi(p_cell_ctxt->global_cell_id,
                &(p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].ecgi));
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ecid_meas_result or p_ue_meas_results or p_cell_ctxt is NULL");
    }
    RRM_UT_TRACE_EXIT();
}

/*******************************************************************************
 * Function Name  : rrm_mac_process_ecid_meas_report_resp_event
 * Inputs         : cell_index
 : p_rrm_glb_ctxt
 : p_mac_ecid_meas_report_resp
 * Outputs        : NONE
 * Returns        : 
 *                  rrm_return_et(SUCCESS / FAILURE)
 * Description    : This funcion processes the MAC_RRM_ECID_MEAS_REPORT_RESP API
 *                  and stores the param values in UE context
 *******************************************************************************/
    rrm_return_et
rrm_mac_process_ecid_meas_report_resp_event(
        rrm_cell_index_t                   cell_index,
        rrm_ue_global_context_t           *p_rrm_glb_ctxt,
        MacRrmEcidMeasurementResp   *p_mac_ecid_meas_report_resp
        )
{
    rrm_return_et                 ret_val = RRM_SUCCESS;
    rrm_ue_index_t                ue_index = RRM_ZERO;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t             *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    U8                            index = RRM_ZERO;
    /* CID 53406 */
    s1ap_rrm_lppa_ecid_meas_report_t     *p_lppa_ecid_meas_report = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    /* CID 53406 */
    p_lppa_ecid_meas_report = (s1ap_rrm_lppa_ecid_meas_report_t*)rrm_mem_get(sizeof(s1ap_rrm_lppa_ecid_meas_report_t));
    if (p_lppa_ecid_meas_report == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_lppa_ecid_meas_report failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }    
    RRM_MEMSET(p_lppa_ecid_meas_report,RRM_ZERO,sizeof(s1ap_rrm_lppa_ecid_meas_report_t));

    if(RRM_PNULL != p_rrm_glb_ctxt &&
            RRM_PNULL != p_mac_ecid_meas_report_resp)
    {
        /* Finding the UE context from the given UE index */
        ue_index = p_mac_ecid_meas_report_resp->ueIndex;
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(ue_index, cell_index);

        if(RRM_PNULL == p_ue_context)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "[UE:%d], Unable to find UE context", ue_index);

            ret_val = RRM_FAILURE;
        }

        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                "[UE:%d], UE context found  response code =%d", ue_index,p_mac_ecid_meas_report_resp->responseCode );

            p_rrm_glb_ctxt->p_ue_context = p_ue_context; /* UE context copied in the Global context */
            p_rrm_glb_ctxt->p_ue_context->is_mac_req_initiated = RRM_FALSE;

            if(RRM_SUCCESS == p_mac_ecid_meas_report_resp->responseCode ||
                    RRM_PARTIAL_SUCCESS == p_mac_ecid_meas_report_resp->responseCode)
            {
                for(index = RRM_ZERO; index < RRM_MAX_ESMLC_MEAS_ID; index++)
                {
                    if(p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].ecid_meas_req_received == RRM_TRUE        &&
                            p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD)
                    {
                        /*  Bitmask in the UE context set to TRUE, to indicate that 
                         ** the data for a particular ESMLC id from MAC has arrived */

                        /* Store MAC meas results in UE context */
                        if (store_mac_meas_results_in_ue_context(p_rrm_glb_ctxt->p_ue_context,
                                    index,
                                    p_mac_ecid_meas_report_resp)== RRM_SUCCESS)
                        {

                            RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                    "Meas results from MAC have arrived, and MAC has given SUCCESS response\
                                    so storing the results in UE context of all esmlc requests which require MAC");
                            p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].
                                ue_mac_meas_status |= RRM_ECID_MAC_MEAS_RECVD;

                            if((RRM_FALSE == p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].ecid_meas_report_sent) &&
                                    (RRM_SUCCESS == check_if_requested_quantifier_is_received(p_rrm_glb_ctxt->p_ue_context, index)))
                            {
                                /* Send meas report */
                                /* CID 53406 */
                                if(RRM_SUCCESS == rrm_ue_build_and_send_combined_ecid_meas_report(p_rrm_glb_ctxt->p_ue_context, 
                                            p_lppa_ecid_meas_report, 
                                            index))
                                {
                                    RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                                            "Combined meas report sent successfully for e_smlc_ue_meas_id[%d] for [UE:%d]",
                                            p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].e_smlc_ue_meas_id,
                                            p_rrm_glb_ctxt->p_ue_context->ue_index);
                                }
                                else
                                {
                                    RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, 
                                            "Unsuccessfully esmlc report for e_smlc_ue_meas_id[%d] for [UE:%d]", 
                                            p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].e_smlc_ue_meas_id,
                                            ue_index);
                                }
                            }
                            else
                            {
                                RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                                        "Not send esmlc report for e_smlc_ue_meas_id[%d] ue_mac_meas_status =%d for [UE:%d]", 
                                        p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].e_smlc_ue_meas_id,
                                        p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].ue_mac_meas_status,
                                        ue_index);
                            }
                        }
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "MAC results handled for ECID_INDEX =%d for [UE:%d]",
                                index,
                                p_rrm_glb_ctxt->p_ue_context->ue_index);
                    }
                    else
                    {

                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "MAC meas not required ECID_INDEX = [%d]", index);
                    }
                }
            }
            else
            {
                for(index = RRM_ZERO; index < RRM_MAX_ESMLC_MEAS_ID; index++)
                {
                    if( p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].ecid_meas_req_received == RRM_TRUE  &&
                            p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD)
                    {
                        /*  Reset the Bitmask in the UE context , to indicate that 
                         ** MAC response is non success  */
                        RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                                "MAC response is non success  \
                                ue_mac_meas_status =%d for index =%d e_smlc_ue_meas_id=%d",
                                p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].ue_mac_meas_status,index,
                                p_rrm_glb_ctxt->p_ue_context->p_ue_positioing_data[index].e_smlc_ue_meas_id);

                    }
                }
                /* Send Failure indication */
                RRM_TRACE (g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "Meas results from MAC have arrived, and MAC has given non-SUCCESS response");

                ret_val = RRM_FAILURE;
            }
        }
        /* SPR 20652 Fix End */
    }

    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                "Either UE global context or \
                p_mac_ecid_meas_report_resp is NULL");

        ret_val = RRM_FAILURE;
    }

    if(RRM_PNULL != p_mac_ecid_meas_report_resp)
    {
        RRM_MEM_FREE(p_mac_ecid_meas_report_resp);
    }
    /* CID 53406 */
    if(RRM_PNULL != p_lppa_ecid_meas_report)
    {
        RRM_MEM_FREE(p_lppa_ecid_meas_report);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*******************************************************************************
 * Function Name  : rrm_ue_build_and_send_combined_ecid_meas_report
 * Inputs         : p_ue_context
 : p_lppa_ecid_meas_report
 : ecid_meas_req_index
 * Outputs        : NONE
 * Returns        : 
 *                  rrm_return_et(SUCCESS / FAILURE)
 * Description    : This function builds and sends the ECID meas report to ESMLC 
 *                  after combining the results from MAC and UE meas results
 *******************************************************************************/
    rrm_return_et
rrm_ue_build_and_send_combined_ecid_meas_report(
        rrm_ue_context_t                     *p_ue_context,
        s1ap_rrm_lppa_ecid_meas_report_t     *p_lppa_ecid_meas_report,
        U8                                    ecid_meas_req_index
        )
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    U16                    transaction_id = RRM_ZERO;
    rrm_cell_index_t       cell_index = p_ue_context->cell_index;
    U8                     index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    /* Coverity 19oct Delete : 54985 */
    if(RRM_PNULL != p_lppa_ecid_meas_report &&
            RRM_FIFTEEN > ecid_meas_req_index)
    {
        RRM_MEMSET(p_lppa_ecid_meas_report, RRM_ZERO, sizeof(s1ap_rrm_lppa_ecid_meas_report_t));

        p_lppa_ecid_meas_report->ue_index           = p_ue_context->ue_index;
        p_lppa_ecid_meas_report->routing_id         = p_ue_context->p_ue_positioing_data[ecid_meas_req_index].routing_id;
        p_lppa_ecid_meas_report->lppa_trans_id      = p_ue_context->p_ue_positioing_data[ecid_meas_req_index].lppa_trans_id;
        p_lppa_ecid_meas_report->e_smlc_ue_meas_id  = p_ue_context->p_ue_positioing_data[ecid_meas_req_index].e_smlc_ue_meas_id;
        p_lppa_ecid_meas_report->enb_ue_meas_id     = p_ue_context->p_ue_positioing_data[ecid_meas_req_index].enb_ue_meas_id;

        rrm_fill_eutran_access_point(cell_index,
                &(p_lppa_ecid_meas_report->e_cid_meas_result));

        ret_val = rrm_fill_serv_cell_ecid_info(cell_index,
                &(p_lppa_ecid_meas_report->e_cid_meas_result));

        if(RRM_SUCCESS == ret_val)
        {
            for(index=RRM_ZERO; (index<p_ue_context->p_ue_positioing_data[ecid_meas_req_index].num_meas_quantifier) && (ret_val == RRM_SUCCESS); index++)
            {
                switch (p_ue_context->p_ue_positioing_data[ecid_meas_req_index].meas_quantifier[index])
                {
                    case RRM_LPPA_CELL_ID:
                        /* Already done, nothing needs to be done */
                        break;
                    case RRM_LPPA_ANGLEOFARRIVAL:
                        p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |= LPPA_MEASUREMENT_RESULT_PRESENT;
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].value_angle_of_arrival = 
                            p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_mac_data.AoA[0];
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].bitmask |= 
                            LPPA_MEAS_RESULT_VALUE_ANGLE_OF_ARRIVAL_PRESENT;
                        break;
                    case RRM_LPPA_TIMINGADVANCETYPE1:
                        p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |= LPPA_MEASUREMENT_RESULT_PRESENT;
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].value_timing_adv_type_1 = 
                            (p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_mac_data.enb_rxtx_diff_type1) + 
                            (p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_ecid_r9.ue_rxtx_time_diff);
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].bitmask |=
                            LPPA_MEAS_RESULT_VALUE_TIMING_ADV_TYPE_1_PRESENT;
                        break;
                    case RRM_LPPA_TIMINGADVANCETYPE2:
                        p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |= LPPA_MEASUREMENT_RESULT_PRESENT;
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].value_timing_adv_type_2 =
                            p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_mac_data.enb_rxtx_diff_type2;
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index].bitmask |=
                            LPPA_MEAS_RESULT_VALUE_TIMING_ADV_TYPE_2_PRESENT;
                        break;
                    case RRM_LPPA_RSRP:
                        p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |= LPPA_MEASUREMENT_RESULT_PRESENT;
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
                        ret_val = rrm_fill_lppa_rsrp_meas_result_from_mac_resp(cell_index,
                                &(p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index]),
                                p_ue_context, 
                                ecid_meas_req_index
                                );
                        break;
                    case RRM_LPPA_RSRQ:
                        p_lppa_ecid_meas_report->e_cid_meas_result.bitmask |=LPPA_MEASUREMENT_RESULT_PRESENT;
                        p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.num_measured_results++;
                        ret_val = rrm_fill_lppa_rsrq_meas_result_from_mac_resp(cell_index,
                                &(p_lppa_ecid_meas_report->e_cid_meas_result.meas_result.measured_results[index]),
                                p_ue_context,
                                ecid_meas_req_index
                                );
                        break;
                    default:
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                                "Not of any valid meas quantifier");
                        break;
                }
            }
        }
        if(RRM_SUCCESS == ret_val )
        {
            transaction_id = rrm_generate_txn_id();
            if(RRM_SUCCESS == rrm_il_send_s1ap_rrm_lppa_ecid_meas_report(p_lppa_ecid_meas_report,
                        RRM_MODULE_ID,
                        RRC_MODULE_ID,
                        transaction_id,cell_index))
            {
                p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ue_mac_meas_status =
                    p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ue_mac_meas_status & ~(RRM_ECID_UE_MEAS_RECVD);
                p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ue_mac_meas_status =
                    p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ue_mac_meas_status & ~(RRM_ECID_MAC_MEAS_RECVD);
                p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_report_sent=RRM_TRUE;;
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_BRIEF,\
                        "ECID=%d meas report send for [UE:%d]",
                        p_ue_context->p_ue_positioing_data[ecid_meas_req_index].e_smlc_ue_meas_id,
                        p_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,\
                        "Failed to send ECID=%d meas report [UE:%d]",
                        p_ue_context->p_ue_positioing_data[ecid_meas_req_index].e_smlc_ue_meas_id,
                        p_ue_context->ue_index);
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,\
                "Either p_lppa_ecid_meas_report or p_ue_context or ecid_meas_req_index >= 15[%d]",
                ecid_meas_req_index );

        return RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*******************************************************************************
 * Function Name  : rrm_fill_lppa_rsrp_meas_result_from_mac_resp
 * Inputs         : cell_index
 : p_ecid_meas_result
 : p_ue_context
 : ecid_meas_req_index
 * Outputs        : NONE
 * Returns        : 
 *                  rrm_return_et(SUCCESS / FAILURE)
 * Description    : This function fills the RSRP results to be sent in the ECID
 *                  meas report after the quantifier values from MAC have arrived
 *******************************************************************************/
    rrm_return_et
rrm_fill_lppa_rsrp_meas_result_from_mac_resp(
        rrm_cell_index_t                 cell_index,
        lppa_measured_res_t             *p_ecid_meas_result,
        rrm_ue_context_t                *p_ue_context,
        U8                               ecid_meas_req_index
        )
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    rrm_cell_context_t    *p_cell_ctxt = RRM_PNULL;
    U8                     index = RRM_ZERO;
    U8                     intra_cell_index = RRM_ZERO;
    lte_ncl_t             *p_lte_ncl = rrm_cellm_get_lte_ncl_info(cell_index);
    U8                     meas_rsrp_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_ecid_meas_result &&
            RRM_PNULL != p_ue_context &&
            RRM_PNULL != p_lte_ncl) /* Coverity: CID 41508 */
    {
        p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);
        /*CID 65780,65781:start*/
        if (RRM_PNULL != p_cell_ctxt)
        {
            p_ecid_meas_result->bitmask |= LPPA_MEAS_RESULT_RESULT_RSRP_PRESENT;
            /* SPR 8771: neighbour cell count check removed */
            rrm_fill_rsrp_for_serving_cell_from_mac_resp(p_cell_ctxt, p_ecid_meas_result, p_ue_context, ecid_meas_req_index);
            meas_rsrp_count++;
            for(index = RRM_ZERO; index < p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_count; index++)
            {
                for(intra_cell_index =RRM_ZERO; intra_cell_index < p_lte_ncl->num_valid_intra_freq_cell  ;intra_cell_index++)
                {
                    if(p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].pci == 
                            p_lte_ncl->intra_freq_cells[intra_cell_index].phy_cell_id)
                    {
                        p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].pci = 
                            p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].pci;
                        p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].earfcn = 
                            p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
                        p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].value_rsrp = 
                            p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].rsrp;

                        if(p_lte_ncl->intra_freq_cells[intra_cell_index].bitmask & RRMCM_RMIF_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT)
                        {
                            p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].bitmask |= LPPA_RESULT_RSRP_ECGI_PRESENT;
                            rrm_convert_rrm_ecgi_into_rrc_ecgi( p_lte_ncl->intra_freq_cells[intra_cell_index].cell_id,
                                    &(p_ecid_meas_result->meas_result_rsrp.result_rsrp[meas_rsrp_count].ecgi));
                        }
                        p_ecid_meas_result->meas_result_rsrp.rsrp_count++;
                        meas_rsrp_count++;
                        break;
                    }
                }
            }
            if(meas_rsrp_count == RRM_ZERO)
            {
                RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR,
                        "PCI of cells obtained in UE's meas results do not match with any of the cells in the NCL");
                ret_val = RRM_FAILURE;
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_ctxt is null");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        /*CID 65780,65781:start*/
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR,
                "either p_ecid_meas_result or p_ue_context is NULL");

        return RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*******************************************************************************
 * Function Name  : rrm_fill_lppa_rsrq_meas_result_from_mac_resp
 * Inputs         : cell_index
 : p_ecid_meas_result
 : p_ue_context
 : ecid_meas_req_index
 * Outputs        : NONE
 * Returns        : 
 *                  rrm_return_et(SUCCESS / FAILURE)
 * Description    : This function fills the RSRQ results to be sent in the ECID
 *                  meas report after the quantifier values from MAC have arrived
 *******************************************************************************/
    rrm_return_et
rrm_fill_lppa_rsrq_meas_result_from_mac_resp(
        rrm_cell_index_t                 cell_index,
        lppa_measured_res_t             *p_ecid_meas_result,
        rrm_ue_context_t                *p_ue_context,
        U8                               ecid_meas_req_index
        )
{
    rrm_return_et          ret_val = RRM_SUCCESS;
    rrm_cell_context_t    *p_cell_ctxt = RRM_PNULL;
    U8                     index = RRM_ZERO;
    U8                     intra_cell_index = RRM_ZERO;
    lte_ncl_t             *p_lte_ncl = rrm_cellm_get_lte_ncl_info(cell_index);
    U8                     meas_rsrq_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    /* coverity  : CID 41509 */
    if( (RRM_PNULL != p_ecid_meas_result) &&
            (RRM_PNULL != p_ue_context) && 
            (RRM_PNULL != p_lte_ncl)  )
    {
        p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);
        /*CID 65781:start*/
        if (RRM_PNULL != p_cell_ctxt)
        {    
            p_ecid_meas_result->bitmask |= LPPA_MEAS_RESULT_RESULT_RSRQ_PRESENT;
            /* SPR 8771: neighbour cell count check removed */
            rrm_fill_rsrq_for_serving_cell_from_mac_resp(p_cell_ctxt, p_ecid_meas_result, p_ue_context, ecid_meas_req_index);
            meas_rsrq_count++;
            for(index = RRM_ZERO; index < p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_count; index++)
            {
                for(intra_cell_index =RRM_ZERO; intra_cell_index < p_lte_ncl->num_valid_intra_freq_cell;intra_cell_index++)
                {
                    if(p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].pci == 
                            p_lte_ncl->intra_freq_cells[intra_cell_index].phy_cell_id)
                    {
                        p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].pci = 
                            p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].pci;
                        p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].earfcn = 
                            p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
                        p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].value_rsrq = 
                            p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.eutran_neighbor_list[index].rsrq;

                        if(p_lte_ncl->intra_freq_cells[intra_cell_index].bitmask & RRMCM_RMIF_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT)
                        {
                            p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].bitmask |= LPPA_RESULT_RSRP_ECGI_PRESENT;
                            rrm_convert_rrm_ecgi_into_rrc_ecgi( p_lte_ncl->intra_freq_cells[intra_cell_index].cell_id,
                                    &(p_ecid_meas_result->meas_result_rsrq.result_rsrq[meas_rsrq_count].ecgi));
                        }
                        p_ecid_meas_result->meas_result_rsrq.rsrq_count++;
                        meas_rsrq_count++;
                        break;
                    }
                }
            }
            if(meas_rsrq_count == RRM_ZERO)
            {
                RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR,
                        "PCI of cells obtained in UE's meas results do not match with any of the cells in the NCL");
                ret_val = RRM_FAILURE;
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"p_cell_context is null");
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        /*CID 65781:end*/

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off,p_g_rrm_uem_facility_name,RRM_ERROR,
                "either p_ecid_meas_result or p_ue_context is NULL");

        return RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*******************************************************************************
 * Function Name  : rrm_fill_rsrp_for_serving_cell_from_mac_resp
 * Inputs         : p_cell_ctxt
 : p_ecid_meas_result
 : p_ue_context
 : ecid_meas_req_index
 * Outputs        : NONE
 * Returns        : NONE
 * Description    : This function fills the RSRP results for serving cell to be 
 *                  sent in the ECID meas report after the quantifier values from 
 *                  MAC have arrived 
 *******************************************************************************/
    rrm_void_t
rrm_fill_rsrp_for_serving_cell_from_mac_resp(
        rrm_cell_context_t     *p_cell_ctxt, 
        lppa_measured_res_t    *p_ecid_meas_result, 
        rrm_ue_context_t       *p_ue_context,
        U8                      ecid_meas_req_index
        )
{
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_cell_ctxt &&
            RRM_PNULL != p_ecid_meas_result &&
            RRM_PNULL != p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Populating RSRP meas result for the serving cell");
        p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].pci = 
            p_cell_ctxt->ran_info.rf_params.rf_configurations.phy_cell_id;
        p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].earfcn = 
            p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
        p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].value_rsrp = 
            p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_serv_cell.rsrp_result;

        p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].bitmask |= LPPA_RESULT_RSRP_ECGI_PRESENT;
        p_ecid_meas_result->meas_result_rsrp.rsrp_count++;
        rrm_convert_rrm_ecgi_into_rrc_ecgi(p_cell_ctxt->global_cell_id,
                &(p_ecid_meas_result->meas_result_rsrp.result_rsrp[RRM_ZERO].ecgi));
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ecid_meas_result or p_ue_context or p_cell_ctxt is NULL");
    }
    RRM_UT_TRACE_EXIT();
}
/*******************************************************************************
 * Function Name  : rrm_fill_rsrq_for_serving_cell_from_mac_resp
 * Inputs         : p_cell_ctxt
 : p_ecid_meas_result
 : p_ue_context
 : ecid_meas_req_index
 * Outputs        : NONE
 * Returns        : NONE
 * Description    : This function fills the RSRQ results for serving cell to be 
 *                  sent in the ECID meas report after the quantifier values from 
 *                  MAC have arrived 
 *******************************************************************************/
    rrm_void_t
rrm_fill_rsrq_for_serving_cell_from_mac_resp(
        rrm_cell_context_t     *p_cell_ctxt, 
        lppa_measured_res_t    *p_ecid_meas_result, 
        rrm_ue_context_t       *p_ue_context,
        U8                      ecid_meas_req_index
        )
{
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_cell_ctxt &&
            RRM_PNULL != p_ecid_meas_result &&
            RRM_PNULL != p_ue_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                "Populating RSRQ meas result for the serving cell");
        p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].pci = 
            p_cell_ctxt->ran_info.rf_params.rf_configurations.phy_cell_id;
        p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].earfcn = 
            p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
        p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].value_rsrq = 
            p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ecid_meas_ue_data.meas_result_serv_cell.rsrq_result;

        p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].bitmask |= LPPA_RESULT_RSRP_ECGI_PRESENT;
        p_ecid_meas_result->meas_result_rsrq.rsrq_count++;
        rrm_convert_rrm_ecgi_into_rrc_ecgi(p_cell_ctxt->global_cell_id,
                &(p_ecid_meas_result->meas_result_rsrq.result_rsrq[RRM_ZERO].ecgi));
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "p_ecid_meas_result or p_ue_context or p_cell_ctxt is NULL");
    }
    RRM_UT_TRACE_EXIT();
}

/*******************************************************************************
 * Function Name  : update_meas_config_remove_status_for_ue_pos
 * Inputs         : p_rrm_ue_ctx
 : meas_id
 * Outputs        : NONE
 * Returns        : NONE
 * Description    : This function marks the meas_status as RRM_MEAS_CONFIG_TO_DELETE for ECID 
 *******************************************************************************/
    rrm_void_t
update_meas_config_remove_status_for_ue_pos(
        rrm_ue_context_t *p_rrm_ue_ctx,
        U8  meas_id)
{
    RRM_UT_TRACE_ENTER();
    YLNODE *p_node = RRM_PNULL;
    meas_report_info_node_t* p_meas_report_node = RRM_PNULL;
    p_node = ylFirst(&(p_rrm_ue_ctx->meas_report_list));
    while (p_node)
    {
        p_meas_report_node = (meas_report_info_node_t*)p_node;
        if(MEAS_TYPE_ECID == p_meas_report_node->meas_type &&
                meas_id        == p_meas_report_node->meas_id)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "meas config status is set RRM_MEAS_CONFIG_TO_DELETE  for meas_id=%d",meas_id);
            p_meas_report_node->meas_status = RRM_MEAS_CONFIG_TO_DELETE;
        }
        /*Coverity_fix_start_54941*/
        p_node = ylNext(p_node);
        /*Coverity_fix_end_54941*/
    }
    RRM_UT_TRACE_EXIT();

}
/*******************************************************************************
 * Function Name  : rrm_ue_meas_config_remove_for_ecid
 * Inputs         : p_ue_context
 : ecid_meas_req_index
 : remove_all_ecid_ue_meas_config
 * Outputs        : NONE
 * Returns        : 
 *                  rrm_return_et(SUCCESS / FAILURE)
 * Description    : This function sends the meas_config_req for removing the meas_configuration for ECID 
 *******************************************************************************/
    rrm_return_et
rrm_ue_meas_config_remove_for_ecid(
        rrm_ue_context_t    *p_ue_context,
        U8                   ecid_meas_req_index,
        rrm_bool_et          remove_all_ecid_ue_meas_config
        )
{
    rrm_return_et                   ret_val = RRM_SUCCESS;
    rrc_rrm_meas_config_req_t      *p_rrc_rrm_meas_config_req = RRM_PNULL;
    U16                             transaction_id = RRM_ZERO;
    U8                              index = RRM_ZERO;
    rrm_bool_et                     UE_MEAS_CONFIG_REMOVE_FLAG = RRM_FALSE;
    U8                              remove_count=RRM_ZERO;
    /*SPR_8004:fix_start */
    U8                              meas_index = RRM_ZERO;
    U8                              meas_id_index = RRM_ZERO;
    /*SPR_8004:fix_end */

    RRM_UT_TRACE_ENTER();

    if((RRM_PNULL != p_ue_context) &&
            (ecid_meas_req_index < RRM_MAX_ESMLC_MEAS_ID))
    {
        p_rrc_rrm_meas_config_req = (rrc_rrm_meas_config_req_t*) 
            rrm_mem_get(sizeof(rrc_rrm_meas_config_req_t));

        if(RRM_PNULL == p_rrc_rrm_meas_config_req)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "Memory allocation failure");
            return RRM_FAILURE;
        }
        transaction_id = rrm_generate_txn_id();
        p_rrc_rrm_meas_config_req->ue_index = p_ue_context->ue_index;

        if(RRM_FALSE == remove_all_ecid_ue_meas_config)
        {
            /*SPR_8004:fix_start */
            for(meas_index = RRM_ZERO; meas_index < MAX_ALLOCATED_ID_FOR_ECID; meas_index ++)
            {
                update_meas_config_remove_status_for_ue_pos
                    ( p_ue_context,
                      p_ue_context->p_ue_positioing_data[ecid_meas_req_index].meas_id_and_meas_obj_id[meas_index].\
                      meas_id
                    );

                p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.\
                    report_config_id[RRM_ZERO]= p_ue_context->p_ue_positioing_data[ecid_meas_req_index].\
                    meas_id_and_meas_obj_id [meas_index].report_config_id;           
                p_rrc_rrm_meas_config_req->meas_config.meas_id_to_remove_list.meas_id[meas_id_index]= \
                                                                                                      p_ue_context->p_ue_positioing_data[ecid_meas_req_index].\
                                                                                                      meas_id_and_meas_obj_id[meas_index].meas_id; 

            }
            /*SPR_8004:fix_end */
            p_ue_context->p_ue_positioing_data[ecid_meas_req_index].ue_meas_send_for_rem = RRM_TRUE;
            p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count= RRM_ONE;
            p_rrc_rrm_meas_config_req->meas_config.meas_id_to_remove_list.count=RRM_ONE;
            p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;
            p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT;
            UE_MEAS_CONFIG_REMOVE_FLAG = RRM_TRUE;
        }
        else
        {
            for (index = RRM_ZERO; index < RRM_MAX_ESMLC_MEAS_ID; index++)
            {
                if((RRM_TRUE ==p_ue_context->p_ue_positioing_data[index].ecid_meas_req_received) &&
                        (p_ue_context->p_ue_positioing_data[index].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD))
                {
                    /*SPR_8004:fix_start*/
                    for(meas_index = RRM_ZERO; meas_index < MAX_ALLOCATED_ID_FOR_ECID ; meas_index ++)
                    {

                        update_meas_config_remove_status_for_ue_pos
                            ( p_ue_context,
                              p_ue_context->p_ue_positioing_data[ecid_meas_req_index].meas_id_and_meas_obj_id[meas_index].\
                              meas_id
                            );
                        p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.\
                            report_config_id[remove_count]= 
                            p_ue_context->p_ue_positioing_data[RRM_ZERO].meas_id_and_meas_obj_id[meas_index].report_config_id;
                        p_rrc_rrm_meas_config_req->meas_config.meas_id_to_remove_list.meas_id[remove_count]= \
                                                                                                             p_ue_context->p_ue_positioing_data[index].meas_id_and_meas_obj_id[meas_index].meas_id;
                    }                                         
                    p_ue_context->p_ue_positioing_data[index].ue_meas_send_for_rem = RRM_TRUE;
                    p_rrc_rrm_meas_config_req->meas_config.report_config_to_remove_list.count++;
                    p_rrc_rrm_meas_config_req->meas_config.meas_id_to_remove_list.count++;
                    remove_count++;
                    p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT;
                    p_rrc_rrm_meas_config_req->meas_config.bitmask |= UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT;
                    UE_MEAS_CONFIG_REMOVE_FLAG = RRM_TRUE;
                }
            }
        }

        if(RRM_TRUE == UE_MEAS_CONFIG_REMOVE_FLAG)
        {
            ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_rrc_rrm_meas_config_req,
                    RRM_MODULE_ID, RRC_MODULE_ID,transaction_id,p_ue_context->cell_index);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, "UE_INDEX[%d], UE_MEAS_CONFIG_REMOVE_FLAG\
                    is FALSE, so not sending the meas_config_req to RRC for release for ESMLC[%d]" ,p_ue_context->ue_index,ecid_meas_req_index);
        }

        if(ret_val == RRM_FAILURE)
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,"[UE:%d],Failed to send Meas" 
                " Config Req for release for ESMLC[%d]" ,p_ue_context->ue_index,ecid_meas_req_index);
        }
        RRM_MEM_FREE(p_rrc_rrm_meas_config_req);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "either  p_ue_context is NULL or ecid_meas_req_index=%d is out of range [0-14]", ecid_meas_req_index);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*******************************************************************************
 * Function Name  : store_mac_meas_results_in_ue_context
 * Inputs         : p_ue_context
 : ecid_meas_index
 : p_mac_ecid_meas_report_resp
 * Outputs        : NONE
 * Returns        : 
 *                  rrm_return_et(SUCCESS / FAILURE)
 * Description    : This function stores the meas results obtained from MAC in ue_context
 *******************************************************************************/
    rrm_return_et
store_mac_meas_results_in_ue_context(
        rrm_ue_context_t                  *p_ue_context,
        U8                                 ecid_meas_index,
        MacRrmEcidMeasurementResp   *p_mac_ecid_meas_report_resp
        )
{
    rrm_ue_index_t    ue_index = p_ue_context->ue_index;
    U8                counter = RRM_ZERO;
    rrm_bool_et       aoa_required=RRM_FALSE;
    rrm_bool_et       ta1_required=RRM_FALSE;
    rrm_bool_et       ta2_required=RRM_FALSE;
    rrm_bool_et       aoa_rec=RRM_FALSE;
    rrm_bool_et       ta1_rec=RRM_FALSE;
    rrm_bool_et       ta2_rec=RRM_FALSE;
    rrm_return_et     ret_val= RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    /* Data structure in UE context, initialised to NULL */

    p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.sfn_for_enb_rxtx_diff_type1 = RRM_ZERO;
    p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.enb_rxtx_diff_type1 = RRM_ZERO;
    p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.sfn_for_enb_rxtx_diff_type2 = RRM_ZERO;
    p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.enb_rxtx_diff_type2 = RRM_ZERO;
    p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.sfn_for_AoA = RRM_ZERO;
    for(counter = RRM_ZERO; counter<MAX_NUM_ANTENNA; counter++)
    {
        p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.AoA[counter] = RRM_ZERO;
    }

    if (p_ue_context->p_ue_positioing_data[ecid_meas_index].ta1_ta2_aoa_req  & RRM_ECID_MAC_AOA_REQD)
    {
        aoa_required=RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                "[UE:%d], AOA is required for e_smlc_ue_meas_id = [%d]", 
                ue_index, p_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id);
    }
    if (p_ue_context->p_ue_positioing_data[ecid_meas_index].ta1_ta2_aoa_req  & RRM_ECID_MAC_TA1_REQD)
    {
        ta1_required = RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                "[UE:%d], TA1 is required for e_smlc_ue_meas_id=%d", 
                ue_index, p_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id);
    }
    if (p_ue_context->p_ue_positioing_data[ecid_meas_index].ta1_ta2_aoa_req  & RRM_ECID_MAC_TA2_REQD )
    {
        ta2_required = RRM_TRUE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                "[UE:%d], TA2 is required for e_smlc_ue_meas_id = [%d]", 
                ue_index, p_ue_context->p_ue_positioing_data[ecid_meas_index].e_smlc_ue_meas_id);
    }

    if(ta1_required == RRM_TRUE )
    {
        if(p_mac_ecid_meas_report_resp->bitmask & RRM_MAC_TYPE1_ENB_RXTX_REPORT_PRESENT)
        {
            ta1_rec = RRM_TRUE;
            p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.sfn_for_enb_rxtx_diff_type1 = 
                p_mac_ecid_meas_report_resp->type1EnbRxTxReport.systemFrameNum;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                    "[UE:%d], SFN for eNodeB RxTx Type1 is [%d]", 
                    ue_index, p_mac_ecid_meas_report_resp->type1EnbRxTxReport.systemFrameNum);

            p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.enb_rxtx_diff_type1 = 
                p_mac_ecid_meas_report_resp->type1EnbRxTxReport.type1EnbRxTxDiffValue;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                    "[UE:%d], eNodeB RxTx Diff value for Type1 is [%d]", 
                    ue_index, p_mac_ecid_meas_report_resp->type1EnbRxTxReport.type1EnbRxTxDiffValue);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                    "[UE:%d], TA1 not received [%d]", 
                    ue_index, p_mac_ecid_meas_report_resp->bitmask);

        }
    }

    if    (ta2_required == RRM_TRUE )
    {
        if(p_mac_ecid_meas_report_resp->bitmask & RRM_MAC_TYPE2_ENB_RXTX_REPORT_PRESENT)
        {
            ta2_rec = RRM_TRUE;
            p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.sfn_for_enb_rxtx_diff_type2 = 
                p_mac_ecid_meas_report_resp->type2EnbRxTxReport.systemFrameNum;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                    "[UE:%d], SFN for eNodeB RxTx Type2 is [%d]", 
                    ue_index, p_mac_ecid_meas_report_resp->type2EnbRxTxReport.systemFrameNum);

            p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.enb_rxtx_diff_type2 = 
                p_mac_ecid_meas_report_resp->type2EnbRxTxReport.type2EnbRxTxDiffValue;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                    "[UE:%d], eNodeB RxTx Diff value for Type2 is [%d]", 
                    ue_index, p_mac_ecid_meas_report_resp->type2EnbRxTxReport.type2EnbRxTxDiffValue);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                    "[UE:%d], TA2 not received [%d]", 
                    ue_index, p_mac_ecid_meas_report_resp->bitmask);
        }
    }
    if(aoa_required == RRM_TRUE && p_mac_ecid_meas_report_resp->bitmask & RRM_MAC_AOA_REPORT_PRESENT)
    {
        aoa_rec = RRM_TRUE;
        p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.sfn_for_AoA = 
            p_mac_ecid_meas_report_resp->angleOfArrivalReport.systemFrameNum;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                "[UE:%d], SFN for AoA is [%d]", 
                ue_index, p_mac_ecid_meas_report_resp->angleOfArrivalReport.systemFrameNum);

        for(counter = RRM_ZERO; counter < MAX_NUM_ANTENNA; counter++)
        {
            p_ue_context->p_ue_positioing_data[ecid_meas_index].ecid_meas_mac_data.AoA[counter] = 
                p_mac_ecid_meas_report_resp->angleOfArrivalReport.angleOfArrivalValue[counter];
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO, \
                    "[UE:%d], AoA value for Antenna[%d] is [%d]", 
                    ue_index, counter, p_mac_ecid_meas_report_resp->angleOfArrivalReport.angleOfArrivalValue[counter]);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                "[UE:%d], AOA not received [%d]", 
                ue_index, p_mac_ecid_meas_report_resp->bitmask);
    }
    if(( aoa_required == RRM_TRUE && aoa_rec == RRM_FALSE) ||
            ( ta1_required == RRM_TRUE && ta1_rec == RRM_FALSE) ||
            ( ta2_required == RRM_TRUE && ta2_rec == RRM_FALSE))
    {
       ret_val=RRM_FAILURE;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, \
                    "[UE:%d], failure to fill mac ecid report bimask [%d]", 
                    ue_index, p_mac_ecid_meas_report_resp->bitmask);
    }
    else
    {
        ret_val=RRM_SUCCESS;
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED, \
                    "[UE:%d], successfully  fill mac ecid report bimask [%d]", 
                    ue_index, p_mac_ecid_meas_report_resp->bitmask);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/***********************************************************************************
 * Function Name  : check_if_requested_quantifier_is_received
 * Inputs         : p_ue_cntxt
 : esmlc_meas_id
 * Outputs        : NONE
 * Returns        :           
 *                  rrm_return_et(SUCCESS / FAILURE)
 * Description    : This function returns SUCCESS or FAILURE on the basis of whether 
 the requested meas data has been received from UE or MAC or not
 ************************************************************************************/
    rrm_return_et
check_if_requested_quantifier_is_received(
        rrm_ue_context_t          *p_ue_cntxt,
        U8                         esmlc_meas_id
        )
{
    rrm_return_et        ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
            "ue_mac_meas_status =%d for esmlc_meas_id =%d, for [UE:%d]",
            p_ue_cntxt->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status,esmlc_meas_id,
            p_ue_cntxt->ue_index);

    if(p_ue_cntxt->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD && 
            p_ue_cntxt->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD)
    {
        if(p_ue_cntxt->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_UE_MEAS_RECVD &&
                p_ue_cntxt->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_MAC_MEAS_RECVD)
        {
            RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                    "Both MAC and UE meas were required and both of"
                    " them have been received for esmlc_meas_index[%d] for [UE:%d]", 
                    esmlc_meas_id, p_ue_cntxt->ue_index);

            ret_val = RRM_SUCCESS;
        }
        else
        {
            RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, 
                    "Both MAC and UE meas were required and any one of them or both of "
                    "them have not been received yet for esmlc_meas_index[%d] for [UE:%d]", 
                    esmlc_meas_id, p_ue_cntxt->ue_index);

            ret_val = RRM_FAILURE;
        }
    }
    else if(p_ue_cntxt->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_UE_MEAS_REQD)
    {
        if(p_ue_cntxt->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_UE_MEAS_RECVD)
        {
            RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                    "Only UE meas was required and it has been received for esmlc_meas_index[%d] for [UE:%d]", 
                    esmlc_meas_id, p_ue_cntxt->ue_index);

            ret_val = RRM_SUCCESS;
        }
        else
        {
            RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, 
                    "Only UE meas was required and it has not been"
                    " received yet for esmlc_meas_index[%d] for [UE:%d]", 
                    esmlc_meas_id, p_ue_cntxt->ue_index);

            ret_val = RRM_FAILURE;
        }
    }
    else if(p_ue_cntxt->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_MAC_MEAS_REQD)
    {
        if(p_ue_cntxt->p_ue_positioing_data[esmlc_meas_id].ue_mac_meas_status & RRM_ECID_MAC_MEAS_RECVD)
        {
            RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED, 
                    "Only MAC meas was required and it has been" 
                    " received for esmlc_meas_index[%d] for [UE:%d]", 
                    esmlc_meas_id, p_ue_cntxt->ue_index);

            ret_val = RRM_SUCCESS;
        }
        else
        {
            RRM_TRACE (g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, 
                    "Only MAC meas was required and it has not been" 
                    " received yet for esmlc_meas_index[%d] for [UE:%d]", 
                    esmlc_meas_id, p_ue_cntxt->ue_index);

            ret_val = RRM_FAILURE;
        }
    }
    else /* case of CELL_ID */
    {
        ret_val = RRM_SUCCESS; 
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR 16406 8SEP start */
/***********************************************************************************
 * Function Name  : rrm_is_set_fgi_bit
 * Inputs         : p_ue_cntxt, bit
 * Outputs        : None
 * Returns        : TRUE/FALSE
 * Description    : This function returns TRUE if a fgi bit is set, returns FALSE
 *                  otherwise
 ************************************************************************************/
rrm_bool_et
rrm_is_set_fgi_bit(
        rrm_ue_context_t  *p_ue_context,
        U32               bit
        )
{
    U32      feature_group_indicators = RRM_ZERO;
    /* SPR 18466 Fix Start */
    U32      feature_group_indicators_r10 = RRM_ZERO;
    /* SPR 18466 Fix End */
    U32      mask = RRM_ONE;

    RRM_UT_TRACE_ENTER();

    if(p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
    {
        /*SPR 18466 fix start*/
        if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.bitmask &
                    RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT) &&
                (((bit >= RRM_ONE) && (bit <= RRM_THIRTY_TWO)) || 
                 ((bit >= RRM_HUNDRED_ONE) && (bit <= RRM_HUNDRED_THIRTY)))
                /*SPR 18466 fix end*/
          )
        {
            feature_group_indicators = p_ue_context->ue_capability_params.
                rrm_eutra_radio_capability_info.
                eutra_radio_capability_info_def.feature_group_indicators;
            /* SPR 18466 Fix Start */
            if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask &
                        RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)
                    &&
                    (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                     ue_eutra_capability_v920_ies.bitmask &
                     RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT)
                    &&
                    (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                     ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask &
                     RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT)
                    &&

                    (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                     ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask & 
                     RRM_UE_EUTRA_CAPABILITY_V1020_FEATUREGROUP_IND_R10_PRESENT))
            {
                if((bit >= RRM_HUNDRED_ONE) && (bit <= RRM_HUNDRED_THIRTY))
                {
                    feature_group_indicators_r10 = p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.featuregroup_ind_r10;
                    mask = mask << (RRM_THIRTY_TWO - (bit - RRM_HUNDRED));
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "feature_group_indicators is %d and mask is %d", feature_group_indicators_r10, mask);
                    if(feature_group_indicators_r10 & mask)
                    {

                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "FGI_BIT %d is ON", bit);
                        return RRM_TRUE;
                    }

                }
                else if((bit >= RRM_ONE) && (bit <= RRM_THIRTY_TWO))
                {
                    mask = mask << (RRM_THIRTY_TWO - bit);
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "feature_group_indicators is %d and mask is %d", feature_group_indicators, mask);
                    if(feature_group_indicators & mask)
                    {

                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                                "FGI_BIT %d is ON", bit);
                        return RRM_TRUE;
                    }
                }

            }
            else if((bit >= RRM_ONE) && (bit <= RRM_THIRTY_TWO))
            {
                mask = mask << (RRM_THIRTY_TWO - bit);
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                        "feature_group_indicators is %d and mask is %d", feature_group_indicators, mask);
                if(feature_group_indicators & mask)
                {

                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "FGI_BIT %d is ON", bit);
                    return RRM_TRUE;
                }
            }
            /* SPR 18466 Fix End */
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                    "RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT bitmask is not ON for Bit[%d]", bit);
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT bitmask is not ON");
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF, "FGI_BIT %d is OFF", bit);
    RRM_UT_TRACE_EXIT();
    return RRM_FALSE;
}

/* SPR 16406 8SEP end */

/*SPR-695 Fix Starts*/
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_handle_low_priority_ue_del_req
 *   Inputs         : p_rrm_glb_ctxt, p_api
 *   Outputs        : None
 *   DESCRIPTION:
 *       This function determines the UE which will be released on the basis of 
 *       the load set up by the OAM.
 *   RETURNS: rrm_return_et
 ******************************************************************************/
rrm_return_et 
    rrm_uem_handle_low_priority_ue_del_req
(
 rrm_ue_global_context_t     *p_rrm_glb_ctxt,
 rrm_void_t *p_api /*Input Api buffer*/
 )
{
    rrm_return_et                  ret_val = RRM_FAILURE;
    rrmuem_cm_ue_rel_ind_t *p_ue_rel_req = RRM_PNULL;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    rrm_ue_context_t *p_ue_context = RRM_PNULL; 
    rrm_ue_index_t ue_index;
    U8 num_of_ue = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_ue_rel_req = (rrmuem_cm_ue_rel_ind_t*)p_api;
    RRM_ASSERT(RRM_PNULL != p_ue_rel_req);

    SET_CELL_INDEX(p_ue_rel_req->cell_index);
    
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,"CellM->RRMUEM_CM_DELETE_LOW_PRIORITY_UE_REQ->UEM");
    for (num_of_ue = RRM_ZERO; num_of_ue<p_ue_rel_req->count; num_of_ue++)
    {
/*spr_22158_changes_start*/
        if (RRM_SUCCESS != (ret_val = rrm_ue_get_low_priority_ue(p_ue_rel_req->cell_index, &ue_index, RRM_ZERO,RRM_ZERO, RRM_FALSE)))
/*spr_22158_changes_end*/
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                    "Lowest priority UE not found!!!");
            return ret_val;
        }

        /** Find the UE context */
        /* SPR 20652 Fix Start */
        p_ue_context = rrm_ue_find_context(ue_index,
                p_ue_rel_req->cell_index);
        if (RRM_PNULL != p_ue_context)
        {
            /* SPR 20652 Fix End */
            p_rrm_glb_ctxt->p_ue_context = p_ue_context;
            p_ue_context->ue_event = RRM_RELEASE_LOW_PRIORITY_UE_REL_EVENT;
            /* SPR 15441 start */
            p_ue_context->current_procedure.p_proc_data = RRM_PNULL;
            /* SPR 15441 end */

            if ((RRM_UE_MAX_STATE > p_ue_context->ue_state) &&
                    (RRM_UE_MAX_EVENT > p_ue_context->ue_event))
            {
                /* SPR 15441 start */
                ret_val = rrm_uem_process_fsm( p_ue_context->ue_state, 
                        p_ue_context->ue_event,
                        p_rrm_glb_ctxt);
                /* SPR 15441 end */
            }
            else
            {
                /* SPR 15441 start */
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name,
                        RRM_ERROR, "Invalid UE state[%d] or UE event[%d] for [UE:%d]", 
                        ue_index,
                        p_ue_context->ue_state, p_ue_context->ue_event);
                /* SPR 15441 end */
                ret_val = RRM_FAILURE;
            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name,
                    RRM_ERROR, "[UE:%d], failed to find ue context",
                    ue_index);
            ret_val = RRM_FAILURE;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*spr_22158_changes_start*/
/*code deleted*/
/*spr_22158_changes_end*/
/*SPR-695 Fix Ends*/
/* CSR-00058598 and SPR-837-fix start*/
/*******************************************************************************
 *   FUNCTION NAME: rrm_check_ue_arp_val_for_emergency_ho_admin
 *   DESCRIPTION:
 *       This function is used for checking the requested erab ARP value with OAM
 *       configured ARP value, is matched or not.
 *   RETURNS:
 *       RRM_TRUE  on MATCHED
 *       RRM_FALSE on UN-MATCHED
 ******************************************************************************/
rrm_return_et
    rrm_check_ue_arp_val_for_emergency_ho_admin
(
 rrm_ue_context_t    *p_rrm_ue_context
 )
{
    U8 rrm_emergency_erab_arp   = RRM_ZERO;
    rrm_return_et  ret_val      = RRM_FAILURE;
    U32  index                  = RRM_ZERO;
    rrm_ue_erab_setup_item_list_t *p_erab_setup_item_list    = RRM_PNULL;
    rrm_ue_proc_ho_adm_data_t     *p_rrm_ue_proc_ho_adm_data = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_context != RRM_PNULL)
    {
        p_rrm_ue_proc_ho_adm_data = (rrm_ue_proc_ho_adm_data_t *) p_rrm_ue_context->current_procedure.p_proc_data;

        rrm_emergency_erab_arp = (U8) (p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rrm_ue_context->cell_index]->epc_info.epc_params.emergency_erab_arp);

        p_erab_setup_item_list = &p_rrm_ue_proc_ho_adm_data->erab_setup_list;;

        /* SPR 17564 Fix Start */
        for(index = RRM_ZERO; index < p_erab_setup_item_list->num_of_list;
                /* SPR 17564 Fix End */
                index++)
        {
            if (rrm_emergency_erab_arp == p_erab_setup_item_list->erab_item[index].erab_level_qos_params.alloc_and_reten_prior.priority_level)
            {
                ret_val = RRM_SUCCESS;
                break;
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "UE context is NULL ");
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/*SPR 21687 Start*/
/*******************************************************************************
 *   FUNCTION NAME:is_ue_restricted_for_given_rat 
 *   DESCRIPTION:
 *       This function is used for checking the is the UE restricted for the
 *   RETURNS:
 *       RRM_TRUE  on restricted
 *       RRM_FALSE on not restricted
 ******************************************************************************/
rrm_bool_et
    is_ue_restricted_for_given_rat
(
 rrm_ue_context_t    *p_rrm_ue_context,
 rrm_rat_type_et     rat_type
 )
{
    RRM_UT_TRACE_ENTER();
    if(RRM_UTRAN_CELL == rat_type)
    {
        if( (p_rrm_ue_context->ho_restriction_list.bitmask & HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT ) &&
                ( (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_ALL) ||
                  (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_UTRAN_TYPE) ||
                  (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_GERAN_AND_UTRAN) ||
                  (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_CDMA2000_AND_UTRAN) )
          )
        {
            if(rrm_is_ue_special_previledge(p_rrm_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                        "[UE:%u] is special privilidge so continuing with HO on inter RAT[UTRAN]",p_rrm_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                        "UTRA is restricted for [UE:%d]", p_rrm_ue_context->ue_index);
                return RRM_TRUE;
            }
        }
    }
    else if(RRM_GERAN_CELL == rat_type)
    {
        if( (p_rrm_ue_context->ho_restriction_list.bitmask & HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT ) &&
                ( (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_ALL) ||
                  (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_GEREN_TYPE) ||
                  (p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat == FORBIDDEN_INTER_RAT_GERAN_AND_UTRAN)
                )
          )
        {
            if(rrm_is_ue_special_previledge(p_rrm_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                        "[UE:%u] is special privilidge so continuing with HO on inter RAT[GERAN]",p_rrm_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                        "[UE:%u], GERAN is forbidden",
                        p_rrm_ue_context->ue_index);
                return RRM_TRUE;
            }
        }
    }
    else if(RRM_CDMA_CELL == rat_type)
    {
        if((p_rrm_ue_context->ho_restriction_list.bitmask & HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT)
                && (FORBIDDEN_INTER_RAT_ALL == p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat ||
                    FORBIDDEN_INTER_RAT_CDMA2000_TYPE == p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat ||
                    FORBIDDEN_INTER_RAT_CDMA2000_AND_UTRAN == p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat))
        {
            if(rrm_is_ue_special_previledge(p_rrm_ue_context))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                        "[UE:%u] is special priviledge so ignoring the forbidden list and" 
                        "continuing with HO on inter RAT[CDMA2000]",p_rrm_ue_context->ue_index);
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                        "[UE:%u], CDMA2000 is forbidden. forbidden value[%u]",
                        p_rrm_ue_context->ue_index, p_rrm_ue_context->ho_restriction_list.forbidden_inter_rat);
                return RRM_TRUE;
            }
        }

    }
    return RRM_FALSE;
}
/*SPR 21687 End*/
/* SPR 17564 Fix Start */
/*******************************************************************************
 *   FUNCTION NAME: rrm_is_ue_special_previledge
 *   DESCRIPTION:
 *       This function is used for checking the requested erab ARP value with OAM
 *       configured ARP value during eRAB setup, is matched or not.
 *   RETURNS:
 *       RRM_TRUE  on MATCHED
 *       RRM_FALSE on UN-MATCHED
 ******************************************************************************/
rrm_bool_et
    rrm_is_ue_special_previledge
(
 rrm_ue_context_t    *p_rrm_ue_context
 )
{
    U8 rrm_emergency_erab_arp   = RRM_ZERO;
    rrm_bool_et  ret_val        = RRM_FALSE;
    U32  index                  = RRM_ZERO;
    rrm_ue_erab_setup_item_list_t *p_erab_setup_item_list    = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_context != RRM_PNULL)
    {
        if (RRM_UE_ESTAB_CAUSE_EMERGENCY == p_rrm_ue_context->establishment_cause ||
                RRM_UE_ESTAB_CAUSE_HIGHPRIORITY_ACCESS == p_rrm_ue_context->establishment_cause)
        {
            ret_val = RRM_TRUE;
        }
        else
        {
            rrm_emergency_erab_arp = (U8) ( p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rrm_ue_context->cell_index]->epc_info.epc_params.emergency_erab_arp);

            p_erab_setup_item_list = &p_rrm_ue_context->drb_configured;

            for(index = RRM_ZERO; index < p_erab_setup_item_list->num_of_list; index++)
            {
                if (rrm_emergency_erab_arp == p_erab_setup_item_list->erab_item[index].erab_level_qos_params.alloc_and_reten_prior.priority_level)
                {
                    ret_val = RRM_TRUE;
                    break;
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "UE context is NULL ");
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/* SPR 17564 Fix End */

/****************************************************************************
 * Function Name  : rrm_ue_emergency_establishment_operation_for_ho
 * Inputs         : trans_id, cell_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Process the UE's Emergency establishment opeation for HO-admin.
 ****************************************************************************/
    rrm_return_et
rrm_ue_emergency_establishment_operation_for_ho (
        U16               trans_id,
        rrm_cell_index_t   cell_index
        )
{

    rrm_return_et         ret_val = RRM_FAILURE;
    rrm_ue_index_t        ue_index = RRM_ZERO;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    access_mgmt_params_t  *p_access_mgmt_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();


    p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(cell_index);

    if ((RRM_PNULL != p_access_mgmt_params) && 
            (RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT & p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->bitmask))
    {
        if ((p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_HYBRID))
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Request is for Hybird cell");
            ret_val = RRM_SUCCESS;
        }

        else if ((p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_CLOSE) ||
                (p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_OPEN)  ||
                (p_access_mgmt_params->access_mode == RRM_OAM_ACCESS_MODE_OPEN_FEMTO))
        {
/*spr_22158_changes_start*/
            if (RRM_SUCCESS ==  rrm_ue_get_low_priority_ue(cell_index, &ue_index,RRM_ZERO,RRM_ZERO,RRM_FALSE))
/*spr_22158_changes_end*/
            {
                if (RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
                            ue_index,
                            RADIO_NETWORK_LAYER_TYPE,
                            REDUCE_LOAD_IN_SERVING_CELL,
                            trans_id,
                            RRM_PNULL,
                            /* SPR_10729_fix */
                            cell_index))
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "send release connection ind send for [UE:%d]",ue_index);
                    ret_val = RRM_SUCCESS;
                    /* SPR 20652 Fix Start */
                    p_ue_context = rrm_ue_find_context(ue_index,
                            cell_index);
                    if (RRM_PNULL == p_ue_context)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "[UE:%d]CELL_INDEX[%d]"
                                ", failed to find ue context",ue_index,cell_index);
                        ret_val = RRM_FAILURE;
                    }
                    else
                    {
                        if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                        {
                            /* SPR 20652 Fix End */
                            RRM_TRACE(g_uem_log_on_off,
                                    p_g_rrm_uem_facility_name,
                                    RRM_DETAILED,
                                    "ue_connection_release_ind sent, \
                                    Failed to clean up ue resources");
                            ret_val = RRM_FAILURE;

                        }
                        else
                        {
                            RRM_TRACE(g_uem_log_on_off,
                                    p_g_rrm_uem_facility_name,
                                    RRM_DETAILED,
                                    "successfully cleaned up resources for the [UE:%d]",
                                    ue_index);
                        }
                    }
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                            "Failed to send release connection ind send for [UE:%d]",
                            ue_index);
                    ret_val = RRM_FAILURE;

                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                        "Unable to find any lower priority UE than UE index");
                ret_val = RRM_FAILURE;
            }
        }
        else
        {

            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "access mode->cell_type is not found");
            ret_val = RRM_FAILURE;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Access mode information is NULL ");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_handle_max_mem_in_hybrid_for_emergency_ho
 * Inputs         : trans_id,cell_index,UE context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : this function handles csg/non-csg membership for ho when
 *                  request is for emergency UE.
 ****************************************************************************/
    rrm_return_et
rrm_handle_max_mem_in_hybrid_for_emergency_ho(
        U16               trans_id,
        rrm_cell_index_t   cell_index,
        rrm_ue_context_t *p_rrm_ue_context
        )
{
    rrm_return_et         ret_val = RRM_FAILURE;
    rrm_ue_index_t        ue_index = RRM_ZERO;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    rrm_ue_context_t *p_ue_context = RRM_PNULL;
    /* SPR 20652 Fix End */
    access_mgmt_params_t  *p_access_mgmt_params = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_access_mgmt_params = rrm_cellm_get_access_mgmt_params(cell_index);

    if ((RRM_PNULL !=p_rrm_ue_context) && (RRM_PNULL != p_access_mgmt_params))
    {
        if ((p_access_mgmt_params->max_csg_members != RRM_INDEX_ERR))
        {
            if (p_rrm_ue_context->rrm_csg_membership.rrm_csg_membership_status == RRM_MEMBER)
            {
                ret_val = rrm_get_low_priority_csg_ue(&ue_index,p_rrm_ue_context->ue_index);
            }
            else
            {
                ret_val = rrm_get_low_priority_non_csg_ue(&ue_index,p_rrm_ue_context->ue_index);
            }
        }
        else
        {
/*spr_22158_changes_start*/
            ret_val = rrm_ue_get_low_priority_ue(cell_index, &ue_index,RRM_ZERO,RRM_ZERO,RRM_FALSE);
/*spr_22158_changes_end*/
            p_rrm_ue_context->rrm_ue_in_hold = RRM_FALSE;
        }

        if (RRM_SUCCESS ==  ret_val)
        {
            if (RRM_SUCCESS == rrm_build_and_send_ue_connection_release_ind(
                        ue_index,
                        RADIO_NETWORK_LAYER_TYPE,
                        REDUCE_LOAD_IN_SERVING_CELL,
                        trans_id,
                        RRM_PNULL,
                        /* SPR_10729_fix */
                        cell_index))
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                        "send release connection ind send for [UE:%d]",ue_index);
                ret_val = RRM_SUCCESS;
                /* SPR 20652 Fix Start */
                p_ue_context = rrm_ue_find_context(ue_index,
                        cell_index);
                if (RRM_PNULL == p_ue_context)
                {
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR, "[UE:%d]CELL_INDEX[%d]"
                            ", failed to find ue context",ue_index,cell_index);
                    ret_val = RRM_FAILURE;
                }
                else
                {
                    if(RRM_FAILURE == rrm_ue_resource_clean_up(p_ue_context))
                    {
                        /* SPR 20652 Fix End */
                        RRM_TRACE(g_uem_log_on_off,
                                p_g_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "ue_connection_release_ind sent, \
                                Failed to clean up ue resources");
                        ret_val = RRM_FAILURE;

                    }
                    else
                    {
                        RRM_TRACE(g_uem_log_on_off,
                                p_g_rrm_uem_facility_name,
                                RRM_DETAILED,
                                "successfully cleaned up resources for the [UE:%d]",
                                ue_index);
                    }
                }
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                        "Failed to send release connection ind send for [UE:%d]",
                        ue_index);
                ret_val = RRM_FAILURE;

            }
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "Unable to find any lower priority UE than UE index");
            ret_val = RRM_FAILURE;

        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "UE context or access mode information is NULL ");
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* CSR-00058598 and SPR-837-fix end */
/*CA Stage3 start*/
/******************************************************************************
 *  FUNCTION NAME: rrm_scell_check_add_meas_config_req 
 *  INPUT        : p_rrm_ue_ctx
 *  DESCRIPTION  : Fills the A1/A2 for scell, meas object configuration in meas config list with values 
 *                 received from OAM that to be sent to RRC.
 *  RETURNS      : RRM_SUCCESS/RRM_FAILURE
 ******************************************************************************/
    rrm_return_et
rrm_scell_check_add_meas_config_req(rrm_ue_context_t *p_ue_context)
{
    U8 count = RRM_ZERO;
    U8 index = RRM_ZERO;
    /*Coverity 63910 Fix Start */ 
    rrc_rrm_meas_config_req_t *p_meas_config_req = RRM_PNULL;
    p_meas_config_req = (rrc_rrm_meas_config_req_t *)rrm_mem_get(
            sizeof(rrc_rrm_meas_config_req_t));
    if ( p_meas_config_req== RRM_PNULL)
    {

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                "Memory allocation to p_meas_config_req failed");
        /* CID 107827 fix Start */
        //rrm_abort();
        RRM_UT_TRACE_EXIT(); 
        return RRM_FAILURE;
        /* CID 107827 fix Stop */

    }
    /*SPR 21148 Start*/
    RRM_MEMSET(p_meas_config_req, RRM_ZERO, sizeof(rrc_rrm_meas_config_req_t));
    /*SPR 21148 End */
    /*Coverity 63910 Fix End */ 
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    for (count = RRM_ZERO; count < p_ue_context->ue_scell_add_params.count; count++)
    {
        /*Check already measurment is configured or not*/
        if (RRM_ZERO ==  p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].meas_bitmask )
        {
            /*configure the measurement and set the bitmask to 1*/
            /*Coverity 63910 Fix Start */ 
            ret_val = rrm_fill_a1_a2_meas_config_object (&p_meas_config_req->meas_config,p_ue_context,
                    p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index);

            p_meas_config_req->ue_index = p_ue_context->ue_index; 
            ret_val = rrm_il_send_rrc_rrm_meas_config_req(p_meas_config_req,
                    RRM_MODULE_ID, RRC_MODULE_ID, RRM_ONE,
                    p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].scell_cell_index);
            /*Coverity 63910 Fix End */ 
            if (RRM_SUCCESS == ret_val)
            {
                /*Storing the meas_id in scell context and set the meas_bitmask i.e meas_config is send for Scell*/
                /*Coverity 63910 Fix Start */ 
                for (index = RRM_ZERO; index < p_meas_config_req->meas_config.meas_id_to_add_mod_list.count; index++)
                {
                    p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].meas_id[index]= 
                        p_meas_config_req->meas_config.meas_id_to_add_mod_list.meas_id_to_add_mod[index].meas_id;
                    /*Coverity 63910 Fix End */ 
                    p_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[count].meas_bitmask |= RRM_ONE;
                }
            }

        }
    }
    RRM_MEM_FREE(p_meas_config_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/******************************************************************************
 *  FUNCTION NAME: rrm_check_active_scell 
 *  INPUT        : p_scell_add_param
 *                 p_scell_active_deactive_list
 *  DESCRIPTION  : Returns the number of active scell in ue_scell_add_params_t 
 *  RETURNS      : NONE
 ******************************************************************************/
    rrm_void_t 
rrm_check_active_scell(rrm_ue_scell_add_params_t *p_scell_add_param, 
        rrm_scell_active_deactive_t *p_scell_active_deactive_list)
{
    U8 index = RRM_ZERO;
    rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
    rrm_bool_t load_present = RRM_FALSE;
    U8   resc_cnt = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    for(index = RRM_ZERO; index < p_scell_add_param->count; index++)
    {
        if(SCELL_ACTIVE == p_scell_add_param->rrm_scell_info_for_ue[index].scell_state) 
        {
            p_scell_active_deactive_list->scell_active_count++;
        }
        else if (SCELL_DEACTIVE == p_scell_add_param->rrm_scell_info_for_ue[index].scell_state)
        {
            p_cell_ctx = rrm_cellm_get_cell_context(p_scell_add_param->rrm_scell_info_for_ue[index].scell_cell_index);
            if((RRM_PNULL != p_cell_ctx) && 
                    (RRM_IS_CA_ELIGIBLE_INFO_PRESENT & p_cell_ctx->operator_info.ca_config.bitmask) &&
                    (RRM_TRUE == p_cell_ctx->operator_info.ca_config.is_ca_eligible) && 
                    /*SPR 11648:start*/
                    (CELL_STATE_ACTIVE == p_cell_ctx->cell_state))
                /*SPR 11648:end*/
            {
                if ((RRM_CELL_LOAD_COMPOSITE_PRESENT == p_cell_ctx->cell_load_action.choice) &&
                        !(RRMCM_ACTN_RRM_SCELL_DEACTIVATE & p_cell_ctx->cell_load_action.u.comp_load_info.actn_status) )
                {
                    p_scell_active_deactive_list->scell_deactive_index[
                        p_scell_active_deactive_list->scell_deactive_count] = index;
                    p_scell_active_deactive_list->scell_deactive_count++;
                }
                else
                {
                    if(RRM_CELL_LOAD_RESRC_SPEC_PRESENT == p_cell_ctx->cell_load_action.choice)
                    {
                        for(resc_cnt = RRM_ZERO; 
                                resc_cnt < p_cell_ctx->cell_load_action.u.resrc_spec_info.count;
                                resc_cnt++)
                        {
                            if (p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resc_cnt].ld_actn.actn_status & 
                                    RRMCM_ACTN_RRM_SCELL_DEACTIVATE)
                            {
                                load_present = RRM_TRUE;
                                break;
                            }
                        }
                    }
                    if(RRM_FALSE == load_present)
                    {
                        p_scell_active_deactive_list->scell_deactive_index[
                            p_scell_active_deactive_list->scell_deactive_count] = index;
                        p_scell_active_deactive_list->scell_deactive_count++;
                    }
                }
            }
        }
    }

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            "Scell active count[%d] deactive count[%d]",
            p_scell_active_deactive_list->scell_active_count,
            p_scell_active_deactive_list->scell_deactive_count);

    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *  FUNCTION NAME: rrm_check_freq_already_configured_for_ca 
 *  INPUT        : U16 eutra_carrier_arfcn, rrm_ue_context_t *p_ue_ctxt
 *  DESCRIPTION  : check inter frequency is already configured as scell or not 
 *  RETURNS      : RRM_TRUE/RRM_FALSE
 ******************************************************************************/
    rrm_bool_et
rrm_check_freq_already_configured_for_ca(inter_freq_cells_t *p_inter_freq, rrm_ue_context_t *p_ue_ctxt)
{
    rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
    rrm_bool_et         ret_val = RRM_FALSE;
    U8                 index = RRM_ZERO;
    rrm_bool_et        scell_deactivated_flag = RRM_FALSE;
    rrm_cell_index_t   cell_index_of_scell = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /*If already A4 is configured for scell. dont send A4 again for same freq.*/
    for(index = RRM_ZERO; index < p_ue_ctxt->ue_scell_add_params.count; index++)
    {
        p_cell_ctx = rrm_cellm_get_cell_context(p_ue_ctxt->ue_scell_add_params.
                rrm_scell_info_for_ue[index].scell_cell_index);
        /*CID 65782:start*/
        if((RRM_PNULL != p_cell_ctx) && (p_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn == 
                    p_inter_freq->eutra_carrier_arfcn)) 
            /*CID 65782:end*/
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                    "eutra_carrier_arfcn[%d] is already added as scell[%d] at index[%d] in ue_scell_add_params",
                    p_inter_freq->eutra_carrier_arfcn, 
                    p_ue_ctxt->ue_scell_add_params.rrm_scell_info_for_ue[index].scell_cell_index,
                    index);
            ret_val = RRM_TRUE;
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
    }
    /*Check mac_instance and cell state */
    rrm_validate_ncl_cell_for_scell_selection(p_inter_freq, p_ue_ctxt->cell_index, 
            &scell_deactivated_flag, &cell_index_of_scell);
    if(RRM_TRUE == scell_deactivated_flag)
    {
        ret_val = RRM_TRUE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*CA Stage3 end*/
/*SPR 11535:start*/
/******************************************************************************
 *  FUNCTION NAME: rrm_handle_ue_inactive 
 *  INPUT        : ue_index, cell_index
 *  DESCRIPTION  : Find ue_context and handle ue_inactivity message from RRC 
 *  RETURNS      : RRM_SUCCESS/RRM_FAILURE
 ******************************************************************************/
rrm_return_et rrm_handle_ue_inactive(rrm_ue_index_t ue_index, 
        rrm_cell_index_t cell_index,
        rrm_ue_global_context_t *p_rrm_glb_ctxt)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    /* SPR 20652 Fix Start */
    /* Code Removed */
    /* SPR 20652 Fix End */
    rrm_ue_context_t *p_ue_context = RRM_PNULL; 
    RRM_UT_TRACE_ENTER();

    /* SPR 21446 start */
    SET_UE_INDEX(ue_index);
    /* SPR 21446 end */
    /** Find the UE context */
    /* SPR 20652 Fix Start */
    p_ue_context = rrm_ue_find_context(ue_index,
            cell_index);
    if (RRM_PNULL != p_ue_context)
    {
        /* SPR 20652 Fix End */
        p_rrm_glb_ctxt->p_ue_context = p_ue_context;
        p_ue_context->ue_event = RRC_RRM_UE_INACTIVE_EVENT;
        p_ue_context->current_procedure.p_proc_data = RRM_NULL;
        ret_val = (rrm_uem_process_fsm(p_ue_context->ue_state,
                    p_ue_context->ue_event,
                    p_rrm_glb_ctxt));

    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR, 
                "UE context not found");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*SPR 11535:end*/

/* SPR 14672 Fix start */
rrm_void_t rrm_fill_rohc_config_ue_ctxt(rrm_ue_context_t *p_ue_context,
        rrm_ue_max_num_rohc_context_session_et  max_rohc_sessions)
{
    RRM_UT_TRACE_ENTER();
    switch(max_rohc_sessions)
    {
        case RRM_UE_CS2:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_TWO;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_ONE;
                break;
            }

        case RRM_UE_CS4:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_TWO;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_TWO;
                break;
            }

        case RRM_UE_CS8:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FOUR;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_TWO;
                break;
            }

        case RRM_UE_CS12:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_THREE;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_FOUR;
                break;
            }

        case RRM_UE_CS16:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FOUR;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_FOUR;
                break;
            }

        case RRM_UE_CS24:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_THREE;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;
            }

        case RRM_UE_CS32:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FOUR;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;
            }

        case RRM_UE_CS48:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_SIX;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;
            }

        case RRM_UE_CS64:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_EIGHT;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;
            }

        case RRM_UE_CS128:
        case RRM_UE_CS256:
        case RRM_UE_CS512:
        case RRM_UE_CS1024:
        case RRM_UE_CS16384:
        case RRM_UE_SPARE2:
        case RRM_UE_SPARE1:
            {
                p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FIFTEEN;
                p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;
                break;
            }
        default:
            p_ue_context->map_data_drb_rohc.max_cid_allocation_per_drb = RRM_FIFTEEN;
            p_ue_context->map_data_drb_rohc.max_count_drbs_rohc_enabled = RRM_EIGHT;

    }
    RRM_UT_TRACE_EXIT();

}
/* SPR 14672 Fix End */

/* Start Fix for SPR 14987 */
/******************************************************************************
 *   FUNCTION NAME: rrm_send_meas_config_request_for_anr
 *   DESCRIPTION:   This function sends meas config request for ANR at UE attach.
 *   RETURNS:       None (rrm_void_t) 
 ******************************************************************************/
rrm_void_t
    rrm_send_meas_config_request_for_anr
(
 rrm_cell_context_t *p_cell_context,
 rrm_ue_context_t   *p_ue_context
 )
{
    U8                                 rat_to_be_configured = p_cell_context->starting_rat_type_for_anr;
    rrm_bool_et                        rat_updated = RRM_FALSE;
    U8                                 last_configured_rat = NO_RAT_CONFIGURED;
    /* SPR 22471 Fix Start */ 
    U16                                carrier_freq = RRM_ZERO;
    meas_eutran_node_t                 *p_meas_eutran_node = RRM_PNULL;
    meas_utran_node_t                  *p_meas_utran_fdd_node = RRM_PNULL;
    meas_utran_tdd_node_t              *p_meas_utran_tdd_node = RRM_PNULL;
    meas_geran_node_t                  *p_meas_geran_node  = RRM_PNULL;
    meas_cdma_node_t                   *p_meas_cdma2000_node = RRM_PNULL;
    /* SPR 22471 Fix End */ 

    RRM_UT_TRACE_ENTER();

    /*Resset the rat_to_be_configured to trigger round robin */
    if(CDMA_RAT < rat_to_be_configured )
    {
        rat_to_be_configured = EUTRAN_RAT; // Considering supported_rats as 1-6
    }

    if ((RRM_PNULL != p_ue_context) && (NO_RAT_CONFIGURED == p_ue_context->rat_configured))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "[UE:%d] & Rat type to be configured= %d",
                p_ue_context->ue_index, rat_to_be_configured);
        do
        {
            switch (rat_to_be_configured)
            {
                case EUTRAN_RAT:
                    /* SPR 22471 Fix Start */
                        if( (UE_SUPPORT_INTRAFREQ_RAT & p_ue_context->supported_rats) ||
                                (UE_SUPPORT_INTERFREQ_RAT & p_ue_context->supported_rats )) 
                        {  
                        p_meas_eutran_node = (meas_eutran_node_t*)rrm_get_first_list_node(&(p_cell_context->meas_eutran_list));
                        while(RRM_PNULL != p_meas_eutran_node)
                        {
                            carrier_freq = p_meas_eutran_node->eutran_config.earfcn;
                            if (RRM_ZERO != rrm_ue_is_ue_supported_eutra_frequency(carrier_freq, p_ue_context))
                            {
                            p_ue_context->rat_configured = EUTRAN_RAT;
                            rat_updated = RRM_TRUE;
                            break;
                        }
                            p_meas_eutran_node = (meas_eutran_node_t*)rrm_get_next_list_node(&p_meas_eutran_node->sNode);
                    }
                        if(RRM_TRUE == rat_updated)
                        {
                            break;
                        }
                    }
                    /* SPR 22471 Fix End */
                    rat_to_be_configured++;
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Measurements NOT requested by SON for EUTRAN or not supported by UE. Moving to new rat %d",
                            rat_to_be_configured);
                    break;		

                case UTRAN_FDD_RAT:
                    /* SPR 22471 Fix Start */
                    if(UE_SUPPORT_UTRAN_RAT & p_ue_context->supported_rats) 
                    {  
                        p_meas_utran_fdd_node = (meas_utran_node_t*)rrm_get_first_list_node(&(p_cell_context->meas_utran_list));
                        while(RRM_PNULL != p_meas_utran_fdd_node)
                    {
                            carrier_freq = p_meas_utran_fdd_node->utran_config.uarfcn;
                            /* SPR 22731 Fix Start */
                            if (RRM_FALSE != rrm_ue_is_ue_supported_utra_fdd_frequency(carrier_freq, p_ue_context))
                                /* SPR 22731 Fix End */
                        {  
                            p_ue_context->rat_configured = UTRAN_FDD_RAT;
                            rat_updated = RRM_TRUE;	
                            break;			
                        }
                            p_meas_utran_fdd_node = (meas_utran_node_t*)rrm_get_next_list_node(&p_meas_utran_fdd_node->sNode);
                        }
                        if(RRM_TRUE == rat_updated)
                        {
                            break;
                        }
                    }
                    /* SPR 22471 Fix End */
                    rat_to_be_configured++;
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Measurements NOT requested by SON for UTRAN FDD or not supported by UE. Moving to new rat %d", 
                            rat_to_be_configured);
                    break;

                case UTRAN_TDD_RAT:
                    /* SPR 22471 Fix Start */
                    if(UE_SUPPORT_UTRAN_RAT & p_ue_context->supported_rats) 
                    {  
                        p_meas_utran_tdd_node = (meas_utran_tdd_node_t*)rrm_get_first_list_node(&(p_cell_context->meas_utran_tdd_list));
                        while(RRM_PNULL != p_meas_utran_tdd_node)
                    {
                            carrier_freq = p_meas_utran_tdd_node->utran_tdd_config.uarfcn_tdd;
                            /* SPR 22731 Fix Start */
                            if (RRM_FALSE != rrm_ue_is_ue_supported_utra_tdd_frequency(carrier_freq, p_ue_context))
                                /* SPR 22731 Fix End */
                        {  
                            p_ue_context->rat_configured = UTRAN_TDD_RAT;
                            rat_updated = RRM_TRUE;	
                            break;			
                        }
                            p_meas_utran_tdd_node = (meas_utran_tdd_node_t*)rrm_get_next_list_node(&p_meas_utran_tdd_node->sNode);
                    }
                        if(RRM_TRUE == rat_updated)
                        {
                            break;
                        }
                    }
                    /* SPR 22471 Fix End */
                    rat_to_be_configured++;
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Measurements NOT requested by SON for UTRAN TDD or not supported by UE. Moving to new rat %d", 
                            rat_to_be_configured);
                    break;			

                case GERAN_RAT:
                    /* SPR 22471 Fix Start */
                    if(UE_SUPPORT_GERAN_RAT & p_ue_context->supported_rats) 
                    {  
                        p_meas_geran_node = (meas_geran_node_t*)rrm_get_first_list_node(&(p_cell_context->meas_geran_list));
                        while(RRM_PNULL != p_meas_geran_node)
                    {
                            carrier_freq = p_meas_geran_node->geran_config.starting_arfcn;
                            if (RRM_FALSE != rrm_ue_is_ue_supported_geran_frequency(carrier_freq, p_ue_context))
                        {  
                            p_ue_context->rat_configured = GERAN_RAT;
                            rat_updated = RRM_TRUE;	
                            break;			
                        }
                            p_meas_geran_node = (meas_geran_node_t*)rrm_get_next_list_node(&p_meas_geran_node->sNode);
                    }
                        if(RRM_TRUE == rat_updated)
                        {
                            break;
                        }
                    }
                    /* SPR 22471 Fix End */
                    rat_to_be_configured++;
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "Measurements NOT requested by SON for GERAN or not supported by UE. Moving to new rat %d", 
                            rat_to_be_configured);
                    break;			

                case CDMA_RAT:
                    /* SPR 22471 Fix Start */
                    if((UE_SUPPORT_HRPD_RAT & p_ue_context->supported_rats) || (UE_SUPPORT_1XRTT & p_ue_context->supported_rats))
                    {  
                        p_meas_cdma2000_node = (meas_cdma_node_t*)rrm_get_first_list_node(&(p_cell_context->meas_cdma_list));
                        while(RRM_PNULL != p_meas_cdma2000_node)
                    {
                            if (RRM_FALSE != rrm_ue_is_ue_supported_cdma2000_frequency(p_meas_cdma2000_node->cdma_config.cdma_type, 
                                        p_meas_cdma2000_node->cdma_config.band_class, p_ue_context))
                        {  
                            p_ue_context->rat_configured = CDMA_RAT;
                            rat_updated = RRM_TRUE;
                            break;
                        }
                            p_meas_cdma2000_node = (meas_cdma_node_t*)rrm_get_next_list_node(&p_meas_cdma2000_node->sNode);
                        }
                        if(RRM_TRUE == rat_updated)
                        {
                            break;
                        }
                    }
                    /* SPR 22471 Fix End */
                    rat_to_be_configured = EUTRAN_RAT;
                    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                            "Measurements NOT requested by SON for CDMA or not supported by UE. Moving to new rat %d",
                            rat_to_be_configured);
                    break;			

                default :
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                            "[UE:%d] has no supported rat type",
                            p_ue_context->ue_index);
            }
        } while((RRM_TRUE != rat_updated) && (p_cell_context->starting_rat_type_for_anr != rat_to_be_configured));

        if(RRM_FALSE == rat_updated)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Could not send meas config request for ANR for [UE:%d] = RAT %d.",
                    p_ue_context->ue_index, p_cell_context->starting_rat_type_for_anr);
            RRM_UT_TRACE_EXIT();
            return;
        }
        if(RRM_FAILURE == rrm_build_and_send_meas_config_req(
                    p_ue_context, MEAS_TYPE_ANR))
        {
            rrm_uem_check_and_reset_meas_config_struct(p_ue_context);
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                    "Failure in sending meas config requst for [UE:%d]",
                    p_ue_context->ue_index);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_DETAILED,
                    "Meas Config Request sent for [UE:%d] for rat type [%d]",
                    p_ue_context->ue_index, p_ue_context->rat_configured);
            p_ue_context->meas_status = RRM_MEAS_CONFIG_REQ_SENT;
            /*+- SPR 16658*/
            p_cell_context->num_anr_strong_cell_req_sent++;
            last_configured_rat = p_ue_context->rat_configured;

            /* Update Starting RAT type to be configured for next ANR meas config req */
            rrm_set_last_configured_rat(p_cell_context,&last_configured_rat);
            p_cell_context->starting_rat_type_for_anr = last_configured_rat;
        }
        p_ue_context->rat_configured = NO_RAT_CONFIGURED;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
                "UE context is NULL OR RAT already configured for the UE");
    }

    RRM_UT_TRACE_EXIT();
    return ;
}
/* End Fix for SPR 14987 */
/***********************************************************************************
 * Function Name  : rrm_is_anr_allowed_on_eutran_freq
 * Inputs         : p_ue_cntxt
 * Outputs        : None
 * Returns        : TRUE/FALSE
 * Description    : This function returns TRUE if a fgi bit is set, returns FALSE
 *                  otherwise
 ************************************************************************************/
    rrm_bool_et 
rrm_is_anr_allowed_on_eutran_freq(
        rrm_ue_context_t *p_ue_context,
        U32     earfcn)
{
    rrm_cell_context_t      *p_cell_context = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    p_cell_context = rrm_cellm_get_cell_context(p_ue_context->cell_index);
    /*Coverity 94863 Fix Start*/ 
    if(RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_ERROR,
                "Cell Context not found[%d]",p_ue_context->cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FALSE;
    }
    /*Coverity 94863 Fix End*/ 
    if (earfcn == p_cell_context->ran_info.rf_params.rf_configurations.dl_earfcn)
    {
        if (p_ue_context->supported_rats & UE_SUPPORT_INTRAFREQ_RAT)
        {
            RRM_UT_TRACE_EXIT();
            return RRM_TRUE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Bit 17 is not set cannot do ANR for Intra EARFCN [%u]", earfcn);
        }
    }
    else
    {
        if (p_ue_context->supported_rats & UE_SUPPORT_INTERFREQ_RAT)
        {
            RRM_UT_TRACE_EXIT();
            return RRM_TRUE;
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "Bit 18 or 25 is not set cannot do ANR for Inter EARFCN [%u]", earfcn);
        }
    }

    RRM_UT_TRACE_EXIT();
    return RRM_FALSE;
}
/* SPR 16406 8SEP start */

/* SPR 16042 start */
/******************************************************************************
 *   FUNCTION NAME: rrm_uem_remove_cgi_report_config
 *   DESCRIPTION:
 *          This function remove the report and the corresponding Meas Id from the structure
 *   RETURNS:
 *             rrm_void_et
 ******************************************************************************/
    rrm_void_t
rrm_uem_remove_cgi_report_config(
        rrm_ue_context_t *p_ue_context,
        U8 report_id
        )
{
    U8 i = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Removing report for Report Id: %d", report_id);
    for (i = RRM_ZERO; i < RRM_ANR_MAX_MEAS_OBJ; i++)
    {
        if (p_ue_context->p_meas_config[i].report_id == report_id)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Successfully Removed MeasId Id: %d", p_ue_context->p_meas_config[i].meas_id);
            p_ue_context->p_meas_config[i].report_id = RRM_ZERO;
            p_ue_context->p_meas_config[i].meas_id = RRM_ZERO;
            p_ue_context->p_meas_config[i].cgi_req_cnt = RRM_ZERO;
            p_ue_context->p_meas_config[i].cgi_success_cnt = RRM_ZERO;
            p_ue_context->p_meas_config[i].cgi_resp_status =
                (rrm_return_et)RRM_ZERO;/*cov 87061 + -*/
            p_ue_context->p_meas_config[i].report_counter = RRM_ZERO;
        }

    }

    RRM_UT_TRACE_EXIT();
}
/* SPR 16042 end */
/* SPR 20653 Fix Start */
rrm_void_t
    get_rat_priority
(
 rrm_oam_rat_priority_list_t  *p_rrm_rat_priority_list,
 rrm_oam_rat_priority_info_et *p_get_eutran_priority,
 rrm_oam_rat_priority_info_et *p_get_utran_priority,
 rrm_oam_rat_priority_info_et *p_get_geran_priority,
 rrm_oam_rat_priority_info_et *p_get_cdma_priority
)
{ 
    U8  rat_count = RRM_ZERO;
    for(rat_count = 0; rat_count < p_rrm_rat_priority_list->rat_count; rat_count++) 
    {
        switch(p_rrm_rat_priority_list->rrm_rat_priority_info[rat_count].rat_type)
    {
        case RRM_OAM_IRAT_EUTRAN:
                *p_get_eutran_priority = (rrm_oam_rat_priority_info_et)rat_count; 
                RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                        "get_eutran_priority = %d", *p_get_eutran_priority);
            break;
        case RRM_OAM_IRAT_UTRAN:
                *p_get_utran_priority = (rrm_oam_rat_priority_info_et)rat_count; 
                RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                        "get_utran_priority = %d", *p_get_utran_priority);
            break;
        case RRM_OAM_IRAT_GERAN:
                *p_get_geran_priority = (rrm_oam_rat_priority_info_et)rat_count; 
                RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                        "get_geran_priority = %d", *p_get_geran_priority);
            break;
        case RRM_OAM_IRAT_CDMA2000:
                *p_get_cdma_priority = (rrm_oam_rat_priority_info_et)rat_count; 
                RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                        "get_cdma_priority = %d", *p_get_cdma_priority);
            break;
        default:
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                        "INVALID rat type %d", p_rrm_rat_priority_list->rrm_rat_priority_info[rat_count].rat_type);
        }
    }
}
/* SPR 20653 Fix End */
/* SPR 21446 start */
/****************************************************************************
 * Function Name  : rrm_print_fgi_bits 
 * Inputs         : UE context
 * Outputs        : None
 * Returns        : None
 * Description    : This function prints the FGI bits in log 
 ****************************************************************************/
rrm_void_t
rrm_print_fgi_bits(
        rrm_ue_context_t  *p_ue_context
        )
{
    RRM_UT_TRACE_ENTER();

    if(p_ue_context->ue_capability_params.bitmask & RRM_UE_EUTRA_RADIO_CAPABILITY_PRESENT)
    {
        if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.bitmask &
                    RRM_UE_EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
          )
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                    "Rel8:feature_group_indicators 0x%x",
                    p_ue_context->ue_capability_params.
                    rrm_eutra_radio_capability_info.
                    eutra_radio_capability_info_def.feature_group_indicators);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                    "No FGI Rel8");
        }

        if((p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.bitmask &
                    RRM_UE_EUTRA_CAPABILITY_V920_IES_PRESENT)
                &&
                (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                 ue_eutra_capability_v920_ies.bitmask &
                 RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT))
        {
            if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask & RRC_UE_EUTRA_CAPABILITY_V9a0_IES_PRESENT)
            {
                if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.bitmask &
                        RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_REL9_ADD_PRESENT)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                            "Rel9_v9a0:feature_group_indicators 0x%x",
                            p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.feature_group_ind_rel9add_r9);
                }
                if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.bitmask &
                        RRM_UE_EUTRA_CAPABILITY_ADDFDD_MODE_R9_PRESENT)
                {
                    if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.fdd_add_ue_eutra_capabilities_r9.bitmask &
                            RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_INDICATORS_R9_PRESENT)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                "Rel9_fddadd:feature_group_indicators 0x%x",
                                p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v9a0_ies.fdd_add_ue_eutra_capabilities_r9.feature_group_indicators_r9);
                    }
                    if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.fdd_add_ue_eutra_capabilities_r9.bitmask &
                            RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_R9ADD_PRESENT)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                "Rel9_fddadd:feature_group_indicators 0x%x",
                                p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.
                                ue_eutra_capability_v9a0_ies.fdd_add_ue_eutra_capabilities_r9.feature_group_ind_rel9add_r9);
                    }
                }
                if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.bitmask &
                        RRM_UE_EUTRA_CAPABILITY_ADDTDD_MODE_R9_PRESENT)
                {
                    if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.tdd_add_ue_eutra_capabilities_r9.bitmask &
                            RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_INDICATORS_R9_PRESENT)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                "Rel9_tddadd:feature_group_indicators 0x%x",
                                p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.
                                tdd_add_ue_eutra_capabilities_r9.feature_group_indicators_r9);
                    }
                    if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.tdd_add_ue_eutra_capabilities_r9.bitmask &
                            RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_R9ADD_PRESENT)
                    {
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                                "Rel9_tddadd:feature_group_indicators 0x%x",
                                p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                                ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v9a0_ies.
                                tdd_add_ue_eutra_capabilities_r9.feature_group_ind_rel9add_r9);
                    }
                }
            }

            if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                    ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT)
            {
                if (p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                        ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.bitmask &
                        RRM_UE_EUTRA_CAPABILITY_V1020_FEATUREGROUP_IND_R10_PRESENT)
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                            "Rel9_tddadd:feature_group_indicators 0x%x",
                            p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.
                            ue_eutra_capability_v920_ies.ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.featuregroup_ind_r10);
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "No FGI provided");
    }

    RRM_UT_TRACE_EXIT();
    return;
}
/* SPR 21446 end */

/* SPR 21496 Fix Start */
/***********************************************************************************
 * Function Name  : rrm_ue_release_ue_capability_params
 * Inputs         : p_ue_context
 * Outputs        : None
 * Returns        : void
 * Description    : This function frees the memory allocated to pointers of UE capability
 *                  at the time of UE release
 ************************************************************************************/
rrm_void_t
rrm_ue_release_ue_capability_params(rrm_ue_context_t *p_ue_context)
{
    U8 count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.
        meas_parameters.band_list_eutra.p_band_info_eutra)
    {
      RRM_MEM_FREE(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.eutra_radio_capability_info_def.
          meas_parameters.band_list_eutra.p_band_info_eutra);
    }
    if(RRM_PNULL != p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
        ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.rf_parameters_v1020.supported_band_combination_r10.p_band_combination_parameters_r10)
    {
        for(count = RRM_ZERO; count < p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
            ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.rf_parameters_v1020.supported_band_combination_r10.count; count++)
        {
            if(RRM_PNULL != p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                    ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.rf_parameters_v1020.supported_band_combination_r10.
                    p_band_combination_parameters_r10[count].p_band_parameters_info)
            {
                RRM_MEM_FREE(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                        ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.rf_parameters_v1020.supported_band_combination_r10.
                        p_band_combination_parameters_r10[count].p_band_parameters_info);
            }
        }
        RRM_MEM_FREE(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
                ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.rf_parameters_v1020.supported_band_combination_r10.p_band_combination_parameters_r10);
    }
    if(RRM_PNULL != p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
        ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
        supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10)
    {
      RRM_MEM_FREE(p_ue_context->ue_capability_params.rrm_eutra_radio_capability_info.ue_eutra_capability_v920_ies.
          ue_eutra_capability_v940_ies.ue_eutra_capability_v1020_ies.ue_eutra_capability_v1060.rf_parameters_v1060.
          supported_band_combination_ext_r10.p_band_combination_parameters_ext_r10);
    }
    if(RRM_PNULL != p_ue_context->ho_restriction_list.equiv_plmn_list.p_equiv_plmn)
    {
      RRM_MEM_FREE(p_ue_context->ho_restriction_list.equiv_plmn_list.p_equiv_plmn);
    }
    if(RRM_PNULL != p_ue_context->ho_restriction_list.forbidden_ta_list.p_forbidden_ta)
    {
        for(count = RRM_ZERO; count < p_ue_context->ho_restriction_list.forbidden_ta_list.count; count++)
        {
            if(RRM_PNULL != p_ue_context->ho_restriction_list.forbidden_ta_list.p_forbidden_ta[count].forbidden_tac.p_forbidden_tac)
            {
                RRM_MEM_FREE(p_ue_context->ho_restriction_list.forbidden_ta_list.p_forbidden_ta[count].forbidden_tac.p_forbidden_tac);
            }
        }
        RRM_MEM_FREE(p_ue_context->ho_restriction_list.forbidden_ta_list.p_forbidden_ta);
    }
    if(RRM_PNULL != p_ue_context->ho_restriction_list.forbidden_la_list.p_forbidden_la)
    {
        for(count = RRM_ZERO; count < p_ue_context->ho_restriction_list.forbidden_la_list.count; count++)
        {
            if(RRM_PNULL != p_ue_context->ho_restriction_list.forbidden_la_list.p_forbidden_la[count].forbidden_lacs_list.p_forbidden_lac)
            {
                RRM_MEM_FREE(p_ue_context->ho_restriction_list.forbidden_la_list.p_forbidden_la[count].forbidden_lacs_list.p_forbidden_lac);
            }
        }
        RRM_MEM_FREE(p_ue_context->ho_restriction_list.forbidden_la_list.p_forbidden_la);
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 21496 Fix End */

/* SPR 21614 start */
/***********************************************************************************
 * Function Name  : rrm_is_update_required_in_cell_select
 * Inputs         : Cell context and PCI of UTRAN
 * Outputs        : None
 * Returns        : void
 * Description    : This function check if PhyCellId reported is valid to be
 *                  added in the cell selection list or not
 ************************************************************************************/
rrm_bool_et rrm_is_update_required_in_cell_select(
    rrm_cell_context_t    *p_cell_ctxt,
    rrm_son_utran_physical_cell_id_t *p_pci
    )
{
    U16         pci     = RRM_ZERO;
    U16         i       = RRM_ZERO;
    rrm_bool_et ret_val = RRM_FALSE;
    inter_rat_ncl_t *p_irat_ncl = RRM_PNULL;    

    RRM_UT_TRACE_ENTER();

    if ((RRM_PNULL != p_cell_ctxt) && (RRM_PNULL != p_pci))
    {
    if (p_pci->bitmask & RRM_PCI_FDD_PRESENT)
    {
        pci = p_pci->pci_fdd;
    }
    else if (p_pci->bitmask & RRM_PCI_TDD_PRESENT)
    {
        pci = p_pci->pci_tdd;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                "PCI bitmask not set for UTRAN neighbour reported in measuement result");
        RRM_UT_TRACE_EXIT();
        return ret_val;
    }
    p_irat_ncl = rrm_cellm_get_inter_rat_ncl_info(p_cell_ctxt->cell_index);

    if (RRM_PNULL != p_irat_ncl)
    {
        for (i = RRM_ZERO; i < p_irat_ncl->num_valid_utran_freq_cell; i++)
        {
            if (pci == p_irat_ncl->utran_freq_cells[i].pcpich_scrambling_code)
            {
                if (RRM_FALSE == p_irat_ncl->utran_freq_cells[i].blacklisted)
                {
                    ret_val = RRM_TRUE;
                }
                else
                {
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
                        "PCI [%d] is blacklisted hence ignored for handover", pci);
                }
                break;
            }
        }
    }
    }
    return ret_val;
    RRM_UT_TRACE_EXIT();
}
/* SPR 21614 end */


